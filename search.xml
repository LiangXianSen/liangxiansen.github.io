<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python Web框架之Tornado]]></title>
      <url>http://www.liangxiansen.cn/2018/04/11/tornado/</url>
      <content type="html"><![CDATA[<h2 id="Tornado-介绍"><a href="#Tornado-介绍" class="headerlink" title="Tornado 介绍"></a>Tornado 介绍</h2><p>Tornado 是 FriendFeed 使用的可扩展的非阻塞式 web 服务器及其相关工具的开源版本。这个 Web 框架看起来有些像web.py 或者 Google 的 webapp，不过为了能有效利用非阻塞式服务器环境，这个 Web 框架还包含了一些相关的有用工具 和优化。</p>
<p>Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其 非阻塞的方式和对 <a href="http://www.www.kernel.org/doc/man-pages/online/pages/man4/epoll.4.html" target="_blank" rel="noopener">epoll</a> 的运用，Tornado 每秒可以处理数以千计的连接，这意味着对于实时 Web 服务来说，Tornado 是一个理想的 Web 框架。我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。（关于如何扩容 服务器，以处理数以千计的客户端的连接的问题，请参阅 <a href="http://www.www.kegel.com/c10k.html" target="_blank" rel="noopener">C10K problem</a>。）</p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><pre><code>pip install tornado

源码安装
https://pypi.python.org/packages/source/t/tornado/tornado-4.3.tar.gz
</code></pre><a id="more"></a>
<h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-

import tornado.ioloop
import tornado.web

# 继承tornado.web.RequestHandler
class MainHandler(tornado.web.RequestHandler):
    # 如果用户是GET请求，将执行这个类的get方法
    def get(self):
        self.write(&quot;Hello, world&quot;)

# 路由映射
application = tornado.web.Application([
    # 访问index页面，交由MainHandler类处理
    (r&quot;/index&quot;, MainHandler),
])


if __name__ == &quot;__main__&quot;:
    # 内部创建了个socket，侦听8888端口
    application.listen(8888)
    # epool + socket
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<p>执行过程：</p>
<ul>
<li>第一步：运行程序，启动 8888 端口侦听</li>
<li>第二步：浏览器客户端访问 /index  –&gt;  <a href="http://127.0.0.1:8888/index" target="_blank" rel="noopener">http://127.0.0.1:8888/index</a></li>
<li>第三步：服务器接受请求，并交由对应的类处理该请求</li>
<li>第四步：类接受到请求之后，根据请求方式（post / get / delete …）的不同调用并执行相应的方法（Resutful方式）</li>
<li>第五步：方法返回值的字符串内容发送到用户浏览器</li>
</ul>
<h3 id="Tronado-原生支持Resutful"><a href="#Tronado-原生支持Resutful" class="headerlink" title="Tronado 原生支持Resutful"></a>Tronado 原生支持Resutful</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import tornado.ioloop
import tornado.web


class MainHandler(tornado.web.RequestHandler):
    # 不同类型的请求执行下面相应的方法
    def get(self):
        self.write(&quot;GET, Test Site&quot;)

    def post(self):
        self.write(&quot;POST, Test Site&quot;)

    def delete(self):
        self.write(&quot;DEL, Test Site&quot;)

    def put(self):
        self.write(&quot;PUT, Test Site&quot;)

# 内部其实就是通过反射实现的
# obj = MainHandler()
# func = getattr(obj, &#39;get&#39;)
# func()

application = tornado.web.Application([
    (r&quot;/index&quot;, MainHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<h3 id="处理表单请求"><a href="#处理表单请求" class="headerlink" title="处理表单请求"></a>处理表单请求</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.ioloop
import tornado.web


class MyFormHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/&quot; method=&quot;POST&quot;&gt;&#39;
                   &#39;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&#39;
                   &#39;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&#39;
                   &#39;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#39;)

    def post(self):
        self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)
        self.write(&quot;You wrote &quot; + self.get_body_argument(&quot;message&quot;))  # 获取form表单内容


def make_app():
    return tornado.web.Application([
        (r&quot;/&quot;, MyFormHandler),
    ])


if __name__ == &quot;__main__&quot;:
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()
</code></pre>
<h3 id="POST-application-json"><a href="#POST-application-json" class="headerlink" title="POST application/json"></a>POST application/json</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import json
import tornado.ioloop
import tornado.web


class BaseHandler(tornado.web.RequestHandler):

    def initialize(self):
        self.json_args = None

    def prepare(self):
        &quot;&quot;&quot;
        复习接收到请求后做的准备操作，然后再执行HTTP方法（post/get/...）。
        :return:
        &quot;&quot;&quot;
        if self.request.headers[&quot;Content-Type&quot;].startswith(&quot;application/json&quot;):
            self.json_args = json.loads(self.request.body)
        else:
            # 我这个接口只定义是传输数据类型是json， 那么在处理请求前做一个json处理
            # 如果不是json 数据类型就直接设置一个错误状态码，返回一个错误信息。
            self.set_status(405)
            self.write({&quot;error&quot;: &quot;ARGUMENT_ERROR: Not application/json&quot;})
            self.finish()  # 关闭链接

    def on_finish(self):
        &quot;&quot;&quot;
        请求结束后被调用，一般用于清理资源
        :return:
        &quot;&quot;&quot;
        pass


class MainHandler(BaseHandler):

    def post(self):
        if self.json_args:
            self.write(self.json_args)  # 如果数据类型就是Json，response数据类型application/json


def make_app():
    return tornado.web.Application([
        (r&quot;/&quot;, MainHandler),
    ])


if __name__ == &quot;__main__&quot;:
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()
</code></pre>
<h3 id="Flush-mothed"><a href="#Flush-mothed" class="headerlink" title="Flush mothed"></a>Flush mothed</h3><p>将当前输出缓冲区写到网络.</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import time
from tornado.web import RequestHandler, Application
from tornado.ioloop import IOLoop


class FlushHandler(RequestHandler):
    def get(self, *args, **kwargs):
        self.write(&#39;start\n&#39;)
        self.flush()
        for x in range(5):
            self.write(&#39;{0}\n&#39;.format(x))
            self.flush()       # 这里是一个for的循环体，这个方法可以将上面的write实时显示到用户浏览器上，如果去掉，你会发现整个循环体结束然后将最终结果显示在用户浏览器上。
            time.sleep(1)
        self.finish(&#39;stop\n&#39;)

def make_app():
    return Application([
        (r&#39;/flush&#39;, FlushHandler),
    ])


if __name__ == &#39;__main__&#39;:
    app = make_app()
    app.listen(port=8888)
    IOLoop.current().start()
</code></pre>
<h2 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h2><p>路由系统其实就是 url 和 类 的对应关系，这里不同于其他框架，其他很多框架均是 url 对应函数，Tornado中每个url对应的是一个类。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
import tornado.ioloop
import tornado.web


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;Hello, world&quot;)


class CMDBHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;cmdb.lianglian.com&quot;)

application = tornado.web.Application([
    (r&quot;/index&quot;, MainHandler),
])

# 添加一个二级域名
application.add_handlers(&#39;cmdb.lianglian.com&#39;, [
    (r&#39;/index&#39;, CMDBHandler),
])

if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<blockquote>
<p>Note： 本地测试先配置好系统hosts文件域名指向</p>
</blockquote>
<p>路由表是 <a href="http://tornado-zh.readthedocs.io/zh/latest/web.html#tornado.web.URLSpec" target="_blank" rel="noopener"><code>URLSpec</code></a> 对象(或元组)的列表, 其中每个都包含(至少)一个正则 表达式和一个处理类. 顺序问题; 第一个匹配的规则会被使用. 如果正则表达 式包含捕获组, 这些组会被作为 <em>路径参数</em> 传递给处理函数的HTTP方法. 如果一个字典作为 <a href="http://tornado-zh.readthedocs.io/zh/latest/web.html#tornado.web.URLSpec" target="_blank" rel="noopener"><code>URLSpec</code></a> 的第三个参数被传递, 它会作为 <em>初始参数</em> 传递给 <a href="http://tornado-zh.readthedocs.io/zh/latest/web.html#tornado.web.RequestHandler.initialize" target="_blank" rel="noopener"><code>RequestHandler.initialize</code></a>. 最后 <a href="http://tornado-zh.readthedocs.io/zh/latest/web.html#tornado.web.URLSpec" target="_blank" rel="noopener"><code>URLSpec</code></a> 可能有一个名字 , 这将允许它被 <a href="http://tornado-zh.readthedocs.io/zh/latest/web.html#tornado.web.RequestHandler.reverse_url" target="_blank" rel="noopener"><code>RequestHandler.reverse_url</code></a> 使用.</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.ioloop
import tornado.web


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;&lt;a href=&quot;%s&quot;&gt;link to story 1&lt;/a&gt;&#39; % self.reverse_url(&quot;story&quot;, &quot;1&quot;))   # /story/1


class StoryHandler(tornado.web.RequestHandler):
    def initialize(self):
        pass

    def get(self, story_id):
        self.write(&quot;this is story %s&quot; % story_id)


def make_app():
    return tornado.web.Application([
        tornado.web.url(r&quot;/&quot;, MainHandler),
        # Tornado通过正则表达式做到分页
        tornado.web.url(r&quot;/story/([0-9]+)&quot;, StoryHandler, name=&quot;story&quot;)  # 设置name属性可以在self.reverse_url被调用
    ])


if __name__ == &quot;__main__&quot;:
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()
</code></pre>
<h3 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h3><p>Tornado中原生支持二级域名的路由，如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">主机头</th>
<th style="text-align:left">url正则</th>
<th style="text-align:left">Handler</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cmdb</td>
<td style="text-align:left">/index/\d*</td>
<td style="text-align:left">CMDBHandler</td>
</tr>
<tr>
<td style="text-align:left">cmdb</td>
<td style="text-align:left">/admin/\w*</td>
<td style="text-align:left">AdminHandler</td>
</tr>
<tr>
<td style="text-align:left">cmdb</td>
<td style="text-align:left">/car/\w*</td>
<td style="text-align:left">CarHandler</td>
</tr>
<tr>
<td style="text-align:left">*.</td>
<td style="text-align:left">/index/\w*</td>
<td style="text-align:left">HomeHandler</td>
</tr>
<tr>
<td style="text-align:left">*.</td>
<td style="text-align:left">/pro/\w*</td>
<td style="text-align:left">ProHandler</td>
</tr>
<tr>
<td style="text-align:left">*.</td>
<td style="text-align:left">/.*</td>
<td style="text-align:left">AllHandler</td>
</tr>
</tbody>
</table>
<h2 id="模板语言"><a href="#模板语言" class="headerlink" title="模板语言"></a>模板语言</h2><p>Tornado中的模板语言和django中类似，模板引擎将模板文件载入内存，然后将数据嵌入其中，最终获取到一个完整的字符串，再将字符串返回给请求者。<br>
Tornado 的模板支持“控制语句”和“表达语句”，控制语句是使用{% 和 %}包起来的 例如 {% if len(items) > 2 %}。表达语句是使用 {{ 和 }} 包起来的，例如 {{ items[0] }}。
</p>
<p>
控制语句和对应的 Python 语句的格式基本完全相同。我们支持 if、for、while 和 try，这些语句逻辑结束的位置需要用 {% end %} 做标记。还通过 "extends" 和 "block" 语句实现了模板继承。这些在 <a href="http://www.github.com/facebook/tornado/blob/master/tornado/template.py" target="_blank" rel="noopener">template 模块</a> 的代码文档中有着详细的描述。</p>
<blockquote>
<p>注：在使用模板前需要在setting中设置模板路径：”template_path” : “Templates”</p>
</blockquote>
<h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
import tornado.ioloop
import tornado.web


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        # self.write(&quot;Hello, world&quot;)
        self.render(&#39;main.html&#39;, li=[11, 22, 33, 44])  # 返回一个html页面和一个数组&quot;li&quot;

# 配置模板文件路径
settings = {
    &#39;template_path&#39;: &#39;Templates&#39;,  # 本地Templates文件夹
}

application = tornado.web.Application([
    (r&quot;/index&quot;, MainHandler),
], **settings)  # 把settings这个字典传给application，配置生效


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<p>Tornado中模板语言里面语法和python基本一样,这也是Tornado前端用python语法直接写逻辑很强大。</p>
<p><img src="http://www.liangxiansen.cn/images/tornado/模版语法.png" alt="模版语言"></p>
<p>在模板中默认提供了一些函数、字段、类以供模板使用：</p>
<pre><code>escape: tornado.escape.xhtml_escape 的別名
xhtml_escape: tornado.escape.xhtml_escape 的別名
url_escape: tornado.escape.url_escape 的別名
json_encode: tornado.escape.json_encode 的別名
squeeze: tornado.escape.squeeze 的別名
linkify: tornado.escape.linkify 的別名
datetime: Python 的 datetime 模组
handler: 当前的 RequestHandler 对象
request: handler.request 的別名
current_user: handler.current_user 的別名
locale: handler.locale 的別名
_: handler.locale.translate 的別名
static_url: for handler.static_url 的別名
xsrf_form_html: handler.xsrf_form_html 的別名
</code></pre><h3 id="模版继承"><a href="#模版继承" class="headerlink" title="模版继承"></a>模版继承</h3><p>Tornado中的模版继承和Django中一样，通过一个大的母版，规定一个大体框架内容，子版继承母版得内容后只需要写自己的内容就行了。</p>
<h4 id="母版（main-html）"><a href="#母版（main-html）" class="headerlink" title="母版（main.html）"></a>母版（main.html）</h4><p><img src="http://www.liangxiansen.cn/images/tornado/母版.png" alt="母版"></p>
<h4 id="子版"><a href="#子版" class="headerlink" title="子版"></a>子版</h4><p><img src="http://www.liangxiansen.cn/images/tornado/子版.png" alt="子版"></p>
<h3 id="模板导入"><a href="#模板导入" class="headerlink" title="模板导入"></a>模板导入</h3><ul>
<li>header.html</li>
</ul>
<pre><code class="html">&lt;div&gt;
    &lt;ul&gt;
        &lt;li&gt;1024&lt;/li&gt;
        &lt;li&gt;42区&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>index.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;
    &lt;title&gt;Index&lt;/title&gt;
    &lt;link href=&quot;{{static_url("css/common.css")}}&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class=&quot;pg-header&quot;&gt;
        {% include 'header.html' %} # 导入header.html得内容到这里
    &lt;/div&gt;

    &lt;script src=&quot;{{static_url("js/jquery-1.8.2.min.js")}}&quot;&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="UIMethod和UIModule"><a href="#UIMethod和UIModule" class="headerlink" title="UIMethod和UIModule"></a>UIMethod和UIModule</h3><ul>
<li>定义</li>
</ul>
<pre><code class="python"># uimethods.py

def tab(self):
    return &#39;UIMethod&#39;
</code></pre>
<pre><code class="python"># uimodules.py

#!/usr/bin/env python
# -*- coding:utf-8 -*-
from tornado.web import UIModule
from tornado import escape

class custom(UIModule):

    def render(self, *args, **kwargs):
        return escape.xhtml_escape(&#39;&lt;h1&gt;wupeiqi&lt;/h1&gt;&#39;)
        #return escape.xhtml_escape(&#39;&lt;h1&gt;wupeiqi&lt;/h1&gt;&#39;)
</code></pre>
<ul>
<li>注册</li>
</ul>
<pre><code class="python">import tornado.ioloop
import tornado.web
import uimodules  # 导入刚刚写的uimodules.py
import uimethods  # 导入刚刚写的uimodules.py


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        # self.write(&quot;Hello, world&quot;)
        self.render(&#39;index.html&#39;, li=[11, 22, 33, 44])  # 返回一个html页面和一个数组&quot;li&quot;


# 配置
settings = {
    &#39;template_path&#39;: &#39;Templates&#39;,
    &#39;static_path&#39;: &#39;static&#39;,
    &#39;static_url_prefix&#39;: &#39;/statics/&#39;,
    &#39;ui_methods&#39;: uimethods,  # 在settings中注册我写的uimethods.py
    &#39;ui_modules&#39;: uimodules,  # 在settings中注册我写的uimodules.py
}

application = tornado.web.Application([
    (r&quot;/index&quot;, MainHandler),
], **settings)  # 把settings这个字典传给application，配置生效


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<ul>
<li>使用</li>
</ul>
<p><img src="http://www.liangxiansen.cn/images/tornado/UIMethod.png" alt="子版"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>Tornado默认是单进程单线程。实时的web特性通常需要为每个用户一个大部分时间都处于空闲的长连接. 在传统的同步web服务器中,这意味着需要给每个用户分配一个专用的线程,这样的开销是十分巨大的.</p>
<p>为了减小对于并发连接需要的开销,Tornado使用了一种单线程事件循环的方式. 这意味着所有应用程序代码都应该是异步和非阻塞的,因为在同一时刻只有一个操作是有效的.</p>
<p>Tornado 中推荐用 <strong>协程</strong> 来编写异步代码. 协程使用 Python 中的关键字 <code>yield</code> 来替代链式回调来实现挂起和继续程序的执行(像在 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 中使用的轻量级线程合作的方法有时也称作协程, 但是在 Tornado 中所有协程使用异步函数来实现的明确的上下文切换).</p>
<h3 id="同步阻塞（Blocking）"><a href="#同步阻塞（Blocking）" class="headerlink" title="同步阻塞（Blocking）"></a>同步阻塞（Blocking）</h3><p>一个函数通常在它等待返回值的时候被 <strong>阻塞</strong> .一个函数被阻塞可能由于很多原因: 网络I/O,磁盘I/O,互斥锁等等.事实上, <em>每一个</em> 函数都会被阻塞,只是时间会比较短而已, 当一个函数运行时并且占用CPU(举一个极端的例子来说明为什么CPU阻塞的时间必须考虑在内, 考虑以下密码散列函数像<a href="http://bcrypt.sourceforge.net/" target="_blank" rel="noopener">bcrypt</a>, 这个函数需要占据几百毫秒的CPU时间, 远远超过了通常对于网络和磁盘请求的时间). 一个函数可以在某些方面阻塞而在其他方面不阻塞.举例来说, <a href="http://tornado-zh-cn.readthedocs.io/zh_CN/latest/httpclient.html#module-tornado.httpclient" target="_blank" rel="noopener"><code>tornado.httpclient</code></a> 在默认设置下将阻塞与DNS解析,但是在其它网络请求时不会阻塞 (为了减轻这种影响,可以用 <a href="http://tornado-zh-cn.readthedocs.io/zh_CN/latest/netutil.html#tornado.netutil.ThreadedResolver" target="_blank" rel="noopener"><code>ThreadedResolver</code></a> 或通过正确配置 <code>libcurl</code> 使用 <code>tornado.curl_httpclient</code> ). 在Tornado的上下文中我们通常讨论网络I/O上下文阻塞, 虽然各种阻塞已经被最小化了.</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import time
import tornado.web


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;index&#39;)


def doing():
    time.sleep(10)
    return &#39;Blocking&#39;


class BlockingHandler(tornado.web.RequestHandler):
    def get(self):
        result = doing()
        self.write(result)


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/blocking&quot;, BlockingHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<ul>
<li>浏览器访问：<a href="http://127.0.0.1:8888/index" target="_blank" rel="noopener">http://127.0.0.1:8888/index</a></li>
<li>浏览器访问：<a href="http://127.0.0.1:8888/blocking" target="_blank" rel="noopener">http://127.0.0.1:8888/blocking</a></li>
<li>你会发现blocking会一直在转圈，处于一个堵塞状态。</li>
<li>你再访问index页面，你发现index页面也会堵塞住。</li>
</ul>
<h3 id="异步非阻塞（Non-Blocking）"><a href="#异步非阻塞（Non-Blocking）" class="headerlink" title="异步非阻塞（Non Blocking）"></a>异步非阻塞（Non Blocking）</h3><p>一个 <strong>异步</strong> 函数在它结束前就已经返回了,而且通常会在程序中触发一些动作然后在后台执行一些任务. (和正常的 <strong>同步</strong> 函数相比, 同步函数在返回之前做完了所有的事). 这里有几种类型的异步接口:</p>
<ul>
<li>回调函数</li>
<li>返回一个占位符 (<a href="http://tornado-zh-cn.readthedocs.io/zh_CN/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a>, <code>Promise</code>, <code>Deferred</code>)</li>
<li>传送一个队列</li>
<li>回调注册 (例如. POSIX 信号)</li>
</ul>
<p>不论使用哪一种类型的接口, <em>依据定义</em> 异步函数与他们的调用者有不同的交互方式; 但没有一种对调用者透明的方式可以将同步函数变成异步函数 (像 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 通过一种轻量的线程库来提供异步系统,但是实际上它并不能让事情变得异步)</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.web
from tornado import gen


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;index&#39;)


@gen.coroutine
def doing():
    &quot;&quot;&quot;
    穿上@gen.coroutine 装饰器之后，最终结果会返回一个可以被yield 的生成器 Future 对象
    与众不同的是这个函数的返回值需要以 raise gen.Return() 这种形式返回。
    :return: Future object
    &quot;&quot;&quot;
    # time.sleep(10)     # time.sleep() 是blocking 的，不支持异步操作，我刚开始测试tornado的时候坑了
    yield gen.sleep(10)  # 使用这个方法代替上面的方法模拟 I/O 等待的情况, 可以点进去看下这个方法的介绍
    raise gen.Return(&#39;Non-Blocking&#39;)


class NonBlockingHandler(tornado.web.RequestHandler):
    @gen.coroutine
    def get(self):
        result = yield doing()
        self.write(result)


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<ul>
<li>浏览器访问：<a href="http://127.0.0.1:8888/nonblocking" target="_blank" rel="noopener">http://127.0.0.1:8888/nonblocking</a></li>
<li>浏览器访问：<a href="http://127.0.0.1:8888/index" target="_blank" rel="noopener">http://127.0.0.1:8888/index</a></li>
<li>你会发现nonblocking会一直在转圈，处于一个堵塞状态。</li>
<li>你再访问index页面，你发现index页面能够访问不受影响。</li>
</ul>
<p>包含了 <code>yield</code> 关键字的函数是一个 <strong>生成器(generator)</strong>. 所有的生成器都是异步的; 当调用它们的时候,会返回一个生成器对象,而不是一个执行完的结果. <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器通过</code>yield<code>表达式和生成器进行交流, 而且通过返回一个 [</code>Future<code>](http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future) 与协程的调用方进行交互. 协程一般不会抛出异常: 它们抛出的任何异常将被 [</code>Future<code>](http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future) 捕获 直到它被得到. 这意味着用正确的方式调用协程是重要的, 否则你可能有被 忽略的错误。</code>@gen.coroutine<code>可以让你的函数以异步协程的形式运行，但是依赖第三方的异步库，要求你的函数本身不是Booking的。例如上面的</code>os.sleep()` 方法是blocking 的，没办法实现异步非阻塞。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>上面提到Future 到底是什么呢，原始的 <a href="http://tornado-zh-cn.readthedocs.io/zh_CN/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 版本十分复杂, 但是 <code>Futures</code> 是 Tornado 中推荐使用的一种做法, 因为它有两个主要的优势. 错误处理时通过 <a href="http://tornado-zh-cn.readthedocs.io/zh_CN/latest/concurrent.html#tornado.concurrent.Future.result" target="_blank" rel="noopener"><code>Future.result</code></a> 函数可以简单的抛出一个异常 (不同于某些传统的基于回调方式接口的 一对一的错误处理方式), 而且 <code>Futures</code> 对于携程兼容的很好.  我们这里简单使用一下future 写一个异步函数。</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.web
from tornado import gen
from tornado.concurrent import Future


class IndexHandler(tornado.web.RequestHandler):

    def get(self):
        self.write(&#39;index&#39;)


def doing():
    future = Future()
    # here doing some things ...
    future.set_result(&#39;Non-Blocking&#39;)
    return future


class NonBlockingHandler(tornado.web.RequestHandler):
    @gen.coroutine
    def get(self):
        result = yield doing()
        self.write(result)


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<h3 id="Python-3-5-async-and-await"><a href="#Python-3-5-async-and-await" class="headerlink" title="Python 3.5: async and await"></a>Python 3.5: <code>async</code> and <code>await</code></h3><p>官方还介绍了在另一种写法， Python 3.5 引入了 <code>async</code> 和 <code>await</code> 关键字(使用这些关键字的 函数也被称为”原生协程”). 从Tornado 4.3, 你可以用它们代替 <code>yield</code> 为基础的协程. 只需要简单的使用 <code>async def foo()</code> 在函数定义的时候代替 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器, 用</code>await<code>代替yield. 本文档的其他部分会继续使用</code>yield<code>的风格来和旧版本的Python兼容, 但是如果</code>async<code>和</code>await` 可用的话，它们运行起来会更快</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.web
from tornado import gen


class IndexHandler(tornado.web.RequestHandler):

    def get(self):
        self.write(&#39;index&#39;)


async def doing():
    await gen.sleep(10)  # here are doing some things
    return &#39;Non-Blocking&#39;


class NonBlockingHandler(tornado.web.RequestHandler):

    async def get(self):
        result = await doing()
        self.write(result)


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.web
from tornado import gen


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;index&#39;)


@gen.coroutine
def doing():
    yield gen.sleep(10)
    raise gen.Return(&#39;Non-Blocking&#39;)


class NonBlockingHandler(tornado.web.RequestHandler):
    @gen.coroutine
    def get(self):
        result1, result2 = yield [doing(), doing()]
        self.write(result1)


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<p>那async ，await 那种方式能并行执行吗？  答案也是可以的：</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5
# Date: 2017/12/13

import tornado.web
from tornado import gen


class IndexHandler(tornado.web.RequestHandler):

    def get(self):
        self.write(&#39;index&#39;)


async def doing():
    await gen.sleep(10)
    return &#39;Non-Blocking&#39;


class NonBlockingHandler(tornado.web.RequestHandler):

    async def get(self):
        result1, result2 = await gen.convert_yielded([doing(), doing()])
        self.write(result1)


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])


if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<p><code>await</code> 关键字比 <code>yield</code> 关键字功能要少一些. 例如,在一个使用 <code>yield</code> 的协程中， 你可以得到<code>Futures</code> 列表, 但是在原生协程中,你必须把列表用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包起来. 你也可以使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.convert_yielded" target="_blank" rel="noopener"><code>tornado.gen.convert_yielded</code></a> 来把任何使用 <code>yield</code> 工作的代码转换成使用 <code>await</code> 的形式.</p>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p><code>coroutine</code> 是给Non-blocking 函数提供异步协程的方式运行， <code>ThreadPoolExecutor</code> 则是通过多进程给blocking 的函数提供非阻塞的方式运行，但是由于是多线程的，Python 使用多线程对新能来说是需要谨慎的，大量的计算量的情况可能会造成性能的下降。</p>
<pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import time
import os
import tornado.web
from tornado import gen
from tornado.concurrent import run_on_executor
from concurrent.futures import ThreadPoolExecutor


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;index&#39;)
        self.write(&#39;index&#39;)
        print(&#39;index&#39;)


class NonBlockingHandler(tornado.web.RequestHandler):
    executor = ThreadPoolExecutor(4)

    @gen.coroutine
    def get(self):
        result = yield self.doing()
        self.write(result)
        print(result)

    # 使用tornado 线程池不需要加上下面的装饰器到I/O函数
    @run_on_executor
    def doing(self):
        # time.sleep(10)
        # yield gen.sleep(10)
        os.system(&quot;ping -c 20 www.baidu.com&quot;)  # 模拟I/O 任务
        return &#39;Non-Blocking&#39;


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])

if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<h3 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import time
import datetime
import os
import tornado.web
from tornado import gen
from tornado.concurrent import run_on_executor
from concurrent.futures import ThreadPoolExecutor


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;index&#39;)
        print(&#39;index&#39;)


class NonBlockingHandler(tornado.web.RequestHandler):
    executor = ThreadPoolExecutor(4)

    @gen.coroutine
    def get(self):
        try:
            start = time.time()
            # 并行执行
            result1, result2 = yield gen.with_timeout(datetime.timedelta(seconds=5), [self.doing(1), self.doing(2)], quiet_exceptions=tornado.gen.TimeoutError)
            self.write(&quot;NO Timeout&quot;)
            print(result1, result2)
            print(time.time() - start)
        except gen.TimeoutError:
            self.write(&quot;Timeout&quot;)
            print(&quot;Timeout&quot;)
            print(time.time() - start)

    # 使用tornado 线程池需要加上下面的装饰器到I/O函数
    @run_on_executor
    def doing(self, num):
        time.sleep(10)
        return &#39;Non-Blocking%d&#39; % num


application = tornado.web.Application([
    (r&quot;/index&quot;, IndexHandler),
    (r&quot;/nonblocking&quot;, NonBlockingHandler),
])

if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
</code></pre>
<h2 id="多进程运行"><a href="#多进程运行" class="headerlink" title="多进程运行"></a>多进程运行</h2><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Xian Sen
# Python 3.5

import tornado.web
from tornado import gen
from tornado.httpserver import HTTPServer


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&#39;index&#39;)


@gen.coroutine
def doing():
    yield gen.sleep(10)
    raise gen.Return(&#39;Non-Blocking&#39;)


class NonBlockingHandler(tornado.web.RequestHandler):
    @gen.coroutine
    def get(self):
        result = yield doing()
        self.write(result)


def make_app():
    return tornado.web.Application([
        (r&quot;/index&quot;, IndexHandler),
        (r&quot;/nonblocking&quot;, NonBlockingHandler),
    ])


def main():
    app = make_app()
    server = HTTPServer(app)
    server.bind(8888)
    server.start(2)  # 设置启动多少个进程
    tornado.ioloop.IOLoop.current().start()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jupyter 使用]]></title>
      <url>http://www.liangxiansen.cn/2017/07/28/jupyter/</url>
      <content type="html"><![CDATA[<h2 id="安装Jupyter"><a href="#安装Jupyter" class="headerlink" title="安装Jupyter"></a>安装Jupyter</h2><pre><code>pip3 install --upgrade pip
pip3 install jupyter
</code></pre><p><a href="http://www.jupyter.org/" target="_blank" rel="noopener">官网</a>  |  <a href="http://www.jupyter-notebook.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">文档</a></p>
<h2 id="配置Jupyter"><a href="#配置Jupyter" class="headerlink" title="配置Jupyter"></a>配置Jupyter</h2><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><pre><code>jupyter notebook --generate-config
</code></pre><h3 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h3><pre><code>jupyter notebook password
</code></pre><h3 id="关闭启动浏览器"><a href="#关闭启动浏览器" class="headerlink" title="关闭启动浏览器"></a>关闭启动浏览器</h3><ul>
<li>vim ~/.jupyter/jupyter_notebook_config.py</li>
</ul>
<pre><code>c.NotebookApp.open_browser = False
</code></pre><h3 id="启动Jupyter"><a href="#启动Jupyter" class="headerlink" title="启动Jupyter"></a>启动Jupyter</h3><pre><code>jupyter notebook
</code></pre><h2 id="制作幻灯片"><a href="#制作幻灯片" class="headerlink" title="制作幻灯片"></a>制作幻灯片</h2><h3 id="安装生产幻灯片插件"><a href="#安装生产幻灯片插件" class="headerlink" title="安装生产幻灯片插件"></a>安装生产幻灯片插件</h3><p>这部分实现主要依靠<a href="https://github.com/damianavila/RISE" target="_blank" rel="noopener"> RISE </a>这个jupyter notebook插件，关于它的使用可以参考它的文档</p>
<h3 id="生成静态幻灯片"><a href="#生成静态幻灯片" class="headerlink" title="生成静态幻灯片"></a>生成静态幻灯片</h3><p>可以参考这个<a href="https://www.youtube.com/watch?v=EOpcxy0RA1A" target="_blank" rel="noopener">视频</a>，简述步骤如下：</p>
<p>在notebook中设置cell 的slide属性，确认好，然后保存</p>
<p>在自己的notebook文件目录（包含.ipynb的目录），制作幻灯片网页，需要 <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a> </p>
<pre><code>jupyter-nbconvert --to slides test.ipynb --reveal-prefix=&quot;http://liangxiansen.cn/files/reveal.js&quot;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Software Collections]]></title>
      <url>http://www.liangxiansen.cn/2017/07/14/scl/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SCL(Software Collections)可以让你在同一个操作系统上安装和使用多个版本的软件，而不会影响整个系统的安装包。SCL为社区的以下需求而设计：创建和使用软件集合生产系统、概念验证系统、开发测试平台。SCL目前已经支持Fedora和RHEL(衍生版本如CentOS也包含在内)。</p>
<p>SCL的创建就是为了给RHEL/CentOS用户提供一种以方便、安全地安装和使用应用程序和运行时环境的多个(而且可能是更新的)版本的方式，同时避免把系统搞乱。与之相对的是第三方源，它们可能会在已安装的包之间引起冲突。</p>
<a id="more"></a>
<p>现有软件选集：</p>
<pre><code>Ruby 1.9.3 (ruby193)
Python 2.7 (python27)
Python 3.5 (Python5)
PHP 5.4 (php54)
MySQL 5.5 (mysql55)
Apache 2.4 (Apache2)
Perl 5.16.3 (perl516)
Node.js 0.10 (nodejs010)
MariaDB 5.5 (mariadb55)
PostgreSQL 9.2 (postgresql92)
</code></pre><p><a href="https://www.softwarecollections.org/en/scls/" target="_blank" rel="noopener">更多的软件集</a></p>
<h2 id="SCL安装Python-开发环境"><a href="#SCL安装Python-开发环境" class="headerlink" title="SCL安装Python 开发环境"></a>SCL安装Python 开发环境</h2><p>关于 Software Collections 官方有一个<a href="https://www.softwarecollections.org/en/docs/" target="_blank" rel="noopener">指导</a>。</p>
<ol>
<li><p>安装 Software Collections yum源</p>
<pre><code>yum install centos-release-scl
</code></pre></li>
<li><p>如果你是RedHat， 你需要开启RHSCL 源使用</p>
<pre><code>yum-config-manager --enable rhel-server-rhscl-7-rpms
</code></pre></li>
<li><p>安装 scl-utils</p>
<pre><code>yum install scl-utils
</code></pre></li>
<li><p>安装 <a href="https://www.softwarecollections.org/en/scls/rhscl/python27/" target="_blank" rel="noopener">Python 开发环境</a></p>
<pre><code>yum install python27
</code></pre></li>
<li><p>激活 Python 开发环境</p>
<p>安装完后可以执行 <code>scl --list</code></p>
<pre><code>[root@localhost ~]# scl --list
python27
</code></pre><p>激活 Python27 环境</p>
<pre><code>scl enable python27 bash
</code></pre><p>你将进入一个新的bash环境，执行 <code>python --version</code></p>
<pre><code>[root@localhost ~]# python --version
Python 2.7.13
</code></pre><p>​</p>
</li>
</ol>
<p>关于使用，这里多说一点，<code>scl-utils</code> 只是方便 Software Collections 使用，比如要查看当前安装了哪些 Software Collections，可以 <code>scl --list</code>，我们也可以不用这个工具。scl 安装的所有都东西默认都在 <code>/opt/rh</code> 里面,可以到想要激活的应用集里面去激活环境。</p>
<p>比如你可以通过执行 <code>source /opt/rh/python27/enable</code> 来激活Python27。</p>
<h2 id="SCL应用场景"><a href="#SCL应用场景" class="headerlink" title="SCL应用场景"></a>SCL应用场景</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>说到这里可能很多人会说这个 <code>Virtualenv</code> 也可以做到啊，需要注意的是<code>Virtualenv</code> 它的出现是为了给开发者提供可以随时在本地部署不同版本的python环境，在不同的开发项目中能够灵活的切换python环境来适应不同的开发需求。</p>
<p><strong>但是：</strong> 当我们构建好一个python环境再上面开发好了之后将env的环境打个包，把项目代码打个包放的别的机器上运行。问题来了～  你会发现各种报错，各种python无法运行，说找不到等等等。。。  其实Virtualenv 他它在给你本地构建不同的python环境的时候，为了节省本地磁盘空间它是以软连接的形式创建的， 你如果只是打包env那个文件夹是不行的，你还需要cp 各种库到到这个env文件夹替换掉软连接。麻烦不说了还各种问题，而且python 编译的系统的一些so文件也会缺少。所以 Virtualenv 只适合是在本地构建环境开发，不能当做一个完整的python环境拿到别的机器上运行。</p>
<p>我们可以看到SCL 安装好的应用集下面有一个root目录，可以理解为 <code>/(根)</code> 目录，这个应用集需要的系统库，编译的文件都会在这里面，和系统的是完全分开的。 （就像是Linux 急救模式 chroot 的感觉）</p>
<pre><code>[root@localhost ~]# ls /opt/rh/python27/root/
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var
</code></pre><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><p>Software Collections 顾名思义它提供一个应用集，他不单帮助你构建python环境，不用考虑python不同版本的问题，而且其他应用也都是可以的，比如本地你装了一个mysq5.5， 但是你又想用mysql 5.6，SCL也是可以做到的。甚至如果你想做一个自己参与开源项目的开发，你也可以为你自己的应用做一个应用集提供给其他开发者使用。</p>
<ul>
<li>有时我们会用docker 快速部署一些服务，比如mysql、Apache、php、等等，来协助自己开发，不需要将时间浪费在部署环境上面，那样的开发环境是多么快捷和高效。</li>
<li>但是交付的时候就苦恼了，如果客户那边也有docker，我可以把我docker的开发环境做好镜像和代码直接给客户，几乎哪到就能用，不需要做任何调试。</li>
<li>如果客户没有docker，或者实际情况不允许使用docker，那怎么办呢。 也有人想到了办法，以前是自己会将自己的环境做成一个个RPM软件包，然后加一个shell脚本自动完成后续工作。</li>
<li>但我想说那个太low了，那都是以前的做法了，如果有更新每次还要重新build 新的RPM包，或者改脚本。现在你可以使用SCL， 你可以想docker一样快速使用SCL中已经存在的应用集，把你需要的应用集在本地安装好后，激活状态下开发。开发完后，退出激活，你把程序和你用的SCL打个包一块交付，在新的环境只需要重新激活SCL就可直接运行程序，不需要调试。没错就是这么方便～</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[区间数值统计]]></title>
      <url>http://www.liangxiansen.cn/2017/05/17/%E5%8C%BA%E9%97%B4%E6%95%B0%E5%80%BC%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Date: 2017/5/15


number_list = []
f = open(&#39;/Users/lianliang/Desktop/true.csv&#39;)
for line in f:
    number = line.split(&#39;,&#39;)[-2].strip()
    number = int(float(number))
    number_list.append(number)


from itertools import groupby
map_list = []
num_list = []
for k, g in groupby(sorted(number_list), key=lambda x: x//10):
    total = len(list(g))
    map_list.append(total)
    num_list.append(k*10)
    print(&#39;{}-{}: {}&#39;.format(k*10, (k+1)*10-1, total))

print map_list
print num_list

import matplotlib.pyplot as plt
plt.plot(num_list, map_list, &#39;b-&#39;)
plt.show()
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Consul 使用手册]]></title>
      <url>http://www.liangxiansen.cn/2017/04/06/consul/</url>
      <content type="html"><![CDATA[<h2 id="使用consul"><a href="#使用consul" class="headerlink" title="使用consul"></a>使用consul</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Consul包含多个组件,但是作为一个整体,为你的基础设施提供服务发现和服务配置的工具.他提供以下关键特性:</p>
<ul>
<li><strong>服务发现</strong> Consul的客户端可用提供一个服务,比如 api 或者mysql ,另外一些客户端可用使用Consul去发现一个指定服务的提供者.通过DNS或者HTTP应用程序可用很容易的找到他所依赖的服务.</li>
<li><strong>健康检查</strong> Consul客户端可用提供任意数量的健康检查,指定一个服务(比如:webserver是否返回了200 OK 状态码)或者使用本地节点(比如:内存使用是否大于90%). 这个信息可由operator用来监视集群的健康.被服务发现组件用来避免将流量发送到不健康的主机.</li>
<li><strong>Key/Value存储</strong> 应用程序可用根据自己的需要使用Consul的层级的Key/Value存储.比如动态配置,功能标记,协调,领袖选举等等,简单的HTTP API让他更易于使用.</li>
<li><strong>多数据中心</strong>: Consul支持开箱即用的多数据中心.这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域.</li>
</ul>
<p>Consul面向DevOps和应用开发者友好.是他适合现代的弹性的基础设施.<br><a id="more"></a></p>
<p><img src="http://www.liangxiansen.cn/images/consul/cluster.png" alt="consul-cluster"></p>
<h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>Consul是一个分布式高可用的系统. 这节将包含一些基础,我们忽略掉一些细节这样你可以快速了解Consul是如何工作的.如果要了解更多细节,请参考深入的架构描述.</p>
<p>每个提供服务给Consul的阶段都运行了一个Consul agent . 发现服务或者设置和获取 key/value存储的数据不是必须运行agent.这个agent是负责对节点自身和节点上的服务进行健康检查的.</p>
<p>Agent与一个和多个Consul Server 进行交互.Consul Server 用于存放和复制数据.server自行选举一个领袖.虽然Consul可以运行在一台server , 但是建议使用3到5台来避免失败情况下数据的丢失.每个数据中心建议配置一个server集群.</p>
<p>你基础设施中需要发现其他服务的组件可以查询任何一个Consul 的server或者 agent.Agent会自动转发请求到server .</p>
<p>每个数据中运行了一个Consul server集群.当一个跨数据中心的服务发现和配置请求创建时.本地Consul Server转发请求到远程的数据中心并返回结果.</p>
<p>更多介绍查看官网<a href="https://www.consul.io" target="_blank" rel="noopener">点击前往</a></p>
<h3 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h3><p>安装Consul,找到适合你系统的包下载他.Consul打包为一个’Zip’文件.<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">前往下载</a></p>
<p>下载后解开压缩包.拷贝Consul到你的PATH路径中,在Unix系统中<code>~/bin</code>和<code>/usr/local/bin</code>是通常的安装目录.根据你是想为单个用户安装还是给整个系统安装来选择.在Windows系统中有可以安装到<code>%PATH%</code>的路径中.</p>
<h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>完成安装后,通过打开一个新终端窗口检查<code>consul</code>安装是否成功.通过执行 <code>consul</code>你应该看到类似下面的输出</p>
<pre><code>[root@dhcp-10-201-102-248 ~]# consul
usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]

Available commands are:
    agent          Runs a Consul agent
    configtest     Validate config file
    event          Fire a new event
    exec           Executes a command on Consul nodes
    force-leave    Forces a member of the cluster to enter the &quot;left&quot; state
    info           Provides debugging information for operators
    join           Tell Consul agent to join cluster
    keygen         Generates a new encryption key
    keyring        Manages gossip layer encryption keys
    kv             Interact with the key-value store
    leave          Gracefully leaves the Consul cluster and shuts down
    lock           Execute a command holding a lock
    maint          Controls node or service maintenance mode
    members        Lists the members of a Consul cluster
    monitor        Stream logs from a Consul agent
    operator       Provides cluster-level tools for Consul operators
    reload         Triggers the agent to reload configuration files
    rtt            Estimates network round trip time between nodes
    snapshot       Saves, restores and inspects snapshots of Consul server state
    version        Prints the Consul version
    watch          Watch for changes in Consul
</code></pre><p>如果你得到一个<code>consul not be found</code>的错误,你的<code>PATH</code>可能没有正确设置.请返回检查你的<code>consul</code>的安装路径是否包含在<code>PATH</code>中.</p>
<h3 id="运行Agent"><a href="#运行Agent" class="headerlink" title="运行Agent"></a>运行Agent</h3><p>完成Consul的安装后,必须运行agent. agent可以运行为<code>server</code>或<code>client</code>模式.每个数据中心至少必须拥有一台server . 建议在一个集群中有3或者5个server.部署单一的server,在出现失败时会不可避免的造成数据丢失.</p>
<p>其他的agent运行为client模式.一个client是一个非常轻量级的进程.用于注册服务,运行健康检查和转发对server的查询.agent必须在集群中的每个主机上运行.</p>
<p>查看启动数据中心的细节请查看<a href="https://www.consul.io/docs/guides/bootstrapping.html" target="_blank" rel="noopener">这里</a>.</p>
<h3 id="启动-Consul-Server"><a href="#启动-Consul-Server" class="headerlink" title="启动 Consul Server"></a>启动 Consul Server</h3><pre><code>consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0
</code></pre><p>运行cosnul agent以<code>server</code>模式，</p>
<ul>
<li><code>-server</code> ： 定义agent运行在server模式</li>
</ul>
<ul>
<li><code>-bootstrap-expect</code> ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用</li>
<li><code>-bind</code>：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</li>
<li><code>-node</code>：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名</li>
<li><code>-ui-dir</code>： 提供存放web ui资源的路径，该目录必须是可读的</li>
<li><code>-rejoin</code>：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。</li>
</ul>
<ul>
<li><code>-config-dir</code>：：配置文件目录，里面所有以.json结尾的文件都会被加载</li>
<li><code>-client</code>：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</li>
</ul>
<pre><code>[root@dhcp-10-201-102-198 consul]# consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0
==&gt; WARNING: Expect Mode enabled, expecting 3 servers
==&gt; Starting Consul agent...
==&gt; Starting Consul agent RPC...
==&gt; Consul agent running!
           Version: &#39;v0.7.4&#39;
           Node ID: &#39;422ec677-74ef-8f29-2f22-01effeed6334&#39;
         Node name: &#39;s1&#39;
        Datacenter: &#39;dc1&#39;
            Server: true (bootstrap: false)
       Client Addr: 0.0.0.0 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)
      Cluster Addr: 10.201.102.198 (LAN: 8301, WAN: 8302)
    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false
             Atlas: &lt;disabled&gt;

==&gt; Log data will now stream in as it occurs:

    2017/03/17 18:03:08 [INFO] raft: Restored from snapshot 139-352267-1489707086023
    2017/03/17 18:03:08 [INFO] raft: Initial configuration (index=6982): [{Suffrage:Voter ID:10.201.102.199:8300 Address:10.201.102.199:8300} {Suffrage:Voter ID:10.201.102.200:8300 Address:10.201.102.200:8300} {Suffrage:Voter ID:10.201.102.198:8300 Address:10.201.102.198:8300}]
    2017/03/17 18:03:08 [INFO] raft: Node at 10.201.102.198:8300 [Follower] entering Follower state (Leader: &quot;&quot;)
    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s1 10.201.102.198
    2017/03/17 18:03:08 [INFO] serf: Attempting re-join to previously known node: s2: 10.201.102.199:8301
    2017/03/17 18:03:08 [INFO] consul: Adding LAN server s1 (Addr: tcp/10.201.102.198:8300) (DC: dc1)
    2017/03/17 18:03:08 [INFO] consul: Raft data found, disabling bootstrap mode
    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s2 10.201.102.199
    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s3 10.201.102.200
    2017/03/17 18:03:08 [INFO] serf: Re-joined to previously known node: s2: 10.201.102.199:8301
    2017/03/17 18:03:08 [INFO] consul: Adding LAN server s2 (Addr: tcp/10.201.102.199:8300) (DC: dc1)
    2017/03/17 18:03:08 [INFO] consul: Adding LAN server s3 (Addr: tcp/10.201.102.200:8300) (DC: dc1)
    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s1.dc1 10.201.102.198
    2017/03/17 18:03:08 [INFO] consul: Adding WAN server s1.dc1 (Addr: tcp/10.201.102.198:8300) (DC: dc1)
    2017/03/17 18:03:08 [WARN] serf: Failed to re-join any previously known node
    2017/03/17 18:03:14 [INFO] agent: Synced service &#39;consul&#39;
    2017/03/17 18:03:14 [INFO] agent: Deregistered service &#39;consul01&#39;
    2017/03/17 18:03:14 [INFO] agent: Deregistered service &#39;consul02&#39;
    2017/03/17 18:03:14 [INFO] agent: Deregistered service &#39;consul03&#39;
</code></pre><ul>
<li>查看集群成员</li>
</ul>
<p>新开一个终端窗口运行<code>consul members</code>, 你可以看到Consul集群的成员.</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# consul members
Node  Address              Status  Type    Build  Protocol  DC
s1    10.201.102.198:8301  alive   server  0.7.4  2         dc1
s2    10.201.102.199:8301  alive   server  0.7.4  2         dc1
s3    10.201.102.200:8301  alive   server  0.7.4  2         dc1
</code></pre><h3 id="启动-Consul-Client"><a href="#启动-Consul-Client" class="headerlink" title="启动 Consul Client"></a>启动 Consul Client</h3><pre><code>consul agent -data-dir /tmp/consul -node=c1 -bind=10.201.102.248 -config-dir=/etc/consul.d/ -join 10.201.102.198
</code></pre><p>运行cosnul agent以client模式，<code>-join</code> 加入到已有的集群中去。</p>
<pre><code>[root@dhcp-10-201-102-248 ~]# consul agent -data-dir /tmp/consul -node=c1 -bind=10.201.102.248 -config-dir=/etc/consul.d/ -join 10.201.102.198
==&gt; Starting Consul agent...
==&gt; Starting Consul agent RPC...
==&gt; Joining cluster...
    Join completed. Synced with 1 initial agents
==&gt; Consul agent running!
           Version: &#39;v0.7.4&#39;
           Node ID: &#39;564dc0c7-7f4f-7402-a301-cebe7f024294&#39;
         Node name: &#39;c1&#39;
        Datacenter: &#39;dc1&#39;
            Server: false (bootstrap: false)
       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)
      Cluster Addr: 10.201.102.248 (LAN: 8301, WAN: 8302)
    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false
             Atlas: &lt;disabled&gt;

==&gt; Log data will now stream in as it occurs:

    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: c1 10.201.102.248
    2017/03/17 15:35:16 [INFO] agent: (LAN) joining: [10.201.102.198]
    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: s2 10.201.102.199
    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: s3 10.201.102.200
    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: s1 10.201.102.198
    2017/03/17 15:35:16 [INFO] agent: (LAN) joined: 1 Err: &lt;nil&gt;
    2017/03/17 15:35:16 [INFO] consul: adding server s2 (Addr: tcp/10.201.102.199:8300) (DC: dc1)
    2017/03/17 15:35:16 [INFO] consul: adding server s3 (Addr: tcp/10.201.102.200:8300) (DC: dc1)
    2017/03/17 15:35:16 [INFO] consul: adding server s1 (Addr: tcp/10.201.102.198:8300) (DC: dc1)
    2017/03/17 15:35:16 [INFO] agent: Synced node info
</code></pre><ul>
<li>查看集群成员</li>
</ul>
<p>新开一个终端窗口运行<code>consul members</code>, 你可以看到Consul集群的成员.</p>
<pre><code>[root@dhcp-10-201-102-248 ~]# consul members
Node  Address              Status  Type    Build  Protocol  DC
c1    10.201.102.248:8301  alive   client  0.7.4  2         dc1
s1    10.201.102.198:8301  alive   server  0.7.4  2         dc1
s2    10.201.102.199:8301  alive   server  0.7.4  2         dc1
s3    10.201.102.200:8301  alive   server  0.7.4  2         dc1
</code></pre><ul>
<li>加入集群</li>
</ul>
<pre><code>[root@dhcp-10-201-102-248 ~]# consul join 10.201.102.198
Node  Address              Status  Type    Build  Protocol  DC
c1    10.201.102.248:8301  alive   client  0.7.4  2         dc1
s1    10.201.102.198:8301  alive   server  0.7.4  2         dc1
s2    10.201.102.199:8301  alive   server  0.7.4  2         dc1
s3    10.201.102.200:8301  alive   server  0.7.4  2         dc1
</code></pre><h3 id="停止Agent"><a href="#停止Agent" class="headerlink" title="停止Agent"></a>停止Agent</h3><p>你可以使用<code>Ctrl-C</code> 优雅的关闭Agent. 中断Agent之后你可以看到他离开了集群并关闭.</p>
<p>在退出中,Consul提醒其他集群成员,这个节点离开了.如果你强行杀掉进程.集群的其他成员应该能检测到这个节点失效了.当一个成员离开,他的服务和检测也会从目录中移除.当一个成员失效了,他的健康状况被简单的标记为危险,但是不会从目录中移除.Consul会自动尝试对失效的节点进行重连.允许他从某些网络条件下恢复过来.离开的节点则不会再继续联系.</p>
<p>此外,如果一个agent作为一个服务器,一个优雅的离开是很重要的,可以避免引起潜在的可用性故障影响达成<a href="https://www.consul.io/docs/internals/consensus.html" target="_blank" rel="noopener">一致性协议</a>.</p>
<p>查看<a href="https://www.consul.io/docs/internals/consensus.html" target="_blank" rel="noopener">这里</a>了解添加和移除server.</p>
<h3 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h3><p>服务定义可以通过配置文件并发送<code>SIGHUP</code>给agent来进行更新.这样你可以让你在不关闭服务或者保持服务请求可用的情况下进行更新.</p>
<pre><code>consul reload
</code></pre><p>另外 HTTP API可以用来动态的添加,移除和修改服务.</p>
<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>搭建好conusl集群后，用户或者程序就能到consul中去查询或者注册服务。可以通过提供服务定义文件或者调用HTTP API来注册一个服务.</p>
<p>首先,为Consul配置创建一个目录.Consul会载入配置文件夹里的所有配置文件.在Unix系统中通常类似 <code>/etc/consul.d</code> (.d 后缀意思是这个路径包含了一组配置文件).</p>
<pre><code>mkdir /etc/consul.d
</code></pre><p>然后,我们将编写服务定义配置文件.假设我们有一个名叫<code>web</code>的服务运行在 80端口.另外,我们将给他设置一个标签.这样我们可以使用他作为额外的查询方式:</p>
<pre><code>echo &#39;{&quot;service&quot;: {&quot;name&quot;: &quot;web&quot;, &quot;tags&quot;: [&quot;rails&quot;], &quot;port&quot;: 80}}&#39; &gt;/etc/consul.d/web.json
</code></pre><p>现在重启agent , 设置配置目录:</p>
<pre><code>$ consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0

...
    [INFO] agent: Synced service &#39;web&#39;
...
</code></pre><ul>
<li><code>-data-dir</code>：提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在</li>
</ul>
<p>你可能注意到了输出了 “synced” 了 web这个服务.意思是这个agent从配置文件中载入了服务定义,并且成功注册到服务目录.</p>
<p>如果你想注册多个服务,你应该在Consul配置目录创建多个服务定义文件.</p>
<p>HTTP API注册服务,curl命令或者postman 以<code>PUT</code>方式请求consul HTTP API更多细节<a href="https://www.consul.io/docs/agent/http/catalog.html#catalog_register" target="_blank" rel="noopener">点击查看</a></p>
<pre><code>curl -X PUT -d &#39;{&quot;Datacenter&quot;: &quot;dc1&quot;, &quot;Node&quot;: &quot;c2&quot;, &quot;Address&quot;: &quot;10.155.0.106&quot;, &quot;Service&quot;: {&quot;Service&quot;: &quot;MAC&quot;, &quot;tags&quot;: [&quot;lianglian&quot;, &quot;Mac&quot;], &quot;Port&quot;: 22}}&#39; http://127.0.0.1:8500/v1/catalog/register
</code></pre><h3 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h3><p>一旦agent启动并且服务同步了.我们可以通过DNS或者HTTP的API来查询服务.</p>
<ul>
<li>DNS API</li>
</ul>
<p>让我们首先使用DNS API来查询.在DNS API中,服务的DNS名字是 <code>NAME.service.consul</code>. 虽然是可配置的,但默认的所有DNS名字会都在<code>consul</code>命名空间下.这个子域告诉Consul,我们在查询服务,<code>NAME</code>则是服务的名称.</p>
<p>对于我们上面注册的Web服务.它的域名是 <code>web.service.consul</code> :</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 web.service.consul

; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 web.service.consul
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 39468
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;web.service.consul.            IN      A

;; ANSWER SECTION:
web.service.consul.     0       IN      A       10.201.102.198

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Tue Mar 28 16:10:24 2017
;; MSG SIZE  rcvd: 52

[root@dhcp-10-201-102-198 ~]#
</code></pre><p>如你所见,一个<code>A</code>记录返回了一个可用的服务所在的节点的IP地址.<code></code>A`记录只能设置为IP地址. 有也可用使用 DNS API 来接收包含 地址和端口的 SRV记录:</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 web.service.consul SRV

; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 web.service.consul SRV
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 13331
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;web.service.consul.            IN      SRV

;; ANSWER SECTION:
web.service.consul.     0       IN      SRV     1 1 80 s1.node.dc1.consul.

;; ADDITIONAL SECTION:
s1.node.dc1.consul.     0       IN      A       10.201.102.198

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Tue Mar 28 16:10:56 2017
;; MSG SIZE  rcvd: 84

[root@dhcp-10-201-102-198 ~]#
</code></pre><p><code>SRV</code>记录告诉我们 <code>web</code> 这个服务运行于节点<code>dhcp-10-201-102-198</code> 的<code>80</code>端口. DNS额外返回了节点的A记录.</p>
<p>最后,我们也可以用 DNS API 通过标签来过滤服务.基于标签的服务查询格式为<code>TAG.NAME.service.consul</code>. 在下面的例子中,我们请求Consul返回有 <code>rails</code>标签的 <code>web</code>服务.我们成功获取了我们注册为这个标签的服务:</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 rails.web.service.consul SRV

; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 rails.web.service.consul SRV
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37307
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;rails.web.service.consul.      IN      SRV

;; ANSWER SECTION:
rails.web.service.consul. 0     IN      SRV     1 1 80 s1.node.dc1.consul.

;; ADDITIONAL SECTION:
s1.node.dc1.consul.     0       IN      A       10.201.102.198

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Tue Mar 28 16:11:45 2017
;; MSG SIZE  rcvd: 90

[root@dhcp-10-201-102-198 ~]#
</code></pre><ul>
<li>HTTP API</li>
</ul>
<p>除了DNS API之外,HTTP API也可以用来进行服务查询:</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -s 127.0.0.1:8500/v1/catalog/service/web | python -m json.tool
[
    {
        &quot;Address&quot;: &quot;10.201.102.198&quot;,
        &quot;CreateIndex&quot;: 492843,
        &quot;ID&quot;: &quot;422ec677-74ef-8f29-2f22-01effeed6334&quot;,
        &quot;ModifyIndex&quot;: 492843,
        &quot;Node&quot;: &quot;s1&quot;,
        &quot;NodeMeta&quot;: {},
        &quot;ServiceAddress&quot;: &quot;&quot;,
        &quot;ServiceEnableTagOverride&quot;: false,
        &quot;ServiceID&quot;: &quot;web&quot;,
        &quot;ServiceName&quot;: &quot;web&quot;,
        &quot;ServicePort&quot;: 80,
        &quot;ServiceTags&quot;: [
            &quot;rails&quot;
        ],
        &quot;TaggedAddresses&quot;: {
            &quot;lan&quot;: &quot;10.201.102.198&quot;,
            &quot;wan&quot;: &quot;10.201.102.198&quot;
        }
    }
]
</code></pre><p>目录API给出所有节点提供的服务.稍后我们会像通常的那样带上健康检查进行查询.就像DNS内部处理的那样.这是只查看健康的实例的查询方法:</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -s 127.0.0.1:8500/v1/catalog/service/web?passing | python -m json.tool
[
    {
        &quot;Address&quot;: &quot;10.201.102.198&quot;,
        &quot;CreateIndex&quot;: 492843,
        &quot;ID&quot;: &quot;422ec677-74ef-8f29-2f22-01effeed6334&quot;,
        &quot;ModifyIndex&quot;: 492843,
        &quot;Node&quot;: &quot;s1&quot;,
        &quot;NodeMeta&quot;: {},
        &quot;ServiceAddress&quot;: &quot;&quot;,
        &quot;ServiceEnableTagOverride&quot;: false,
        &quot;ServiceID&quot;: &quot;web&quot;,
        &quot;ServiceName&quot;: &quot;web&quot;,
        &quot;ServicePort&quot;: 80,
        &quot;ServiceTags&quot;: [
            &quot;rails&quot;
        ],
        &quot;TaggedAddresses&quot;: {
            &quot;lan&quot;: &quot;10.201.102.198&quot;,
            &quot;wan&quot;: &quot;10.201.102.198&quot;
        }
    }
]
</code></pre><h3 id="WEB管理界面"><a href="#WEB管理界面" class="headerlink" title="WEB管理界面"></a>WEB管理界面</h3><p>Consul同时提供了一个漂亮的功能齐全的WEB界面,开箱即用.界面可以用来查看所有的节点,可以查看健康检查和他们的当前状态.可以读取和设置K/V 存储的数据.UI自动支持多数据中心.<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">点击前往下载</a></p>
<p><img src="http://www.liangxiansen.cn/images/consul/ui_download.png" alt="UI_Download"></p>
<p>下载完后上传至服务器，建议所有server角色都使用WebUI，。</p>
<pre><code>consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0
</code></pre><ul>
<li><code>-ui-dir</code>： 提供存放web ui资源的路径，指向该目录必须是可读的</li>
<li><code>-client</code>：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</li>
</ul>
<p>可通过<a href="http://10.201.102.198:8500访问WEB管理界面。" target="_blank" rel="noopener">http://10.201.102.198:8500访问WEB管理界面。</a></p>
<p><img src="http://www.liangxiansen.cn/images/consul/ui.png" alt="UI_Download"></p>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>我们现在看到Consul运行时如此简单.添加节点和服务,查询节点和服务.在这一节.我们将继续添加健康检查到节点和服务.健康检查是服务发现的关键组件.预防使用到不健康的服务.</p>
<p>这一步建立在前一节的Consul集群创建之上.目前你应该有一个包含多个节点的Consul集群.</p>
<ul>
<li>自定义检查</li>
</ul>
<p>和服务注册类似,一个检查可以通过检查定义或HTTP API请求来注册.</p>
<p>我们将使用和检查定义来注册检查.和服务类似,因为这是建立检查最常用的方式.</p>
<p>在第二个节点的配置目录建立定义文件:</p>
<p><code>/etc/consul.d/web.json</code></p>
<pre><code>{&quot;service&quot;: {
    &quot;name&quot;: &quot;Faceid&quot;,
    &quot;tags&quot;: [&quot;extract&quot;, &quot;verify&quot;, &quot;compare&quot;, &quot;idcard&quot;],
    &quot;address&quot;: &quot;10.201.102.198&quot;,
    &quot;port&quot;: 9000,
    &quot;check&quot;: {
        &quot;name&quot;: &quot;ping&quot;,
        &quot;script&quot;: &quot;curl -s localhost:9000&quot;,
        &quot;interval&quot;: &quot;3s&quot;
        }
    }
}
</code></pre><p>or</p>
<p><code>/etc/consul.d/web.json</code></p>
<pre><code>{&quot;service&quot;: {
    &quot;name&quot;: &quot;Faceid&quot;,
    &quot;tags&quot;: [&quot;extract&quot;, &quot;verify&quot;, &quot;compare&quot;, &quot;idcard&quot;],
    &quot;address&quot;: &quot;10.201.102.199&quot;,
    &quot;port&quot;: 9000,
    &quot;check&quot;: {
        &quot;id&quot;: &quot;api&quot;,
           &quot;name&quot;: &quot;HTTP API on port 9000&quot;,
        &quot;http&quot;: &quot;http://localhost:9000&quot;,
        &quot;interval&quot;: &quot;10s&quot;,
        &quot;timeout&quot;: &quot;1s&quot;
        }
   }
}
</code></pre><p><a href="https://www.consul.io/docs/agent/checks.html" target="_blank" rel="noopener">more</a></p>
<h3 id="检查健康状态"><a href="#检查健康状态" class="headerlink" title="检查健康状态"></a>检查健康状态</h3><p>我们能适应HTTP API来检查他们.首先我们检查有哪些失败的检查.使用这个命令(注意:这个命令可以运行在任何节点)</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -s http://localhost:8500/v1/health/state/critical | python -m json.tool
[
    {
        &quot;CheckID&quot;: &quot;service:Faceid&quot;,
        &quot;CreateIndex&quot;: 493398,
        &quot;ModifyIndex&quot;: 493846,
        &quot;Name&quot;: &quot;Service &#39;Faceid&#39; check&quot;,
        &quot;Node&quot;: &quot;s1&quot;,
        &quot;Notes&quot;: &quot;&quot;,
        &quot;Output&quot;: &quot;&quot;,
        &quot;ServiceID&quot;: &quot;Faceid&quot;,
        &quot;ServiceName&quot;: &quot;Faceid&quot;,
        &quot;Status&quot;: &quot;critical&quot;
    }
]
</code></pre><p>我们可以看到,只有一个检查我们的<code>web</code>服务在<code>critical</code>状态</p>
<p>另外,我们可以尝试用DNS查询web服务,Consul将不会返回结果.因为服务不健康.</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 Faceid.service.consul SRV

; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 Faceid.service.consul SRV
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 40884
;; flags: qr aa rd; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 3
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;Faceid.service.consul.         IN      SRV

;; ANSWER SECTION:
Faceid.service.consul.  0       IN      SRV     1 1 9000 s3.node.dc1.consul.
Faceid.service.consul.  0       IN      SRV     1 1 9000 s1.node.dc1.consul.
Faceid.service.consul.  0       IN      SRV     1 1 9000 s2.node.dc1.consul.

;; ADDITIONAL SECTION:
s3.node.dc1.consul.     0       IN      A       10.201.102.200
s1.node.dc1.consul.     0       IN      A       10.201.102.198
s2.node.dc1.consul.     0       IN      A       10.201.102.199

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Tue Mar 28 18:20:15 2017
;; MSG SIZE  rcvd: 165
</code></pre><h3 id="K-／V"><a href="#K-／V" class="headerlink" title="K ／V"></a>K ／V</h3><p>除了提供服务发现和健康检查的集成.Consul提供了一个易用的键/值存储.这可以用来保持动态配置,协助服务协调,领袖选举,做开发者可以想到的任何事情.</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -v http://localhost:8500/v1/kv/?recurse
* About to connect() to localhost port 8500 (#0)
*   Trying ::1... 拒绝连接
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8500 (#0)
&gt; GET /v1/kv/?recurse HTTP/1.1
&gt; User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.21 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2
&gt; Host: localhost:8500
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 404 Not Found
&lt; X-Consul-Index: 1
&lt; X-Consul-Knownleader: true
&lt; X-Consul-Lastcontact: 0
&lt; Date: Thu, 18 Aug 2016 08:21:39 GMT
&lt; Content-Length: 0
&lt; Content-Type: text/plain; charset=utf-8
&lt;
* Connection #0 to host localhost left intact
* Closing connection #0
</code></pre><p>因为没有key所以我们得到了一个404响应.现在我们<code></code>PUT`一些示例的Key:</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -X PUT -d &#39;test&#39; http://localhost:8500/v1/kv/web/key1
[root@dhcp-10-201-102-198 ~]# curl -X PUT -d &#39;test&#39; http://localhost:8500/v1/kv/web/key2?flags=42
[root@dhcp-10-201-102-198 ~]# curl -X PUT -d &#39;test&#39;  http://localhost:8500/v1/kv/web/sub/key3
</code></pre><p>我们创建了值为”test”的3个Key,注意返回的值是经过了base64编码的.用来支持非UTF8编码字符.对Key <code>web/key2</code>我们设置了一个标志值为 <code>42</code>.所有的key支持设置一个64位的整形数字标志.Consul内部不适用这个值.但是他可以被客户端适用来做一些元数据.</p>
<p>完成设置后,我们发起了一个<code>GET</code>请求来接收多个key的值,使用<code>?recurse</code>参数.</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -s http://localhost:8500/v1/kv/web/?recurse | python -m json.tool
[
    {
        &quot;CreateIndex&quot;: 502660,
        &quot;Flags&quot;: 0,
        &quot;Key&quot;: &quot;web/key1&quot;,
        &quot;LockIndex&quot;: 0,
        &quot;ModifyIndex&quot;: 502660,
        &quot;Value&quot;: &quot;dGVzdA==&quot;
    },
    {
        &quot;CreateIndex&quot;: 502663,
        &quot;Flags&quot;: 42,
        &quot;Key&quot;: &quot;web/key2&quot;,
        &quot;LockIndex&quot;: 0,
        &quot;ModifyIndex&quot;: 502663,
        &quot;Value&quot;: &quot;dGVzdA==&quot;
    },
    {
        &quot;CreateIndex&quot;: 502665,
        &quot;Flags&quot;: 0,
        &quot;Key&quot;: &quot;web/sub/key3&quot;,
        &quot;LockIndex&quot;: 0,
        &quot;ModifyIndex&quot;: 502665,
        &quot;Value&quot;: &quot;dGVzdA==&quot;
    }
]
</code></pre><p>你可以获取单个的key</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -s http://localhost:8500/v1/kv/web/key1 | python -m json.tool
[
    {
        &quot;CreateIndex&quot;: 502660,
        &quot;Flags&quot;: 0,
        &quot;Key&quot;: &quot;web/key1&quot;,
        &quot;LockIndex&quot;: 0,
        &quot;ModifyIndex&quot;: 502660,
        &quot;Value&quot;: &quot;dGVzdA==&quot;
    }
]
</code></pre><p>删除key也很简单.通过<code>DELETE</code>动作来完成.我们可以通过指定完整路径来删除一个单独的key.或者我们可以使用<code>?recurse</code>递归的删除主路径下所有key.</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl -X DELETE http://localhost:8500/v1/kv/web/sub?recurse
true
</code></pre><p>可以通过发送相同的URL并提供不同的消息体的<code>PUT</code>请求去修改一个Key.另外,Consul提供一个检查并设置的操作,实现原子的Key修改.通过<code>?cas=</code>参数加上<code>GET</code>中最近的<code>ModifyIndex</code>来达到. 例如我们想修改 “web/key1”:</p>
<pre><code>curl -X PUT -d &#39;newval&#39; http://localhost:8500/v1/kv/web/key1?cas=502660
true
curl -X PUT -d &#39;newval&#39; http://localhost:8500/v1/kv/web/key1?cas=502660
false
</code></pre><p>在这种情况下,第一次<code>CAS</code> 更新成功因为<code>ModifyIndex</code>是<code>502660</code>.而第二次失败是因为<code>ModifyIndex</code>在第一次更新后已经不是<code>502660</code>了 .</p>
<p>我们也可以使用<code>ModifyIndex</code>来等待key值的改变.例如我们想等待<code>key2</code>被修改:</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# curl &quot;http://localhost:8500/v1/kv/web/key2&quot;
[{&quot;LockIndex&quot;:0,&quot;Key&quot;:&quot;web/key2&quot;,&quot;Flags&quot;:42,&quot;Value&quot;:&quot;dGVzdA==&quot;,&quot;CreateIndex&quot;:502663,&quot;ModifyIndex&quot;:502663}]
[root@dhcp-10-201-102-198 ~]# curl &quot;http://localhost:8500/v1/kv/web/key2?index=502663&amp;wait=5s&quot;
[{&quot;LockIndex&quot;:0,&quot;Key&quot;:&quot;web/key2&quot;,&quot;Flags&quot;:42,&quot;Value&quot;:&quot;dGVzdA==&quot;,&quot;CreateIndex&quot;:502663,&quot;ModifyIndex&quot;:502663}]
</code></pre><p>通过提供 <code>?index=</code>,我们请求等待key值有一个比<code>502663</code>更大的<code>ModifyIndex</code>.虽然<code>?wait=5s</code>参数限制了这个请求最多5秒,否则返回当前的未改变的值. 这样可以有效的等待key的改变.另外,这个功能可以用于等待一组key.直到其中的某个key有修改.</p>
<h2 id="Conusl-命令行"><a href="#Conusl-命令行" class="headerlink" title="Conusl 命令行"></a>Conusl 命令行</h2><p>见识了consul的强大，consul可以通过一个简单的CLI来控制，consul只有一个命令行应用，就是consul命令，consul命令可以包含agent、members等参数进行使用，这一篇来具体看看consul CLI的具体用法，consul -h即可看到consul cli所支持的参数，而每个参数里面又支持其他参数，下面我们就来具体看看。</p>
<pre><code>[root@dhcp-10-201-102-198 ~]# consul
usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]

Available commands are:
    agent          Runs a Consul agent  运行一个consul agent
    configtest     Validate config file
    event          Fire a new event
    exec           Executes a command on Consul nodes  在consul节点上执行一个命令
    force-leave    Forces a member of the cluster to enter the &quot;left&quot; state   强制节点成员在集群中的状态转换到left状态
    info           Provides debugging information for operators  提供操作的debug级别的信息
    join           Tell Consul agent to join cluster   加入consul节点到集群中
    keygen         Generates a new encryption key  生成一个新的加密key
    keyring        Manages gossip layer encryption keys
    kv             Interact with the key-value store
    leave          Gracefully leaves the Consul cluster and shuts down
    lock           Execute a command holding a lock
    maint          Controls node or service maintenance mode
    members        Lists the members of a Consul cluster    列出集群中成员
    monitor        Stream logs from a Consul agent  打印consul节点的日志信息
    operator       Provides cluster-level tools for Consul operators
    reload         Triggers the agent to reload configuration files   触发节点重新加载配置文件
    rtt            Estimates network round trip time between nodes
    snapshot       Saves, restores and inspects snapshots of Consul server state
    version        Prints the Consul version    打印consul的版本信息
    watch          Watch for changes in Consul   监控consul的改变

</code></pre><p>更详细见<a href="https://www.consul.io/docs/commands/index.html" target="_blank" rel="noopener">官网</a></p>
<h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p><code>agent</code>指令是consul的核心，它运行agent来维护成员的重要信息、运行检查、服务宣布、查询处理等等。 </p>
<pre><code>==&gt; Usage: consul agent [options]

  Starts the Consul agent and runs until an interrupt is received. The
  agent represents a single node in a cluster.

Options:

  -advertise=addr                  Sets the advertise address to use
  -advertise-wan=addr              Sets address to advertise on wan instead of
                                   advertise addr
  -bootstrap                       Sets server to bootstrap mode
  -bind=0.0.0.0                    Sets the bind address for cluster
                                   communication
  -http-port=8500                  Sets the HTTP API port to listen on
  -bootstrap-expect=0              Sets server to expect bootstrap mode.
  -client=127.0.0.1                Sets the address to bind for client access.
                                   This includes RPC, DNS, HTTP and HTTPS (if
                                   configured)
  -config-file=foo                 Path to a JSON file to read configuration
                                   from. This can be specified multiple times.
  -config-dir=foo                  Path to a directory to read configuration
                                   files from. This will read every file ending
                                   in &quot;.json&quot; as configuration in this
                                   directory in alphabetical order. This can be
                                   specified multiple times.
  -data-dir=path                   Path to a data directory to store agent
                                   state
  -dev                             Starts the agent in development mode.
  -recursor=1.2.3.4                Address of an upstream DNS server.
                                   Can be specified multiple times.
  -dc=east-aws                     Datacenter of the agent (deprecated: use
                                   &#39;datacenter&#39; instead).
  -datacenter=east-aws             Datacenter of the agent.
  -encrypt=key                     Provides the gossip encryption key
  -join=1.2.3.4                    Address of an agent to join at start time.
                                   Can be specified multiple times.
  -join-wan=1.2.3.4                Address of an agent to join -wan at start
                                   time. Can be specified multiple times.
  -retry-join=1.2.3.4              Address of an agent to join at start time
                                   with retries enabled. Can be specified
                                   multiple times.
  -retry-interval=30s              Time to wait between join attempts.
  -retry-max=0                     Maximum number of join attempts. Defaults to
                                   0, which will retry indefinitely.
  -retry-join-ec2-region           EC2 Region to use for discovering servers to
                                   join.
  -retry-join-ec2-tag-key          EC2 tag key to filter on for server
                                   discovery
  -retry-join-ec2-tag-value        EC2 tag value to filter on for server
                                   discovery
  -retry-join-gce-project-name     Google Compute Engine project to discover
                                   servers in
  -retry-join-gce-zone-pattern     Google Compute Engine region or zone to
                                   discover servers in (regex pattern)
  -retry-join-gce-tag-value        Google Compute Engine tag value to filter
                                   for server discovery
  -retry-join-gce-credentials-file Path to credentials JSON file to use with
                                   Google Compute Engine
  -retry-join-wan=1.2.3.4          Address of an agent to join -wan at start
                                   time with retries enabled. Can be specified
                                   multiple times.
  -retry-interval-wan=30s          Time to wait between join -wan attempts.
  -retry-max-wan=0                 Maximum number of join -wan attempts.
                                   Defaults to 0, which will retry
                                   indefinitely.
  -log-level=info                  Log level of the agent.
  -node=hostname                   Name of this node. Must be unique in the
                                   cluster
  -node-meta=key:value             An arbitrary metadata key/value pair for
                                   this node.
                                   This can be specified multiple times.
  -protocol=N                      Sets the protocol version. Defaults to
                                   latest.
  -rejoin                          Ignores a previous leave and attempts to
                                   rejoin the cluster.
  -server                          Switches agent to server mode.
  -syslog                          Enables logging to syslog
  -ui                              Enables the built-in static web UI server
  -ui-dir=path                     Path to directory containing the Web UI
                                   resources
  -pid-file=path                   Path to file to store agent PID
</code></pre><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p><code>event</code>命令提供了一种机制，用来fire自定义的用户事件，这些事件对consul来说是不透明的，但它们可以用来构建自动部署、重启服务或者其他行动的脚本。</p>
<pre><code>-http-addr：http服务的地址，agent可以链接上来发送命令，如果没有设置，则默认是127.0.0.1:8500。
-datacenter：数据中心。
-name：事件的名称
-node：一个正则表达式，用来过滤节点
-service：一个正则表达式，用来过滤节点上匹配的服务
-tag：一个正则表达式，用来过滤节点上符合tag的服务，必须和-service一起使用。
</code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>exec</code>指令提供了一种远程执行机制，比如你要在所有的机器上执行uptime命令，远程执行的工作通过job来指定，存储在KV中，agent使用event系统可以快速的知道有新的job产生，消息是通过gossip协议来传递的，因此消息传递是最佳的，但是并不保证命令的执行。事件通过gossip来驱动，远程执行依赖KV存储系统(就像消息代理一样)。</p>
<pre><code>-http-addr：http服务的地址，agent可以链接上来发送命令，如果没有设置，则默认是127.0.0.1:8500。
-datacenter：数据中心。
-prefix：key在KV系统中的前缀，用来存储请求数据，默认是_rexec
-node：一个正则表达式，用来过滤节点，评估事件
-service：一个正则表达式，用来过滤节点上匹配的服务
-tag：一个正则表达式，用来过滤节点上符合tag的服务，必须和-service一起使用。
-wait：在节点多长时间没有响应后，认为job已经完成。
-wait-repl：
-verbose：输出更多信息
</code></pre><h3 id="force-leave"><a href="#force-leave" class="headerlink" title="force-leave"></a>force-leave</h3><p><code>force-leave</code>治疗可以强制consul集群中的成员进入left状态(空闲状态)，记住，即使一个成员处于活跃状态，它仍旧可以再次加入集群中，这个方法的真实目的是强制移除failed的节点。如果failed的节点还是网络的一部分，则consul会周期性的重新链接failed的节点，如果经过一段时间后(默认是72小时)，consul则会宣布停止尝试链接failed的节点。force-leave指令可以快速的把failed节点转换到left状态。</p>
<pre><code>-rpc-addr:一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400。
</code></pre><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><code>info</code>指令提供了各种操作时可以用到的debug信息，对于client和server，info有返回不同的子系统信息，目前有以下几个KV信息：agent(提供agent信息)，consul(提供consul库的信息)，raft(提供raft库的信息)，serf_lan(提供LAN gossip pool),serf_wan(提供WAN gossip pool) </p>
<pre><code>-rpc-addr：一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400
</code></pre><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>join</code>指令告诉consul agent加入一个已经存在的集群中，一个新的consul agent必须加入一个已经有至少一个成员的集群中，这样它才能加入已经存在的集群中，如果你不加入一个已经存在的集群，则agent是它自身集群的一部分，其他agent则可以加入进来。agents可以加入其他agent多次。consul join [options] address。如果你想加入多个集群，则可以写多个地址，consul会加入所有的地址。</p>
<pre><code>-wan：agent运行在server模式，xxxxxxx
-rpc-addr：一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400。
</code></pre><h3 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h3><p><code>keygen</code>指令生成加密的密钥，可以用在consul agent通讯加密</p>
<pre><code>生成一个key
</code></pre><h3 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h3><p><code>leave</code>指令触发一个优雅的离开动作并关闭agent，节点离开后不会尝试重新加入集群中。运行在server状态的节点，节点会被优雅的删除，这是很严重的，在某些情况下一个不优雅的离开会影响到集群的可用性。</p>
<pre><code>-rpc-addr:一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400。
</code></pre><h3 id="members"><a href="#members" class="headerlink" title="members"></a>members</h3><p><code>members</code>指令输出consul agent目前所知道的所有的成员以及它们的状态，节点的状态只有alive、left、failed三种状态。</p>
<pre><code>-detailed：输出每个节点更详细的信息。
-rpc-addr：一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400。
-status：过滤出符合正则规则的节点
-wan：xxxxxx
</code></pre><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p><code>monitor</code>指令用来链接运行的agent，并显示日志。monitor会显示最近的日志，并持续的显示日志流，不会自动退出，除非你手动或者远程agent自己退出。</p>
<pre><code>-log-level：显示哪个级别的日志，默认是info
-rpc-addr：一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400
</code></pre><h3 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h3><p><code>reload</code>指令可以重新加载agent的配置文件。SIGHUP指令在重新加载配置文件时使用，任何重新加载的错误都会写在agent的log文件中，并不会打印到屏幕。</p>
<pre><code>-rpc-addr：一个rpc地址，agent可以链接上来发送命令，如果没有指定，默认是127.0.0.1:8400
</code></pre><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>打印consul的版本</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code>指令提供了一个机制，用来监视实际数据视图的改变(节点列表、成员服务、KV)，如果没有指定进程，当前值会被dump出来</p>
<pre><code>-http-addr：http服务的地址，agent可以链接上来发送命令，如果没有设置，则默认是127.0.0.1:8500。
-datacenter：数据中心查询。
-token：ACL token
-key：监视key，只针对key类型
-name：监视event，只针对event类型
-prefix：监视key prefix，只针对keyprefix类型
-service：监控service，只针对service类型
-state：过略check state
-tag：过滤service tag
-type：监控类型，一般有key、keyprefix、service、nodes、checks、event
</code></pre><h2 id="Consul-配置"><a href="#Consul-配置" class="headerlink" title="Consul 配置"></a>Consul 配置</h2><p>agent有各种各样的配置项可以在命令行或者配置文件进行定义，所有的配置项都是可选择的，当加载配置文件的时候，consul从配置文件或者配置目录加载配置。后面定义的配置会合并前面定义的配置，但是大多数情况下，合并的意思是后面定义的配置会覆盖前面定义的配置，但是有些情况，例如event句柄，合并仅仅是添加到前面定义的句柄后面。consul重新加载配置文件也支持以信号的方式接收update信号。</p>
<p>下面看看命令行参数：</p>
<pre><code>-advertise：通知展现地址用来改变我们给集群中的其他节点展现的地址，一般情况下-bind地址就是展现地址
-bootstrap：用来控制一个server是否在bootstrap模式，在一个datacenter中只能有一个server处于bootstrap模式，当一个server处于bootstrap模式时，可以自己选举为raft leader。
-bootstrap-expect：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap公用
-bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0
-client：consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1
-config-file：明确的指定要加载哪个配置文件
-config-dir：配置文件目录，里面所有以.json结尾的文件都会被加载
-data-dir：提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在
-dc：该标记控制agent允许的datacenter的名称，默认是dc1
-encrypt：指定secret key，使consul在通讯时进行加密，key可以通过consul keygen生成，同一个集群中的节点必须使用相同的key
-join：加入一个已经启动的agent的ip地址，可以多次指定多个agent的地址。如果consul不能加入任何指定的地址中，则agent会启动失败，默认agent启动时不会加入任何节点。
-retry-join：和join类似，但是允许你在第一次失败后进行尝试。
-retry-interval：两次join之间的时间间隔，默认是30s
-retry-max：尝试重复join的次数，默认是0，也就是无限次尝试
-log-level：consul agent启动后显示的日志信息级别。默认是info，可选：trace、debug、info、warn、err。
-node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名
-protocol：consul使用的协议版本
-rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。
-server：定义agent运行在server模式，每个集群至少有一个server，建议每个集群的server不要超过5个
-syslog：开启系统日志功能，只在linux/osx上生效
-ui-dir:提供存放web ui资源的路径，该目录必须是可读的
-pid-file:提供一个路径来存放pid文件，可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent
</code></pre><p> 除了命令行参数外，配置也可以写入文件中，在某些情况下配置文件会更简单一些，例如：利用consul被用来管理系统。配置文件是json格式的，很容易编写。配置文件不仅被用来设置agent的启动，也可以用来提供健康检测和服务发现的定义。配置文件的一般样例如下：</p>
<pre><code>{
  &quot;datacenter&quot;: &quot;dc1&quot;,
  &quot;data_dir&quot;: &quot;/opt/consul&quot;,
  &quot;log_level&quot;: &quot;INFO&quot;,
  &quot;node_name&quot;: &quot;s1&quot;,
  &quot;server&quot;: true,
  &quot;bootstrap_expect&quot;: 3,
  &quot;bind_addr&quot;: &quot;10.201.102.198&quot;,
  &quot;client_addr&quot;: &quot;0.0.0.0&quot;,
  &quot;ui_dir&quot;: &quot;/root/consul_ui&quot;,
  &quot;retry_join&quot;: [&quot;10.201.102.198&quot;,&quot;10.201.102.199&quot;,&quot;10.201.102.200&quot;,&quot;10.201.102.248&quot;],
  &quot;retry_interval&quot;: &quot;30s&quot;,
  &quot;enable_debug&quot;: false,
  &quot;rejoin_after_leave&quot;: true,
  &quot;start_join&quot;: [&quot;10.201.102.198&quot;,&quot;10.201.102.199&quot;,&quot;10.201.102.200&quot;,&quot;10.201.102.248&quot;],
  &quot;enable_syslog&quot;: true,
  &quot;syslog_facility&quot;: &quot;local5&quot;
}
</code></pre><p>下面看看详细的配置文件参数：</p>
<pre><code>acl_datacenter：只用于server，指定的datacenter的权威ACL信息，所有的servers和datacenter必须同意ACL datacenter
acl_default_policy：默认是allow
acl_down_policy：
acl_master_token：
acl_token：agent会使用这个token和consul server进行请求
acl_ttl：控制TTL的cache，默认是30s
addresses：一个嵌套对象，可以设置以下key：dns、http、rpc
advertise_addr：等同于-advertise
bootstrap：等同于-bootstrap
bootstrap_expect：等同于-bootstrap-expect
bind_addr：等同于-bind
ca_file：提供CA文件路径，用来检查客户端或者服务端的链接
cert_file：必须和key_file一起
check_update_interval：
client_addr：等同于-client
datacenter：等同于-dc
data_dir：等同于-data-dir
disable_anonymous_signature：在进行更新检查时禁止匿名签名
disable_remote_exec：禁止支持远程执行，设置为true，agent会忽视所有进入的远程执行请求
disable_update_check：禁止自动检查安全公告和新版本信息
dns_config：是一个嵌套对象，可以设置以下参数：allow_stale、max_stale、node_ttl 、service_ttl、enable_truncate
domain：默认情况下consul在进行DNS查询时，查询的是consul域，可以通过该参数进行修改
enable_debug：开启debug模式
enable_syslog：等同于-syslog
encrypt：等同于-encrypt
key_file：提供私钥的路径
leave_on_terminate：默认是false，如果为true，当agent收到一个TERM信号的时候，它会发送leave信息到集群中的其他节点上。
log_level：等同于-log-level
node_name:等同于-node
ports：这是一个嵌套对象，可以设置以下key：dns(dns地址：8600)、http(http api地址：8500)、rpc(rpc:8400)、serf_lan(lan port:8301)、serf_wan(wan port:8302)、server(server rpc:8300)
protocol：等同于-protocol
recursor：
rejoin_after_leave：等同于-rejoin
retry_join：等同于-retry-join
retry_interval：等同于-retry-interval
server：等同于-server
server_name：会覆盖TLS CA的node_name，可以用来确认CA name和hostname相匹配
skip_leave_on_interrupt：和leave_on_terminate比较类似，不过只影响当前句柄
start_join：一个字符数组提供的节点地址会在启动时被加入
statsd_addr：
statsite_addr：
syslog_facility：当enable_syslog被提供后，该参数控制哪个级别的信息被发送，默认Local0
ui_dir：等同于-ui-dir
verify_incoming：默认false，如果为true，则所有进入链接都需要使用TLS，需要客户端使用ca_file提供ca文件，只用于consul server端，因为client从来没有进入的链接
verify_outgoing：默认false，如果为true，则所有出去链接都需要使用TLS，需要服务端使用ca_file提供ca文件，consul server和client都需要使用，因为两者都有出去的链接
watches：watch一个详细名单
</code></pre><h2 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h2><p>consul的主要接口是RESTful HTTP API，该API可以用来增删查改nodes、services、checks、configguration。所有的endpoints主要分为以下类别：</p>
<pre><code>kv - Key/Value存储
agent - Agent控制
catalog - 管理nodes和services
health - 管理健康监测
session - Session操作
acl - ACL创建和管理
event - 用户Events
status - Consul系统状态
</code></pre><p>下面我们就单独看看每个模块的具体内容。</p>
<h3 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h3><p>agent endpoints用来和本地agent进行交互，一般用来服务注册和检查注册，支持以下接口</p>
<pre><code>/v1/agent/checks : 返回本地agent注册的所有检查(包括配置文件和HTTP接口)
/v1/agent/services : 返回本地agent注册的所有 服务
/v1/agent/members : 返回agent在集群的gossip pool中看到的成员
/v1/agent/self : 返回本地agent的配置和成员信息
/v1/agent/join/&lt;address&gt; : 触发本地agent加入node
/v1/agent/force-leave/&lt;node&gt;&gt;: 强制删除node
/v1/agent/check/register : 在本地agent增加一个检查项，使用PUT方法传输一个json格式的数据
/v1/agent/check/deregister/&lt;checkID&gt; : 注销一个本地agent的检查项
/v1/agent/check/pass/&lt;checkID&gt; : 设置一个本地检查项的状态为passing
/v1/agent/check/warn/&lt;checkID&gt; : 设置一个本地检查项的状态为warning
/v1/agent/check/fail/&lt;checkID&gt; : 设置一个本地检查项的状态为critical
/v1/agent/service/register : 在本地agent增加一个新的服务项，使用PUT方法传输一个json格式的数据
/v1/agent/service/deregister/&lt;serviceID&gt; : 注销一个本地agent的服务项
</code></pre><h3 id="catalog"><a href="#catalog" class="headerlink" title="catalog"></a>catalog</h3><p>catalog endpoints用来注册/注销nodes、services、checks</p>
<pre><code>/v1/catalog/register : Registers a new node, service, or check
/v1/catalog/deregister : Deregisters a node, service, or check
/v1/catalog/datacenters : Lists known datacenters
/v1/catalog/nodes : Lists nodes in a given DC
/v1/catalog/services : Lists services in a given DC
/v1/catalog/service/&lt;service&gt; : Lists the nodes in a given service
/v1/catalog/node/&lt;node&gt; : Lists the services provided by a node
</code></pre><h3 id="health"><a href="#health" class="headerlink" title="health"></a>health</h3><p>health endpoints用来查询健康状况相关信息，该功能从catalog中单独分离出来</p>
<pre><code>/v1/healt/node/&lt;node&gt;: 返回node所定义的检查，可用参数?dc=
/v1/health/checks/&lt;service&gt;: 返回和服务相关联的检查，可用参数?dc=
/v1/health/service/&lt;service&gt;: 返回给定datacenter中给定node中service
/v1/health/state/&lt;state&gt;: 返回给定datacenter中指定状态的服务，state可以是&quot;any&quot;, &quot;unknown&quot;, &quot;passing&quot;, &quot;warning&quot;, or &quot;critical&quot;，可用参数?dc=
</code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session endpoints用来create、update、destory、query sessions</p>
<pre><code>/v1/session/create: Creates a new session
/v1/session/destroy/&lt;session&gt;: Destroys a given session
/v1/session/info/&lt;session&gt;: Queries a given session
/v1/session/node/&lt;node&gt;: Lists sessions belonging to a node
/v1/session/list: Lists all the active sessions
</code></pre><h3 id="acl"><a href="#acl" class="headerlink" title="acl"></a>acl</h3><p>acl endpoints用来create、update、destory、query acl</p>
<pre><code>/v1/acl/create: Creates a new token with policy
/v1/acl/update: Update the policy of a token
/v1/acl/destroy/&lt;id&gt;: Destroys a given token
/v1/acl/info/&lt;id&gt;: Queries the policy of a given token
/v1/acl/clone/&lt;id&gt;: Creates a new token by cloning an existing token
/v1/acl/list: Lists all the active tokens
</code></pre><h3 id="event-1"><a href="#event-1" class="headerlink" title="event"></a>event</h3><p>event endpoints用来fire新的events、查询已有的events</p>
<pre><code>/v1/event/fire/&lt;name&gt;: 触发一个新的event，用户event需要name和其他可选的参数，使用PUT方法
/v1/event/list: 返回agent知道的events
</code></pre><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>status endpoints用来或者consul 集群的信息</p>
<pre><code>/v1/status/leader : 返回当前集群的Raft leader
/v1/status/peers : 返回当前集群中同事
</code></pre><h2 id="Consul-Template"><a href="#Consul-Template" class="headerlink" title="Consul-Template"></a>Consul-Template</h2><p> 在consul-template没出现之前，大家构建服务发现系统，大多采用的是zookeeper、etcd+confd这样类似的系统，之前写过一篇consul+confd的文，讲的是如何动态生成配置文件的，如今consul官方推出了自己的模板系统，就是consul-template，这样的话动态的配置系统可以分化为etcd+confd和consul+consul-template两大阵营。consul是一个和etcd类似但又强于etcd的系统，关于etcd和consul可以翻阅以前的文章，consul-template的定位就和confd差不多一样了，confd的后端可以是etcd或者consul，相信consul搭配consul-template能发挥更大的效果。consul-template提供了一个便捷的方式从consul中获取存储的值，consul-template守护进程会查询consul实例，来更新系统上指定的任何模板，当更新完成后，模板可以选择运行一些任意的命令。</p>
<pre><code>    consul template的使用场景：consul template可以查询consul中的服务目录、key、key-values等。这种强大的抽象功能和查询语言模板可以使consul template特别适合动态的创建配置文件。例如：创建apache/nginx proxy balancers、haproxy backends、varnish servers、application configurations。
</code></pre><p>consul template的特性：</p>
<pre><code>    quiescence：consul template内制静止平衡功能，可以智能的发现consul实例中的更改信息。这个功能可以防止频繁的更新模板而引起系统的波动。
    dry mode：不确定当前架构的状态？担心模板的变化会破坏子系统？无须担心，因为consul template还有-dry模式。在dry模式，consul template会将结果呈现在STDOUT，所以操作员可以检查输出是否正常，以决定更换模板是否安全
    CLI and Config：如果你喜欢在命令行上指定一切，consul template都可以hold住。随着内置HCL的支持，consul template接收一个配置文件，命令行参数，或者两者的混合。通过这种方式你可以继续使用你现在已有的配置管理工具和consul template来配合。
    verbose debugging：即使每件事你都做的近乎完美，但是有时候还是会有失败发生。consul template可以提供更详细的debug日志信息。
</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>你可以在<a href="https://releases.hashicorp.com/consul-template/" target="_blank" rel="noopener">发布页</a>下载发布包.如果你希望自己编译请查看<a href="https://github.com/hashicorp/consul-template#contributing" target="_blank" rel="noopener">说明文档</a>.</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>  -auth=&lt;user[:pass]&gt;      设置基本的认证用户名和密码
  -consul-addr=&lt;address&gt;   设置Consul实例的地址
  -max-stale=&lt;duration&gt;    查询过期的最大频率，默认是1s
  -dedup                   启用重复数据删除，当许多consul template实例渲染一个模板的时候可以降低consul的负载
  -ssl                     使用https连接Consul使用SSL
  -ssl-verify              通过SSL连接的时候检查证书
  -ssl-cert                SSL客户端证书发送给服务器
  -ssl-key                 客户端认证时使用的SSL/TLS私钥
  -ssl-ca-cert             验证服务器的CA证书列表
  -token=&lt;token&gt;           设置Consul API的token
  -syslog                  把标准输出和标准错误重定向到syslog，syslog的默认级别是local0。
  -syslog-facility=&lt;f&gt;     设置syslog级别，默认是local0，必须和-syslog配合使用
  -template=&lt;template&gt;     增加一个需要监控的模板，格式是：&#39;templatePath:outputPath(:command)&#39;，多个模板则可以设置多次
  -wait=&lt;duration&gt;         当呈现一个新的模板到系统和触发一个命令的时候，等待的最大最小时间。如果最大值被忽略，默认是最小值的4倍。
  -retry=&lt;duration&gt;        当在和consul api交互的返回值是error的时候，等待的时间，默认是5s。
  -config=&lt;path&gt;           配置文件或者配置目录的路径
  -pid-file=&lt;path&gt;         PID文件的路径
  -log-level=&lt;level&gt;       设置日志级别，可以是&quot;debug&quot;,&quot;info&quot;, &quot;warn&quot; (default), and &quot;err&quot;
  -dry                     Dump生成的模板到标准输出，不会生成到磁盘
  -once                    运行consul-template一次后退出，不以守护进程运行
  -reap                    子进程自动收割
</code></pre><p>查看全部选项,使用以下命令</p>
<pre><code>consul-template -h
</code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>1、查询本地consl实例，生成模板后重启nginx，如果consul不可用，如果api故障则每30s尝试检测一次值，consul-template运行一次后退出</p>
<pre><code>consul-template -retry 30s -once -consul-addr=10.201.102.198:8500 -template &quot;test.ctmpl:test.out&quot;
</code></pre><ul>
<li>test.ctmpl</li>
</ul>
<pre><code>{{range service "Faceid"}}
{{.ID}} {{.Address}}:{{.Port}} check inter 5000 fall 1 rise 2 weight 2{{end}}
</code></pre><ul>
<li>test.out</li>
</ul>
<pre><code>Faceid 10.201.102.198:9000 check inter 5000 fall 1 rise 2 weight 2
Faceid 10.201.102.199:9000 check inter 5000 fall 1 rise 2 weight 2
Faceid 10.201.102.200:9000 check inter 5000 fall 1 rise 2 weight 2
</code></pre><p>2、运行consul-temple作为一个服务</p>
<pre><code>consul-template -consul-addr=10.201.102.198:8500 -template &quot;test.ctmpl:test.out&quot;
</code></pre><p>3、查询一个实例，渲染多个模板，然后重启相关服务</p>
<pre><code>consul-template -retry 30s -once -consul-addr=10.201.102.198:8500 -template &quot;test.ctmpl:test.out&quot;\
 -template &quot;/tmp/redis.ctmpl:/var/redis/redis.conf:service redis restart&quot; \
 -template &quot;/tmp/haproxy.ctmpl:/var/haproxy/haproxy.conf&quot;
</code></pre><p>4、查询一个实例，dump模板到标准输出，参数中的-template则会被忽略</p>
<pre><code>consul-template -dry -consul-addr=10.201.102.198:8500 -template &quot;test.ctmpl:test.out&quot;
</code></pre><pre><code>以上参数除了在命令行使用，也可以直接配置在文件中，下面看看Consul-Template的配置文件，简称HCL(HashiCorp Configuration Language)，它是和JSON兼容的，下面看个例子：
</code></pre><pre><code>#### 配置文件

​```Consul-Template```配置文件是使用[HashiCorp Configuration Language (HCL)](https://github.com/hashicorp/hcl)编写的.这意味着```Consul Template```是和JSON兼容的,查看更多信息请查看 [HCL 规范](https://github.com/hashicorp/hcl)

配置文件语法支持上面的所有的选项,除非在表格中进行标明.

​```json

// 这是要连接的Consul Agent的地址.默认为127.0.0.1:8500.这是Consul的默认绑定地址和端口.
// 不建议你直接与 Consul的 Server直接进行交互,请与本地的Consul Agent进行交互.这样做是有一些原因
// 最重要的是本地agent可以复用与server的连接.减少HTTP的连接数.另外这个地址更好记.
consul = &quot;127.0.0.1:8500&quot;

// 这是用于连接Consul的ACL token. 如果你的集群未启用就不需要设置.
//
// 这个选项也可以通过环境变量 CONSUL_TOKEN 来进行设置
token = &quot;abcd1234&quot;

// 这是监听出发reload事件的信号,默认值如下所示.将这个值设置为空将引起 CT ,从而不监听reload事件
reload_signal = &quot;SIGHUP&quot;

// 这是监听出发core dump事件的信号,默认值如下所示.将这个值设置为空将引起 CT ,从而不监听core dump信号
dump_signal = &quot;SIGQUIT&quot;

// 这是监听出发graceful stop事件的信号,默认值如下所示.将这个值设置为空将引起 CT ,从而不监听graceful stop信号
kill_signal = &quot;SIGINT&quot;

// 这是连接Consul的重试时间.Consul Template是高容错的设计.这意味着,出现失败他不会退出.而按照
// 分布式系统的惯例进行指数补偿和重试来等待集群恢复.
retry = &quot;10s&quot;

// This is the maximum interval to allow &quot;stale&quot; data. By default, only the
// Consul leader will respond to queries; any requests to a follower will
// forward to the leader. In large clusters with many requests, this is not as
// scalable, so this option allows any follower to respond to a query, so long
// as the last-replicated data is within these bounds. Higher values result in
// less cluster load, but are more likely to have outdated data.
// 这是允许陈旧数据的最大时间.Consul默认只有领袖对请求进行相应.所有对追随者的请求将被转发给领袖.
// 在有大量请求的大型集群中,这显得不够有扩展性.所以这个选项允许任何追随者响应查询,只要最后复制的数据
// 在这个范围内.数值越高,越减少集群负载,但是更容易接受到过期数据.
max_stale = &quot;10m&quot;

// 这是log的等级,如果你找到了bug,请打开debug 日志,这样我们可以更好的定位问题.这个选项也可用在命令行.
log_level = &quot;warn&quot;

// 这是存放Consul Template 进程的PID文件的路径,如果你计划发送定制的信号到这个进程这会比较有用.
pid_file = &quot;/path/to/pid&quot;

// 这是一个静止定时器,他定义了在模板渲染之前等待集群达到一致状态的最小和最大时间.
// 这对于一些变化较大的系统中比较有用,可以减少模板渲染的次数
wait = &quot;5s:10s&quot;


// 这是 Vault配置的开始
// Vault是HashiCorp的另外一个产品
vault {
  // This is the address of the Vault leader. The protocol (http(s)) portion
  // of the address is required.
  address = &quot;https://vault.service.consul:8200&quot;

  // This is the token to use when communicating with the Vault server.
  // Like other tools that integrate with Vault, Consul Template makes the
  // assumption that you provide it with a Vault token; it does not have the
  // incorporated logic to generate tokens via Vault&#39;s auth methods.
  //
  // This value can also be specified via the environment variable VAULT_TOKEN.
  token = &quot;abcd1234&quot;

  // This option tells Consul Template to automatically renew the Vault token
  // given. If you are unfamiliar with Vault&#39;s architecture, Vault requires
  // tokens be renewed at some regular interval or they will be revoked. Consul
  // Template will automatically renew the token at half the lease duration of
  // the token. The default value is true, but this option can be disabled if
  // you want to renew the Vault token using an out-of-band process.
  //
  // Note that secrets specified in a template (using {{secret}} for example)
  // are always renewed, even if this option is set to false. This option only
  // applies to the top-level Vault token itself.
  renew = true

  // This section details the SSL options for connecting to the Vault server.
  // Please see the SSL options below for more information (they are the same).
  ssl {
    // ...
  }
}

// 这部分配置请求的基本的权限验证信息
auth {
  enabled  = true
  username = &quot;test&quot;
  password = &quot;test&quot;
}

// 这部分配置连接到Consul服务器的SSL信息.
ssl {
  // 使用SSL需要先打开这个开关
  enabled = true

  // This enables SSL peer verification. The default value is &quot;true&quot;, which
  // will check the global CA chain to make sure the given certificates are
  // valid. If you are using a self-signed certificate that you have not added
  // to the CA chain, you may want to disable SSL verification. However, please
  // understand this is a potential security vulnerability.
  verify = false

  // This is the path to the certificate to use to authenticate. If just a
  // certificate is provided, it is assumed to contain both the certificate and
  // the key to convert to an X509 certificate. If both the certificate and
  // key are specified, Consul Template will automatically combine them into an
  // X509 certificate for you.
  cert = &quot;/path/to/client/cert&quot;
  key = &quot;/path/to/client/key&quot;

  // This is the path to the certificate authority to use as a CA. This is
  // useful for self-signed certificates or for organizations using their own
  // internal certificate authority.
  ca_cert = &quot;/path/to/ca&quot;
}

// 设置连接到syslog服务器的配置
// 用于进行日志记录syslog {
  // 打开开关
  enabled = true

  // 设备名称
  facility = &quot;LOCAL5&quot;
}

// This block defines the configuration for de-duplication mode. Please see the
// de-duplication mode documentation later in the README for more information
// on how de-duplication mode operates.
deduplicate {
  // This enables de-duplication mode. Specifying any other options also enables
  // de-duplication mode.
  enabled = true

  // This is the prefix to the path in Consul&#39;s KV store where de-duplication
  // templates will be pre-rendered and stored.
  prefix = &quot;consul-template/dedup/&quot;
}

// This block defines the configuration for exec mode. Please see the exec mode
// documentation at the bottom of this README for more information on how exec
// mode operates and the caveats of this mode.
exec {
  // This is the command to exec as a child process. There can be only one
  // command per Consul Template process.
  command = &quot;/usr/bin/app&quot;

  // This is a random splay to wait before killing the command. The default
  // value is 0 (no wait), but large clusters should consider setting a splay
  // value to prevent all child processes from reloading at the same time when
  // data changes occur. When this value is set to non-zero, Consul Template
  // will wait a random period of time up to the splay value before reloading
  // or killing the child process. This can be used to prevent the thundering
  // herd problem on applications that do not gracefully reload.
  splay = &quot;5s&quot;

  // This defines the signal that will be sent to the child process when a
  // change occurs in a watched template. The signal will only be sent after
  // the process is started, and the process will only be started after all
  // dependent templates have been rendered at least once. The default value
  // is &quot;&quot; (empty or nil), which tells Consul Template to restart the child
  // process instead of sending it a signal. This is useful for legacy
  // applications or applications that cannot properly reload their
  // configuration without a full reload.
  reload_signal = &quot;SIGUSR1&quot;

  // This defines the signal sent to the child process when Consul Template is
  // gracefully shutting down. The application should begin a graceful cleanup.
  // If the application does not terminate before the `kill_timeout`, it will
  // be terminated (effectively &quot;kill -9&quot;). The default value is &quot;SIGTERM&quot;.
  kill_signal = &quot;SIGINT&quot;

  // This defines the amount of time to wait for the child process to gracefully
  // terminate when Consul Template exits. After this specified time, the child
  // process will be force-killed (effectively &quot;kill -9&quot;). The default value is
  // &quot;30s&quot;.
  kill_timeout = &quot;2s&quot;
}

// 这部分定义了对模板的配置,和其他配置块不同.这部分可以针对不同模板配置多次.也可以在CLI命令
// 直接进行配置
template {
  // 这是输入模板的配置文件路径,必选项
  source = &quot;/path/on/disk/to/template.ctmpl&quot;

  // 这是源模板渲染之后存放的路径,如果父目录不存在Consul Template会尝试进行创建
  destination = &quot;/path/on/disk/where/template/will/render.txt&quot;

  // This is the optional command to run when the template is rendered. The
  // command will only run if the resulting template changes. The command must
  // return within 30s (configurable), and it must have a successful exit code.
  // Consul Template is not a replacement for a process monitor or init system.
  // 这是当模板渲染完成后可选的要执行的命令.这个命令只会在模板发生改变后才会运行.这个命令必须要在30秒
  // 内进行返回(可配置),必须返回一个成功的退出码.Consul Template不能替代进程监视或者init 系统
  // 的功能
  command = &quot;restart service foo&quot;

  // 这是最大的等待命令返回的时间,默认是30秒
  command_timeout = &quot;60s&quot;

  // 这是渲染后的文件的权限,如果不设置,Consul Template将去匹配之前已经存在的文件的权限.
  // 如果文件不存在,权限会被设置为 0644
  perms = 0600

  // 这个选项对渲染之前的文件进行备份.他保持一个备份.
  // 这个选项在发生意外更高时,有一个回滚策略.
  backup = true

  // 模板的分隔符,默认是 &quot;{{"和"}}&quot;.但是对于一些模板用其他的分隔符可能更好
  // 可以避免与本身的冲突
  left_delimiter  = &quot;{{"
  right_delimiter = "}}&quot;

  // 这是最小和最大等待渲染一个新模板和执行命令的时间.使用 分号 个号.如果忽略最大值,最大
  // 值会被设置为最小值的4倍.这个选项没有默认值.这个值相对全局所以的等待时间有最高优先级
  wait = &quot;2s:6s&quot;
}
</code></pre><blockquote>
<p>注意: 不是所有的选项都是必选的.例如: 如果你没有使用Vault你不用设置这一块. 类似的你没有使用syslog系统你也不需要指定syslog配置.</p>
</blockquote>
<p>为了更加安全,<code>token</code>也可以从环境变量里读取,使用 <code>CONSUL_TOKEN</code> 和 <code>VAULT_TOKEN</code>.强烈建议你不要把token放到未加密的文本配置文件中.</p>
<h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><p>Consul Template 使用了Go的模板语法.如果你对他的语法不熟悉建议你读下文档.他的语法看起来与 Mustache, Handlebars, 或者 Liquid 类似.</p>
<p>在Go 提供的模板函数之外,Consul Template暴露了以下的函数:</p>
<h3 id="API-函数"><a href="#API-函数" class="headerlink" title="API 函数"></a>API 函数</h3><h5 id="datacenters"><a href="#datacenters" class="headerlink" title="datacenters"></a>datacenters</h5><p>查询目录中的所有数据中心.使用以下语法:</p>
<pre><code>{{datacenters}}

</code></pre><h5 id="file"><a href="#file" class="headerlink" title="file"></a>file</h5><p>读取并输出磁盘上的本地文件,如果无法读取产生一个错误.使用如下语法</p>
<pre><code>{{file "/path/to/local/file"}}

</code></pre><p>这个例子将输出 <code>/path/to/local/file</code> 文件内容到模板. <strong>注意:这不会在嵌套模板中被处理</strong></p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>查询Consul指定key的值,如果key的值不能转换为字符串,将产生错误.使用如下语法:</p>
<pre><code>{{key "service/redis/maxconns@east-aws"}}

</code></pre><p>上面的例子查询了在<code>east-aws</code>数据中心的 <code>service/redis/maxconns</code>的值.如果忽略数据中心参数,将会查询本地数据中心的值:</p>
<pre><code>{{key "service/redis/maxconns"}}

</code></pre><p>Consul键值结构的美妙在于,这完全取决于你!</p>
<h5 id="key-or-default"><a href="#key-or-default" class="headerlink" title="key_or_default"></a>key_or_default</h5><p>查询Consul中指定的key的值,如果key不存在,则返回默认值.使用方式如下</p>
<pre><code>{{key_or_default "service/redis/maxconns@east-aws" "5"}}

</code></pre><p>注意Consul Template使用了多个阶段的运算.在第一阶段的运算如果Consul没有返回值,则会一直使用默认值.后续模板解析中如果值存在了则会读取真实的值.这很重要,运维Consul Templae不会因为<code>key_or_default</code>没找到key而阻塞模板的的渲染.即使key存在如果Consul没有按时返回这个数据,也会使用默认值来进行替代.</p>
<h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>查看Consul的所有以指定前缀开头的key-value对.如果有值无法转换成字符串则会产生一个错误:</p>
<pre><code>{{range ls "service/redis@east-aws"}}
{{.Key}} {{.Value}}{{end}}

</code></pre><p>如果Consul实例在<code>east-aws</code>数据中心存在这个结构<code>service/redis</code>,渲染后的模板应该类似这样:</p>
<pre><code>minconns 2
maxconns 12

</code></pre><p>如果你忽略数据中心属性,则会返回本地数据中心的查询结果.</p>
<h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><p>查询目录中的一个节点信息</p>
<pre><code>{{node "node1"}}

</code></pre><p>如果未指定任何参数,则当前agent所在节点将会被返回:</p>
<pre><code>{{node}}

</code></pre><p>你可以指定一个可选的参数来指定数据中心:</p>
<pre><code>{{node "node1" "@east-aws"}}

</code></pre><p>如果指定的节点没有找到则会返回<code>nil</code>.如果节点存在就会列出节点的信息和节点提供的服务.</p>
<pre><code>{{with node}}{{.Node.Node}} ({{.Node.Address}}){{range .Services}}
  {{.Service}} {{.Port}} ({{.Tags | join ","}}){{end}}
{{end}}

</code></pre><h5 id="nodes"><a href="#nodes" class="headerlink" title="nodes"></a>nodes</h5><p>查询目录中的全部节点,使用如下语法</p>
<pre><code>{{nodes}}

</code></pre><p>这个例子会查询Consul的默认数据中心.你可以使用可选参数指定一个可选参数来指定数据中心:</p>
<pre><code>{{nodes "@east-aws"}}

</code></pre><p>这个例子会查询<code>east-aws</code>数据中心的所有几点.</p>
<h5 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h5><p>查询<code>Vault</code>中指定路径的密匙.如果指定的路径不存在或者<code>Vault</code>的Token没有足够权限去读取指定的路径,将会产生一个错误.如果路径存在但是key不存在则返回<code></code>.</p>
<pre><code>{{with secret "secret/passwords"}}{{.Data.password}}{{end}}

</code></pre><p>可以使用如下字段:</p>
<pre><code>LeaseID - the unique lease identifier
LeaseDuration - the number of seconds the lease is valid
Renewable - if the secret is renewable
Data - the raw data - this is a map[string]interface{}, so it can be queried using Go&#39;s templating &quot;dot notation&quot;
If the map key has dots &quot;.&quot; in it, you need to access the value using the index function:

{{index .Data "my.key.with.dots"}}
If additional arguments are passed to the function, then the operation is assumed to be a write operation instead of a read operation. The write operation must return data in order to be valid. This is especially useful for the PKI secret backend, for example.

{{ with secret "pki/issue/my-domain-dot-com" "common_name=foo.example.com" }}
{{ .Data.certificate }}
{{ end }}
The parameters must be key=value pairs, and each pair must be its own argument to the function:

{{ secret "path/" "a=b" "c=d" "e=f" }}
Please always consider the security implications of having the contents of a secret in plain-text on disk. If an attacker is able to get access to the file, they will have access to plain-text secrets.

</code></pre><p>Please note that Vault does not support blocking queries. As a result, Consul Template will not immediately reload in the event a secret is changed as it does with Consul’s key-value store. Consul Template will fetch a new secret at half the lease duration of the original secret. For example, most items in Vault’s generic secret backend have a default 30 day lease. This means Consul Template will renew the secret every 15 days. As such, it is recommended that a smaller lease duration be used when generating the initial secret to force Consul Template to renew more often.</p>
<h5 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h5><p>Query Vault to list the secrets at the given path. Please note this requires Vault 0.5+ and the endpoint you want to list secrets must support listing. Not all endpoints support listing. The result is the list of secret names as strings.</p>
<pre><code>{{range secrets "secret/"}}{{.}}{{end}}

</code></pre><p>The trailing slash is optional in the template, but the generated secret dependency will always have a trailing slash in log output.</p>
<p>To iterate and list over every secret in the generic secret backend in Vault, for example, you would need to do something like this:</p>
<pre><code>{{range secrets "secret/"}}
{{with secret (printf "secret/%s" .)}}
{{range $k, $v := .Data}}
{{$k}}: {{$v}}
{{end}}
{{end}}
{{end}}

</code></pre><p>You should probably never do this. Please also note that Vault does not support blocking queries. To understand the implications, please read the note at the end of the secret function.</p>
<h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><p>查询Consul中匹配表达式的服务.语法如下:</p>
<pre><code>{{service "release.web@east-aws"}}

</code></pre><p>上面的例子查询Consul中,在<code>east-aws</code>数据中心存在的健康的 <code>web</code>服务.tag和数据中心参数是可选的.从当前数据中心查询所有节点的<code>web</code>服务而不管tag,查询语法如下:</p>
<pre><code>{{service "web"}}

</code></pre><p>这个函数返回<code>[]*HealthService</code>结构.可按照如下方式应用到模板:</p>
<pre><code>{{range service "web@data center"}}
server {{.Name}} {{.Address}}:{{.Port}}{{end}}

</code></pre><p>产生如下输出:</p>
<pre><code>server nyc_web_01 123.456.789.10:8080
server nyc_web_02 456.789.101.213:8080

</code></pre><p>默认值会返回健康的服务,如果你想获取所有服务,可以增加<code>any</code>选项,如下:</p>
<pre><code>{{service "web" "any"}}

</code></pre><p>这样就会返回注册过的所有服务,而不论他的状态如何.</p>
<p>如果你想过滤指定的一个或者多个健康状态,你可以通过逗号隔开多个健康状态:</p>
<pre><code>{{service "web" "passing, warning"}}

</code></pre><p>这样将会返回被他们的节点和服务级别的检查定义标记为 “passing” 或者 “warning”的服务. 请注意逗号是 <code>OR</code>而不是<code>AND</code>的意思.</p>
<p>指定了超过一个状态过滤,并包含<code>any</code>将会返回一个错误.因为<code>any</code>是比所有状态更高级的过滤.</p>
<p>后面这2种方式有些架构上的不同:</p>
<pre><code>{{service "web"}}
{{service "web" "passing"}}

</code></pre><p>前者会返回Consul认为<code>healthy</code>和<code>passing</code>的所有服务.后者将返回所有已经在Consul注册的服务.然后会执行一个客户端的过滤.通常如果你想获取健康的服务,你应该不要使用<code>passing</code>参数,直接忽略第三个参数即可.然而第三个参数在你想查询 <code>passing</code>或者<code>warning</code>的服务会比较有用,如下:</p>
<pre><code>{{service "web" "passing, warning"}}

</code></pre><p>服务的状态也是可见的,如果你想自己做一些额外的过滤,语法如下:</p>
<pre><code>{{range service "web" "any"}}
{{if eq .Status "critical"}}
// Critical state!{{end}}
{{if eq .Status "passing"}}
// Ok{{end}}

</code></pre><p>执行命令时,在Consul将服务设置为维护模式,只需要在你的命令上包上Consul的 <code>maint</code> 调用:</p>
<pre><code>#!/bin/sh
set -e
consul maint -enable -service web -reason &quot;Consul Template updated&quot;
service nginx reload
consul maint -disable -service web

</code></pre><p>另外如果你没有安装Consul agent,你可以直接调用API请求:</p>
<pre><code>#!/bin/sh
set -e
curl -X PUT &quot;http://$CONSUL_HTTP_ADDR/v1/agent/service/maintenance/web?enable=true&amp;reason=Consul+Template+Updated&quot;
service nginx reload
curl -X PUT &quot;http://$CONSUL_HTTP_ADDR/v1/agent/service/maintenance/web?enable=false&quot;

</code></pre><h5 id="services"><a href="#services" class="headerlink" title="services"></a>services</h5><p>查询Consul目录中的所有服务,使用如下语法:</p>
<pre><code>{{services}}

</code></pre><p>这个例子将查询Consul的默认数据中心,你可以指定一个可选参数来指定数据中心:</p>
<pre><code>{{services "@east-aws"}}

</code></pre><p>请注意: <code>services</code>函数与<code>service</code>是不同的,<code>service</code>接受更多参数并且查询监控的服务列表.这个查询Consul目录并返回一个服务的tag的Map,如下:</p>
<pre><code>{{range services}}
{{.Name}}
{{range .Tags}}
  {{.}}{{end}}
{{end}}

</code></pre><h5 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h5><p>查询所有指定前缀的key-value值对,如果其中的值有无法转换为字符串的则引发错误:</p>
<pre><code>{{range tree "service/redis@east-aws"}}
{{.Key}} {{.Value}}{{end}}

</code></pre><p>如果Consul实例在<code>east-aws</code>数据中心有一个<code>service/redis</code>结构,模板的渲染结果类似下面:</p>
<pre><code>minconns 2
maxconns 12
nested/config/value &quot;value&quot;

</code></pre><p>和<code>ls</code>不同,<code>tree</code>返回前缀下的所有key.和Unix的tree命令比较像.如果忽略数据中心参数,则会使用本地数据中心</p>
<p><a href="https://book-consul-guide.vnzmi.com/11_consul_template.html" target="_blank" rel="noopener">查看更多</a></p>
<p><a href="https://book-consul-guide.vnzmi.com/11_consul_template.html" target="_blank" rel="noopener">项目Github地址</a></p>
<h3 id="Haproxy-实例"><a href="#Haproxy-实例" class="headerlink" title="Haproxy 实例"></a>Haproxy 实例</h3><p>根据haproxy服务的配置文件创建一个consul-template模版渲染文件：<code>haproxy.ctmpl</code></p>
<pre><code># Consul Haproxy configured

global
        maxconn         20480
        ulimit-n        65535
        log             127.0.0.1 local5
        uid             200
        gid             200
        chroot          /usr/local/haproxy
        nbproc          1
        daemon
        pidfile         /usr/local/haproxy/logs/haproxy.pid

defaults
        log             global
        mode            http
        option          httplog
        option          dontlognull
        option          forwardfor
        option          abortonclose
        retries         3
        maxconn         3000
        stats           enable
        stats           hide-version
        stats   uri     /admin
        stats   auth    admin:admin
        stats   refresh 10s
        balance         roundrobin
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms
        timeout check 2000ms

listen web_haproxy
        bind 0.0.0.0:8080
        mode http
        log     127.0.0.1 local5 err
        stats   refresh 5s
        stats   uri /admin
        stats   realm liang lian
        stats   auth admin:admin
        stats   hide-version
        stats   admin if TRUE

frontend consul
        bind    0.0.0.0:8500
        mode    http
        log     global
        default_backend consul-cluster

backend consul-cluster
        mode http
        {{range service "Faceid"}}
        server {{.ID}} {{.Address}}:{{.Port}} check inter 5000 fall 1 rise 2 weight 2{{end}}
</code></pre><p>运行consul-template作为一个服务,通过上面的渲染模版渲染一个haproxy.cfg的配置文件，然后重启haproxy服务</p>
<pre><code>consul-template -consul-addr=10.201.102.185:8500 -template &quot;/root/haproxy.ctmpl:/etc/haproxy.cfg:service haproxy restart&quot;
</code></pre><blockquote>
<p>10.201.102.185 看我上篇文章<a href="http://www.liangxiansen.cn/2017/03/06/haproxy/">Haproxy</a>，这是consul集群的VIP，为了避免单独调某一台服务器服务器出现故障后consul-template无法工作。</p>
</blockquote>
<p>渲染后的<code>haproxy.cfg</code></p>
<pre><code># Consul Haproxy configured

global
        maxconn         20480
        ulimit-n        65535
        log             127.0.0.1 local5
        uid             200
        gid             200
        chroot          /usr/local/haproxy
        nbproc          1
        daemon
        pidfile         /usr/local/haproxy/logs/haproxy.pid

defaults
        log             global
        mode            http
        option          httplog
        option          dontlognull
        option          forwardfor
        option          abortonclose
        retries         3
        maxconn         3000
        stats           enable
        stats           hide-version
        stats   uri     /admin
        stats   auth    admin:admin
        stats   refresh 10s
        balance         roundrobin
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms
        timeout check 2000ms

listen web_haproxy
        bind 0.0.0.0:8080
        mode http
        log     127.0.0.1 local5 err
        stats   refresh 5s
        stats   uri /admin
        stats   realm liang lian
        stats   auth admin:admin
        stats   hide-version
        stats   admin if TRUE

frontend consul
        bind    0.0.0.0:8500
        mode    http
        log     global
        default_backend consul-cluster

backend consul-cluster
        mode http

        server Faceid 10.201.102.198:9000 check inter 5000 fall 1 rise 2 weight 2
        server Faceid 10.201.102.199:9000 check inter 5000 fall 1 rise 2 weight 2
        server Faceid 10.201.102.200:9000 check inter 5000 fall 1 rise 2 weight 2
</code></pre><p>整个就是搭建consul集群，平台中的服务会注册到consul集群中，haproxy避免consul-template调consul时出现单点故障consul-template无法工作做的高可用，Consul-template就是能在整个平台的各个系统和应用中使用，查询consul集群来获取平台上各个应用的存活状态和IP。</p>
<p>整套下来实现了两个重点：</p>
<ul>
<li>实现了中心服务注册查询</li>
<li>平台中其他节点的查询服务和配置文件自动更新</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://my.oschina.net/guol/blog/675281" target="_blank" rel="noopener">https://my.oschina.net/guol/blog/675281</a></p>
<p><a href="https://www.consul.io/docs/guides/index.html" target="_blank" rel="noopener">https://www.consul.io/docs/guides/index.html</a></p>
<p><a href="https://www.gitbook.com/book/vincentmi/consul-guide/details" target="_blank" rel="noopener">https://www.gitbook.com/book/vincentmi/consul-guide/details</a></p>
<h2 id="Service-RPM-Download"><a href="#Service-RPM-Download" class="headerlink" title="Service RPM Download"></a>Service RPM Download</h2><h3 id="Consul-0-7-5"><a href="#Consul-0-7-5" class="headerlink" title="Consul 0.7.5"></a>Consul 0.7.5</h3><ul>
<li><a href="http://www.liangxiansen.cn/files/consul-megvii-0.7.5-1.el6.x86_64.rpm">consul-megvii-0.7.5-1.el6.x86_64.rpm</a></li>
<li><a href="http://www.liangxiansen.cn/files/consul-megvii-0.7.5-1.el6.src.rpm">consul-megvii-0.7.5-1.el6.src.rpm</a></li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://www.liangxiansen.cn/files/consul.pdf">点击下载PDF文件</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HAproxy]]></title>
      <url>http://www.liangxiansen.cn/2017/03/06/haproxy/</url>
      <content type="html"><![CDATA[<h2 id="HAproxy"><a href="#HAproxy" class="headerlink" title="HAproxy"></a>HAproxy</h2><h3 id="HAProxy介绍"><a href="#HAProxy介绍" class="headerlink" title="HAProxy介绍"></a>HAProxy介绍</h3><p>HAProxy提供<strong>高可用性</strong>、<strong>负载均衡</strong>以及基于TCP和HTTP应用的代理，<strong>支持虚拟主机</strong>，它是免费、快速并且可靠的一种解决方案。根据官方数据，其最高极限支持10G的并发。 </p>
<p> HAProxy特别适用于那些负载特大的web站点， 这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。</p>
<p>其支持从4层至7层的网络交换，即覆盖所有的TCP协议。就是说，Haproxy 甚至还支持 Mysql 的均衡负载。。</p>
<p>如果说在功能上，能以proxy反向代理方式实现 WEB均衡负载，这样的产品有很多。包括 Nginx，ApacheProxy，lighttpd，Cheroke 等。但要明确一点的，Haproxy 并不是 Http 服务器。以上提到所有带反向代理均衡负载的产品，都清一色是 WEB 服务器。简单说，就是他们能自个儿提供静态(html,jpg,gif..)或动态(php,cgi..)文件的传输以及处理。而Haproxy 仅仅，而且专门是一款的用于均衡负载的应用代理。其自身并不能提供http服务。 </p>
<p>但其配置简单，拥有非常不错的服务器健康检查功能还有专门的系统状态监控页面，当其代理的后端服务器出现故障, HAProxy会自动将该服务器摘除，故障恢复后再自动将该服务器加入。自1.3版本开始还引入了frontend,backend,frontend根据任意HTTP请求头内容做规则匹配，然后把请求定向到相关的backend。 </p>
<a id="more"></a>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>内容交换 : 可以根据请求(request)的任何一部分 来选择一组服务器, 比如请求的 URI , Host头(header) , cookie , 以及其他任何东西. 当然，对那些静态分离的站点来说，对此特性还有更多的需求。 </li>
</ul>
<ul>
<li>全透明代理 : 可以用 客户端IP地址 或者任何其他地址来连接后端服务器. 这个特性仅在Linux 2.4/2.6内核打了cttproxy 补丁后才可以使用. 这个特性也使得为某特殊服务器处理部分流量同时又不修改服务器的地址成为可能。</li>
</ul>
<ul>
<li>基于树的更快的调度器 : 1.2.16以上的版本要求所有的超时都设成同样的值以支持数以万计的全速连接. 这个特性已经移植到1.2.17. </li>
</ul>
<ul>
<li>内核TCP拼接 : 避免了内核到用户然后用户到内核端的数据拷贝, 提高了吞吐量同时又降低了CPU使用率 . Haproxy 1.3支持Linux L7SW 以满足在商用硬件上数Gbps 的吞吐的需求。 </li>
</ul>
<ul>
<li>连接拒绝 : 因为维护一个连接的打开的开销是很低的，有时我们很需要限制攻击蠕虫(attack bots)，也就是说限制它们的连接打开从而限制它们的危害。 这个已经为一个陷于小型DDoS攻击的网站开发了而且已经拯救了很多站点。 </li>
</ul>
<ul>
<li>细微的头部处理 : 使得编写基于header的规则更为简单，同时可以处理URI的某部分。 </li>
</ul>
<ul>
<li>快而可靠的头部处理 : 使用完全RFC2616 兼容的完整性检查对一般的请求全部进行分析和索引仅仅需要不到2ms 的时间。 </li>
</ul>
<ul>
<li>模块化设计 : 允许更多人加入进此项目，调试也非常简单. poller已经分离, 已经使得它们的开发简单了很多. HTTP已经从TCP分离出来了，这样增加新的七层特性变得非常简单. 其他子系统也会很快实现模块化 </li>
</ul>
<ul>
<li>投机I/O 处理 : 在一个套接字就绪前就尝试从它读取数据。poller仅推测哪个可能就绪哪个没有，尝试猜测，并且如果成功，一些开销很大的系统调用就可以省去了。如果失败，就会调用这些系统调用。已知的使用Linux epoll()已经净提升起码10%了。 </li>
</ul>
<ul>
<li>ACLs : 使用任意规则的任意组合作为某动作的执行条件。</li>
</ul>
<ul>
<li>TCP 协议检查 : 结合ACL来对请求的任意部分进行检查，然后再进行转发。这就可以执行协议验证而不是盲目的进行转发。比如说允许SSL但拒绝SSH。</li>
</ul>
<ul>
<li>更多的负载均衡算法 : 现在，动态加权轮循(Dynamic Round Robin)，加权源地址哈希(Weighted Source Hash)，加权URL哈希和加权参数哈希(Weighted Parameter Hash)已经实现。其他算法比如Weighted Measured Response Time也很快会实现。 </li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载haproxy源码，目前国内无法访问haproxy官网（<a href="http://www.haproxy.org），**Fuck" target="_blank" rel="noopener">www.haproxy.org），**Fuck</a> GFW**。 可以通过直接访问<a href="http://www.haproxy.org/download/1.7/src/地址，选择相应的版本下载。或者使用wget命令" target="_blank" rel="noopener">http://www.haproxy.org/download/1.7/src/地址，选择相应的版本下载。或者使用wget命令</a></p>
<pre><code> wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.3.tar.gz
</code></pre><p>下载，下载完成后，将其解压。</p>
<pre><code>cd haproxy-1.7.3
uname -a
make TARGET=linux26 PREFIX=/usr/local/haproxy
make install PREFIX=/usr/local/haproxy
</code></pre><p>linux26,26表示linux系统的主次版本号。 执行上面的命令，输出done就正确安装完成。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>修改配置</li>
</ul>
<p>配置文件可以参考源码里面examples下面的haproxy.cfg文件，haproxy里的配置参数可到<a href="http://www.cbonte.github.io/haproxy-dconv/index.html" target="_blank" rel="noopener">haproxy-dconv</a>查看。</p>
<pre><code>mkdir /usr/local/haproxy/logs
vim /etc/haproxy.cfg
</code></pre><ul>
<li>在/etc/syslog.conf文件中添加，如下：</li>
</ul>
<pre><code># Haproxy
local5.*                                                /usr/local/haproxy/logs/haproxy.log
</code></pre><ul>
<li>如果系统需要设置接收外来日志，修改/etc/sysconfig/rsyslog文件：</li>
</ul>
<pre><code>SYSLOGD_OPTIONS=&quot;-r -m 0 -c 2&quot;
</code></pre><ul>
<li>开启rsyslog的日志记录功能</li>
</ul>
<p>vi /etc/rsyslog.conf 找到下面两行并去掉前面的#号</p>
<pre><code>#$ModLoad imudp
#$UDPServerRun 514
</code></pre><ul>
<li>重启rsyslog生效</li>
</ul>
<pre><code>/etc/init.d/rsyslog reload
</code></pre><ul>
<li>配置文件解释</li>
</ul>
<pre><code>####################全局配置信息########################
#######参数是进程级的，通常和操作系统（OS）相关#########
global
       maxconn 20480                   #默认最大连接数
       log 127.0.0.1 local3            #[err warning info debug]
       chroot /var/haproxy             #chroot运行的路径
       uid 99                          #所属运行的用户uid
       gid 99                          #所属运行的用户组
       daemon                          #以后台形式运行haproxy
       nbproc 1                        #进程数量(可以设置多个进程提高性能)
       pidfile /var/run/haproxy.pid    #haproxy的pid存放路径,启动进程的用户必须有权限访问此文件
       ulimit-n 65535                  #ulimit的数量限制

       #####################默认的全局设置######################
       ##这些参数可以被利用配置到frontend，backend，listen组件##
defaults
       log global
       mode http                       #所处理的类别 (#7层 http;4层tcp  )
       maxconn 20480                   #最大连接数
       option httplog                  #日志类别http日志格式
       option httpclose                #每次请求完毕后主动关闭http通道
       option dontlognull              #不记录健康检查的日志信息
       option forwardfor               #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip
       option redispatch               #serverId对应的服务器挂掉后,强制定向到其他健康的服务器
       option abortonclose             #当服务器负载很高的时候，自动结束掉当前队列处理比较久的连接
       stats refresh 30                #统计页面刷新间隔
       retries 3                       #3次连接失败就认为服务不可用，也可以通过后面设置
       balance roundrobin              #默认的负载均衡的方式,轮询方式
      #balance source                  #默认的负载均衡的方式,类似Nginx的ip_hash
      #balance leastconn               #默认的负载均衡的方式,最小连接
       contimeout 5000                 #连接超时
       clitimeout 50000                #客户端超时
       srvtimeout 50000                #服务器超时
       timeout check 2000              #心跳检测超时

       ####################监控页面的设置#######################
listen admin_status                    #Frontend和Backend的组合体,监控组的名称，按需自定义名称
        bind 0.0.0.0:65532             #监听端口
        mode http                      #http的7层模式
        log 127.0.0.1 local3 err       #错误日志记录
        stats refresh 5s               #每隔5秒自动刷新监控页面
        stats uri /admin?stats         #监控页面的url
        stats realm itnihao itnihao   #监控页面的提示信息
        stats auth admin:admin         #监控页面的用户和密码admin,可以设置多个用户名
        stats auth admin1:admin1       #监控页面的用户和密码admin1
        stats hide-version             #隐藏统计页面上的HAproxy版本信息
        stats admin if TRUE            #手工启用/禁用,后端服务器(haproxy-1.4.9以后版本)

       errorfile 403 /etc/haproxy/errorfiles/403.http
       errorfile 500 /etc/haproxy/errorfiles/500.http
       errorfile 502 /etc/haproxy/errorfiles/502.http
       errorfile 503 /etc/haproxy/errorfiles/503.http
       errorfile 504 /etc/haproxy/errorfiles/504.http

       #################HAProxy的日志记录内容设置###################
       capture request  header host           len 40
       capture request  header Content-Length len 10
       capture request  header Referer        len 200
       capture response header Server         len 40
       capture response header Content-Length len 10
       capture response header Cache-Control  len 8

       #######################网站监测listen配置#####################
       ###########此用法主要是监控haproxy后端服务器的监控状态############
listen site_status
       bind 0.0.0.0:1081                    #监听端口
       mode http                            #http的7层模式
       log 127.0.0.1 local3 err             #[err warning info debug]
       monitor-uri /site_status             #网站健康检测URL，用来检测HAProxy管理的网站是否可以用，正常返回200，不正常返回503
       acl site_dead nbsrv(server_web) lt 2 #定义网站down时的策略当挂在负载均衡上的指定backend的中有效机器数小于1台时返回true
       acl site_dead nbsrv(server_blog) lt 2
       acl site_dead nbsrv(server_bbs)  lt 2
       monitor fail if site_dead            #当满足策略的时候返回503，网上文档说的是500，实际测试为503
       monitor-net 192.168.16.2/32          #来自192.168.16.2的日志信息不会被记录和转发
       monitor-net 192.168.16.3/32

       ########frontend配置############
       #####注意，frontend配置里面可以定义多个acl进行匹配操作########
frontend http_80_in
       bind 0.0.0.0:80      #监听端口，即haproxy提供web服务的端口，和lvs的vip端口类似
       mode http            #http的7层模式
       log global           #应用全局的日志配置
       option httplog       #启用http的log
       option httpclose     #每次请求完毕后主动关闭http通道，HA-Proxy不支持keep-alive模式
       option forwardfor    #如果后端服务器需要获得客户端的真实IP需要配置次参数，将可以从Http Header中获得客户端IP
       ########acl策略配置#############
       acl itnihao_web hdr_reg(host) -i ^(www.itnihao.cn|ww1.itnihao.cn)$
       #如果请求的域名满足正则表达式中的2个域名返回true -i是忽略大小写
       acl itnihao_blog hdr_dom(host) -i blog.itnihao.cn
       #如果请求的域名满足www.itnihao.cn返回true -i是忽略大小写
       #acl itnihao    hdr(host) -i itnihao.cn
       #如果请求的域名满足itnihao.cn返回true -i是忽略大小写
       #acl file_req url_sub -i  killall=
       #在请求url中包含killall=，则此控制策略返回true,否则为false
       #acl dir_req url_dir -i allow
       #在请求url中存在allow作为部分地址路径，则此控制策略返回true,否则返回false
       #acl missing_cl hdr_cnt(Content-length) eq 0
       #当请求的header中Content-length等于0时返回true

      ########acl策略匹配相应#############
       #block if missing_cl
       #当请求中header中Content-length等于0阻止请求返回403
       #block if !file_req || dir_req
       #block表示阻止请求，返回403错误，当前表示如果不满足策略file_req，或者满足策略dir_req，则阻止请求
       use_backend  server_web  if itnihao_web
       #当满足itnihao_web的策略时使用server_web的backend
       use_backend  server_blog if itnihao_blog
       #当满足itnihao_blog的策略时使用server_blog的backend
       #redirect prefix http://blog.itniaho.cn code 301 if itnihao
       #当访问itnihao.cn的时候，用http的301挑转到http://192.168.16.3
       default_backend server_bbs
       #以上都不满足的时候使用默认server_bbs的backend


       ##########backend的设置##############
       #下面我将设置三组服务器 server_web，server_blog，server_bbs
###########backend server_web#################
backend server_web
       mode http            #http的7层模式
       balance roundrobin   #负载均衡的方式，roundrobin平均方式
       cookie SERVERID      #允许插入serverid到cookie中，serverid后面可以定义
       option httpchk GET /index.html #心跳检测的文件
       server web1 192.168.16.2:80 cookie web1 check inter 1500 rise 3 fall 3 weight 1
       #服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，
       #fall 3是3次失败认为服务器不可用，weight代表权重
       server web2 192.168.16.3:80 cookie web2 check inter 1500 rise 3 fall 3 weight 2
       #服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，
       #fall 3是3次失败认为服务器不可用，weight代表权重

#############backend server_blog##############
backend server_blog
       mode http            #http的7层模式
       balance roundrobin   #负载均衡的方式，roundrobin平均方式

       cookie SERVERID      #允许插入serverid到cookie中，serverid后面可以定义
       option httpchk GET /index.html #心跳检测的文件
       server blog1 192.168.16.2:80 cookie blog1 check inter 1500 rise 3 fall 3 weight 1
       #服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
       server blog2 192.168.16.3:80 cookie blog2 check inter 1500 rise 3 fall 3 weight 2
        #服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重

#############backend server_bbs##############

backend server_bbs
       mode http            #http的7层模式
       balance roundrobin   #负载均衡的方式，roundrobin平均方式
       cookie SERVERID      #允许插入serverid到cookie中，serverid后面可以定义
       option httpchk GET /index.html #心跳检测的文件
       server bbs1 192.168.16.2:80 cookie bbs1 check inter 1500 rise 3 fall 3 weight 1
       #服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
       server bbs2 192.168.16.3:80 cookie bbs2 check inter 1500 rise 3 fall 3 weight 2
        #服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
</code></pre><ul>
<li>下面是我的配置</li>
</ul>
<pre><code>global
        maxconn         20480
        ulimit-n        65535
        log             127.0.0.1 local5
        uid             200
        gid             200
        chroot          /usr/local/haproxy
        nbproc          1
        daemon
        pidfile         /usr/local/haproxy/logs/haproxy.pid

defaults
        log             global
        mode            http
        option          httplog
        option          dontlognull
        option          forwardfor
        option          abortonclose
        retries         3
        maxconn         3000
        stats           enable
        stats           hide-version
        stats   uri     /admin
        stats   auth    admin:admin
        stats   refresh 10s
        balance         roundrobin
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms
        timeout check 2000ms

listen web_haproxy
        bind 0.0.0.0:8080
        mode http
        log     127.0.0.1 local5 err
        stats   refresh 5s
        stats   uri /admin
        stats   realm liang lian
        stats   auth admin:admin
        stats   hide-version
        stats   admin if TRUE

frontend consul
        bind    0.0.0.0:8500
        mode    http
        log     global
        default_backend consul-cluster

backend consul-cluster
        mode http
        server s1 10.201.102.198:8500 check inter 5000 fall 1 rise 2 weight 2
        server s2 10.201.102.199:8500 check inter 5000 fall 1 rise 2 weight 2
        server s3 10.201.102.200:8500 check inter 5000 fall 1 rise 2 weight 2
</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/usr/local/haproxy/sbin/haproxy -f /etc/haproxy.cfg
</code></pre><ul>
<li>启动脚本</li>
</ul>
<pre><code>cp haproxy-1.7.3/examples/haproxy.init /etc/init.d/haproxy
chmod +x /etc/init.d/haproxy
</code></pre><h3 id="web-Haproxy"><a href="#web-Haproxy" class="headerlink" title="web-Haproxy"></a>web-Haproxy</h3><p>我Haproxy服务器IP地址是10.201.102.185</p>
<p><a href="http://10.201.102.185:8080/admin" target="_blank" rel="noopener">http://10.201.102.185:8080/admin</a></p>
<p><img src="http://www.liangxiansen.cn/images/haproxy/web-haproxy.png" alt="web-haproxy"></p>
<h3 id="Bakend-server"><a href="#Bakend-server" class="headerlink" title="Bakend_server"></a>Bakend_server</h3><p><a href="http://10.201.102.185:8500" target="_blank" rel="noopener">http://10.201.102.185:8500</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python函数默认参数的一个坑]]></title>
      <url>http://www.liangxiansen.cn/2017/01/13/python%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%9D%91/</url>
      <content type="html"><![CDATA[<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre><code class="python">def func(a,b=[]):
    b.append(a)
    print(b)

func(1)
func(2)
func(3)
</code></pre>
<p>有个考python特性的面试题，func（3）的时候，b 这个list是啥。</p>
<a id="more"></a>
<p>输出结果：</p>
<pre><code>[1]
[1, 2]
[1, 2, 3]
</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre><code class="python">def func(a,b=1):
    b += a
    print(b)

func(1)
func(2)
func(3)
</code></pre>
<p>输出结果：</p>
<pre><code>2
3
4
</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里引用一段<code>栈</code>和<code>堆</code>的概率</p>
<blockquote>
<ul>
<li>栈（操作系统）：<br>由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆（操作系统）：<br>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</li>
</ul>
</blockquote>
<p>根据上面的概率但是正常输出应该是<code>[3]</code>呀，很多其他语言都是这样。这里很明显<code>‘b’</code>没有被回收，<code>‘a’</code>是正常的回收了。根据第二个例子，发现不是一般情况，“数组”和普通数值型不一样的效果。据此分析：</p>
<h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><pre><code>def func(a b=[])   ---&gt;  代码进行到这里定义一个函数（1）

b = []   ---&gt; 设置默认参数，在堆中创建一个b = [] （2）
              创建一个&quot;栈&quot;，在栈中创建 a, b = (2)的地址指针位置, （3）
func(1)   ---&gt;  执行函数func(1),修改栈中a = 1
b.append(a)---&gt; 调用栈中的b 指针（引用传递），将a到列表--&gt;b
print(b)
                函数func(1)执行完，栈系统自动回收，b指针消失。但是b的值已经修改。
</code></pre><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><pre><code>def func(a b=1)   ---&gt;  代码进行到这里定义一个函数（1）
                         创建一个&quot;栈&quot;，在栈中创建 a, b = 1, （2）
func(1)   ---&gt;  执行函数func(1),修改栈中a = 1，
b += a      ---&gt;   修改过栈中 b = 1 + a
print(b)                       
                函数func(1)执行完，栈系统自动回收，a,b消失。
</code></pre><p>Python的数组类型是用的引用传递，普通数字是值传递，这就是python和其他语言处理默认参数方式不一样吧，其他语言再执行函数之前，初始化一个栈，所有的参数都重新初始化到新的栈中。</p>
<p>如上就是我的分析，但是本人技术有限怕理解不对，希望大神不吝赐教！记下来只是提醒自己python有这样一个<code>特性</code>在这，需要注意。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用supervisor管理python脚本守护进程踩的一个坑]]></title>
      <url>http://www.liangxiansen.cn/2017/01/06/supervisor-shell/</url>
      <content type="html"><![CDATA[<h2 id="使用supervisor管理python脚本守护进程踩的一个坑"><a href="#使用supervisor管理python脚本守护进程踩的一个坑" class="headerlink" title="使用supervisor管理python脚本守护进程踩的一个坑"></a>使用supervisor管理python脚本守护进程踩的一个坑</h2><h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><pre><code class="shell">#!/bin/bash

export LD_LIBRARY_PATH=/root/FRI_FACEID/instantclient_12_1
export ORACLE_HOME=/root/FRI_FACEID/instantclient_12_1

source ../env/bin/activate
python -u ./new_whitelist_mb.py
</code></pre>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="http://www.liangxiansen.cn/images/supervisor/shell.jpg" alt="shell"></p>
<a id="more"></a>
<blockquote>
<p>都是通过最后一个进程启动的，但是这个进程结束后，他所运行的python脚本创建的进程并没有结束，supervisor管理的他会帮你启动脚本并管理这个程序，supervisorctl start 启动这个程序的时候会创建一个进程并记录下这个进程的PID，当执行supervisorctl stop 然后再kill 了这个PID号的进程，但是，由这个脚本所创建的子进程并没办法管理，所以才出现了如上图的情况。</p>
</blockquote>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre><code class="shell">#!/bin/bash

export LD_LIBRARY_PATH=/root/FRI_FACEID/instantclient_12_1
export ORACLE_HOME=/root/FRI_FACEID/instantclient_12_1

source ../env/bin/activate
exec python -u ./new_whitelist_mb.py
</code></pre>
<blockquote>
<p>Linux系统exec函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。</p>
</blockquote>
<p>这样supervisor在管理stop程序的时候就能够通过之前记录的PID来kill掉现在的进程。</p>
<blockquote>
<p>Note: 在脚本中使用exec，exec会替换掉原进程，而且执行完会退出，不会执行下面的，类似于python的retrun，所以使用的时候下面不要再写内容。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随手笔记]]></title>
      <url>http://www.liangxiansen.cn/2016/10/08/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>windows 默认结束符<code>\n\r</code> 类unix下是<code>\r</code> 所以需要转换,<br>tr -d ‘\r’ &lt; testsource.sh &gt; ./testsource.shbak</p>
<p>source 需要有<code>/</code>不然它找不到它得话就从系统环境变量PATH中找,</p>
<a id="more"></a>
<blockquote>
<p>关于回车与换行 </p>
<p>很久以前，老式的电传打字机使用两个字符来另起新行。一个字符把滑动架移回首位 (称为回车,ASCII码为0D)，另一个字符把纸上移一行 (称为换行,ASCII码为0A)。当计算机问世以后，存储器曾经非常昂贵。有些人就认定没必要用两个字符来表示行尾。UNIX 开发者决定他们可以用一个字符来表示行尾，Linux沿袭Unix，也是。Apple 开发者规定了用.开发 MS-DOS以及Windows 的那些家伙则决定沿用老式的. </p>
<p>三种行尾格式如下: </p>
<p>unix :  <code>\n</code> </p>
<p>dos :  <code>\r\n</code> </p>
<p>mac :  <code>\r</code> </p>
<p>这意味着，如果你试图把一个文件从一种系统移到另一种系统，那么你就有换行符方面的麻烦。 </p>
<p>因为MS-DOS及Windows是回车＋换行来表示换行，因此在Linux下用Vim查看在Windows下写的代码，行尾后“^M”符号。</p>
<p>在Vim中解决这个问题，很简单，在Vim中利用替换功能就可以将“^M”都删掉，键入如下替换命令行： </p>
<p>:%  s/^M//g </p>
<p>注意： </p>
<p>上述命令行中的“^M”符，不是“^”再加上“M”，而是由“Ctrl+v”、“Ctrl+M”键生成的，或者Ctrl+v，再按回车。 </p>
<p>或者使用这个命令： </p>
<p>:%  s/\r//g</p>
</blockquote>
<p>是用VI的命令：<br>使用vi打开文本文件 </p>
<pre><code>vi dos.txt 
命令模式下输入 

:set fileformat=unix 
:w 
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS 基础]]></title>
      <url>http://www.liangxiansen.cn/2016/09/29/css/</url>
      <content type="html"><![CDATA[<h2 id="CSS-介绍"><a href="#CSS-介绍" class="headerlink" title="CSS 介绍"></a>CSS 介绍</h2><p>css是英文<code>Cascading Style Sheets</code>的缩写,称为层叠样式表，用于对页面进行美化，CSS的可以使页面更加的美观。基本上所有的html页面都或多或少的使用css。</p>
<p>存在方式有三种：<code>标签嵌入</code>、<code>页面嵌入</code>和<code>外部样式文件嵌入</code></p>
<a id="more"></a>
<h3 id="标签嵌入"><a href="#标签嵌入" class="headerlink" title="标签嵌入"></a>标签嵌入</h3><p>将要赋予某个标签样式的css代码写在标签里面.style属性定义标签的样式,所有的样式都写在style属性里面.</p>
<pre><code class="html">&lt;div style=&quot;background-color: red;border: 1px solid green;&quot;&gt;测试&lt;/div&gt;
</code></pre>
<h3 id="页面嵌入"><a href="#页面嵌入" class="headerlink" title="页面嵌入"></a>页面嵌入</h3><p>统一写在页面的head部分,用style标签包裹,这样是不是不会那么散乱了呢? 但是问题就来了,我写这这,我怎么应用到我想要的那个标签或者元素上呢?</p>
<p>在后面一小节就开始讲<code>选择器</code>,通过选择器来找到那个它(你心所想的那个标签).</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;

    &lt;!--在head里面统一写css样式,页面嵌入得css样式都包裹在style标签里面--&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        div{
            background-color: red;
            border: 1px solid green;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;测试&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="外部样式文件嵌入"><a href="#外部样式文件嵌入" class="headerlink" title="外部样式文件嵌入"></a>外部样式文件嵌入</h3><p>当页面内容写的多了,样式也随之增多,你回发现在head上一大长串,到最后如果要修改单独某个样式其实也不好找,那么我们可不可以将样式像网站目录那样分门别类的文件呢?</p>
<p>只要创建一个<code>.css</code>的文件,然后将css样式写在里面就可以了.下面是应用方法:<br><code>test.css(css样式文件):</code></p>
<pre><code>div{
    background-color: red;
    border: 1px solid green;
}
</code></pre><p><code>test.html(html页面):</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;!--外部样式文件引入--&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;测试&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p><strong>优先级：</strong> 标签&gt;页面&gt;外部，这个仅限同样的样式冲突是才有用,如果真遇到冲突了,你一定要使用某个样式,你可以在那个冲突的样式后面加上<code>!important</code></p>
</blockquote>
<pre><code>.hide{
    display: none!important;
}
</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>有了选择器,我们可以通过各种各样得方式找到页面上的某个元素并给它加上样式,选择器的定义方法如下:</p>
<pre><code>选择器名称{

}
</code></pre><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>定义标签选择器的时候,这个选择器的名称以你要定义的标签的名称命名,那么所有的这个标签都会加上这个样式</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        /*定义标签选择器,这个标签选择器名称要和标签的名称一样,在&quot;{}&quot;里面写样式代码,会让所有&quot;div&quot;标签应用上我这里写的样式*/
        div{
            background-color: red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--这里有div标签,那么他就会自动应用上上面定义的css样式--&gt;
    &lt;div&gt;测试&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>每一个标签上都还有或多或少的属性,有的是内部语法用来定义这个标签展示效果的,有的是程序员自己加的,为了帮助实现功能的.</p>
<p>那么属性是什么呢? 摘一段代码:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/attr_selector.png" alt="标签属性"></p>
<blockquote>
<p>图中圈出来的,用等号连接起来,前面是属性名,后面是属性的值,这就是这个标签的属性了; 红色的是内置语法规定的,蓝色的是我自己写的一个.任何开发者都可以在标签中新增自己的属性,只要按照那种格式写就可以.</p>
</blockquote>
<p>属性选择器的用法:<br>属性用中括号包裹,等号前面是属性名,后面是value,添加多个属性条件直接紧接着在后面写就行了,属性选择和其他条件之间没有空格.</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        /*找到input标签,并且type属性是&quot;text&quot;的,lalbel属性是&quot;姓名&quot;的给它加上背景颜色*/
        input[type=&#39;text&#39;][label=&#39;姓名&#39;]{
            background-color: yellow;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;http://192.168.11.88:8000/index/&quot; method=&quot;post&quot;  enctype=&quot;multipart/form-data&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;user&quot; label=&quot;姓名&quot;/&gt;
        &lt;input type=&quot;password&quot; name=&quot;pwd&quot; label=&quot;密码&quot;/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><p>为具有某个唯一ID的标签设置样式：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        /*定义ID选择器,这个选择器名称前面加&quot;#&quot;号,表示这是一个id选择器,后面跟id值,下面会让所有id=&quot;test&quot;的标签并应用上我这里写的样式*/
        #test{
            background-color: red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--这里给div标签设置一个id,id是唯一的,不可以重复,为了能够证明这个标签的唯一作用,方便找到它.是的,id也是这个标签的属性--&gt;
    &lt;div id=&quot;test&quot;&gt;测试&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>类选择器,定义好后,想用他随时可以拿来用,可以使用很多来实现很漂亮的样式,很灵活方便</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        /*定义类选择器,这个选择器名称前面加&quot;.&quot;,表示这是一个类选择器,需要使用这个样式的标签只需要class=&quot;test&quot;在他的class属性里面添加上这个类选择器名称,可以应用多个*/
        .backgroud{
            background-color: red;
        }
        .font_size{
            font-size: 30px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--这里给div标签设置一个class属性,在class属性里面加上上面定义的类属选择器名--&gt;
    &lt;div class=&quot;backgroud font_size&quot;&gt;测试&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>组合选择器就是我们之前所学的所有选择器组合起来使用,选择器之间用空格隔开</p>
<p><strong>递归组合</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        /*第一个条件满足之后,就进入到里面然后在里面找第二个条件,如果没有满足的就再进入他的每一个子标签里面找,一级一级往下找,只要有满足这个递归关系就会应用这个样式*/
        .body .bd-head{
            background-color: blue;
            font-size: 24px;
        }
        .body .bd-content{
            background-color: greenyellow;
            font-size: 12px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;body&quot;&gt;
        &lt;div class=&quot;bd-head&quot;&gt;这是标题&lt;/div&gt;
        &lt;div class=&quot;bd-content&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;cc1&lt;/li&gt;
                &lt;li&gt;cc2&lt;/li&gt;
                &lt;li&gt;cc3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<p><strong>并联组合</strong></p>
<p>用逗号将选择条件连接起来,最后哪个满足了谁都会应用上样式,都满足则都应用上.</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        /*第一个查找条件是一个递归组合查找,第二个也是递归组合查找,用逗号连接,最后这两个条件不管谁满足了谁就会应用这个样式*/
        .body .bd-head,.body .bd-content{
            background-color: yellow;
            font-size: 24px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;body&quot;&gt;
        &lt;div class=&quot;bd-head&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;head1&lt;/li&gt;
                &lt;li&gt;head2&lt;/li&gt;
                &lt;li&gt;head3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div class=&quot;bd-content&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;cc1&lt;/li&gt;
                &lt;li&gt;cc2&lt;/li&gt;
                &lt;li&gt;cc3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;!--这个是不满足两个条件的,所以没有样式--&gt;
        &lt;div class=&quot;bd-footer&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;footer1&lt;/li&gt;
                &lt;li&gt;footer2&lt;/li&gt;
                &lt;li&gt;footer3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>CSS 伪类用于向某些选择器添加特殊的效果。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><pre><code>selector : pseudo-class {property: value}
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:active</td>
<td style="text-align:left">向被激活的元素添加样式。</td>
</tr>
<tr>
<td style="text-align:left">:focus</td>
<td style="text-align:left">向拥有键盘输入焦点的元素添加样式。</td>
</tr>
<tr>
<td style="text-align:left">:hover</td>
<td style="text-align:left">当鼠标悬浮在元素上方时，向元素添加样式。</td>
</tr>
<tr>
<td style="text-align:left">:link</td>
<td style="text-align:left">向未被访问的链接添加样式。</td>
</tr>
<tr>
<td style="text-align:left">:visited</td>
<td style="text-align:left">向已被访问的链接添加样式。</td>
</tr>
<tr>
<td style="text-align:left">:first-child</td>
<td style="text-align:left">向元素的第一个子元素添加样式。</td>
</tr>
<tr>
<td style="text-align:left">:lang</td>
<td style="text-align:left">向带有指定 lang 属性的元素添加样式。</td>
</tr>
</tbody>
</table>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre><code class="html">&lt;html&gt;
&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
a:link {color: #FF0000}
a:visited {color: #00FF00}
a:hover {color: #FF00FF}
a:active {color: #0000FF}
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;&lt;b&gt;&lt;a href=&quot;/index.html&quot; target=&quot;_blank&quot;&gt;这是一个链接。&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后，这样才能生效！&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:active 必须位于 a:hover 之后，这样才能生效！&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">a:link {color: #FF0000}        /* 未访问的链接 */
a:visited {color: #00FF00}    /* 已访问的链接 */
a:hover {color: #FF00FF}    /* 鼠标移动到链接上 */
a:active {color: #0000FF}    /* 选定的链接 */
</code></pre>
<p>:first-child</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
p:first-child {
  color: red;
  } 
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;some text&lt;/p&gt;
&lt;p&gt;some text&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>:lang</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;

&lt;style type=&quot;text/css&quot;&gt;
q:lang(no)
   {
   quotes: &quot;~&quot; &quot;~&quot;
   }
&lt;/style&gt;

&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;文字&lt;q lang=&quot;no&quot;&gt;段落中的引用的文字&lt;/q&gt;文字&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre>
<h2 id="css美化网页"><a href="#css美化网页" class="headerlink" title="css美化网页"></a>css美化网页</h2><p>   学习css实战前,首先先学习两个理论知识,知道<code>css</code>是应用在<code>html</code>标签上的,那么css影响着html的显示效果,同时html也影响着css的效果,不同的标签加上同一个css样式不一定是同样的一个展示效果.html标签分别分为:<code>内联标签(行内标签)</code>, <code>块级标签</code>这两种.</p>
<blockquote>
<ul>
<li>块级标签: 占整行, 可以设置宽度高度</li>
<li>内联标签: 内容有多少占多少, 不能设置宽和高</li>
</ul>
</blockquote>
<p>当然这两种形式也不是绝对的,后面会讲如何让这两种标签互相转换.<br>最典型的两个案例就是div标签(块级标签)和span标签(内联标签),现在很流行的页面布局方式就是<code>div + css</code></p>
<h3 id="backgroud-color"><a href="#backgroud-color" class="headerlink" title="backgroud-color"></a>backgroud-color</h3><p>设置背景颜色,被标签添加背景颜色.</p>
<pre><code class="html">&lt;div style=&quot;background-color: yellow&quot;&gt;Hello World&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/background-color.png" alt="背景颜色"></p>
<pre><code class="html">&lt;span style=&quot;background-color: yellow;&quot;&gt;Hello World&lt;/span&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/span.png" alt="背景颜色"></p>
<h3 id="height-amp-width"><a href="#height-amp-width" class="headerlink" title="height &amp; width"></a>height &amp; width</h3><p>设置宽和高</p>
<pre><code class="html">&lt;div style=&quot;background-color: yellow;width: 200px; height: 200px&quot;&gt;Hello World&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/width.png" alt="高&amp;宽"></p>
<h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><p>添加背景图片,如果图片尺寸不够标签尺寸的话,背景图片默认会平铺,</p>
<pre><code class="html">&lt;div style=&quot;background-image: url(&#39;header.png&#39;);width: 500px; height: 700px&quot;&gt;Hello World&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/backgrund-image.png" alt="背景图片"></p>
<p>设置为不平铺,只需要加上”background-repeat: no-repeat;”</p>
<pre><code class="html">&lt;div style=&quot;background-image: url(&#39;header.png&#39;); background-repeat: no-repeat; width: 500px; height: 700px&quot;&gt;Hello World&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/backgrund-image2.png" alt="背景图片"></p>
<h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h3><p>应用场景，在实际的生产环境中咱们在网页上看到的小图片不是一个一个的零散的小图片的，咱们只是看到了大图片的一部分。比如一个大图片，我只让他显示一部分并不全部显示怎么做？</p>
<p>可以这么想：<br>有一个窗口，你在窗口的一边，只能通过窗口来看外面，你不能动，我们可以通过移动这个窗口来让你看到不同的场景，当然你看到的大小和窗口的大小有关！</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        .chuangkou{
            /*定义一个图片*/
            background-image: url(&#39;logo.png&#39;);
            /*定义一个窗口,指定长和宽*/
            height: 20px;
            width: 20px;
            background-repeat: no-repeat;
            background-position: 0px -55px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;chuangkou&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>原图:<br><img src="http://www.liangxiansen.cn/images/前端/backgrund-image.png" alt="背景图片"></p>
<p>实际效果:<br><img src="http://www.liangxiansen.cn/images/前端/backgrund-image2.png" alt="背景图片"></p>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>设置边框</p>
<pre><code class="html">&lt;!--border:有3个参数：线的粗细、线的样式（实线、点、虚线等）、线的颜色--&gt;
&lt;!--第一种：线的粗细为1像素，实线、红色--&gt;
&lt;div style=&quot;border:1px solid red;height:10px&quot; &gt;&lt;/div&gt;
&lt;!--第二种：线的粗细为1像素，点、蓝色--&gt;
&lt;div style=&quot;border:1px dotted blue;height:10px&quot; &gt;&lt;/div&gt;
&lt;!--第三种：线的粗细为1像素、虚线、紫色--&gt;
&lt;div style=&quot;border:1px dashed purple;height:10px&quot; &gt;&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/border.png" alt="边框"></p>
<p>边框可以单独的设置一边的边框、上、下、左、右</p>
<pre><code class="html">&lt;!--在右边设置边框，3px、实线、黑色--&gt;
&lt;span style=&quot;border-right: 3px solid black&quot;&gt;Hello World&lt;/span&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/border2.png" alt="边框"></p>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>可以对内联标签和块标签进行转换,还能隐藏标签元素.</p>
<pre><code class="html">&lt;!--display: none将隐藏标签--&gt;
&lt;div style=&quot;display: none;&quot;&gt;我被隐藏了&lt;/div&gt;
&lt;!--display: inline会将块级别标签调为内联标签--&gt;
&lt;div style=&quot;background-color:red;display:inline&quot;&gt;我变内联了&lt;/div&gt;
&lt;!--display: block会将内联标签调为块级别标签--&gt;
&lt;span style=&quot;background-color:red;display:block&quot;&gt;我变块级了&lt;/span&gt;
&lt;!--display: inline-block既可块级又可内联,就是在内联标签的基础上可以设置宽和高--&gt;
&lt;span style=&quot;background-color:red;display:inline-block;height: 100px;width: 300px&quot;&gt;我既可块级又可内联&lt;/span&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/display.png" alt="Display"></p>
<h3 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h3><p>鼠标停浮样式</p>
<pre><code class="html">&lt;div style=&quot;cursor:pointer&quot;&gt;停放在这里显示小手(pointer)&lt;/div&gt;
&lt;div style=&quot;cursor:help&quot;&gt;停放在这里显示问号(help)&lt;/div&gt;
&lt;div style=&quot;cursor:wait&quot;&gt;停放在这里显示加载(wait)&lt;/div&gt;
&lt;div style=&quot;cursor:move&quot;&gt;停放在这里显示移动(move)&lt;/div&gt;
&lt;div style=&quot;cursor:crosshair&quot;&gt;停放在这里显示定位(crosshair)&lt;/div&gt;
</code></pre>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>浮动,向一个方向靠齐,多用于布局</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div style=&quot;width: 500px;border: 1px solid red;&quot;&gt;
        &lt;!--浮动对齐--&gt;
        &lt;!--这里长和宽，可以用百分比或者直接指定像素来指定--&gt;
        &lt;div style=&quot;width: 20%;background-color: aqua;float: left;&quot;&gt;f&lt;/div&gt;
        &lt;div style=&quot;width: 30%;background-color: beige;float: right;&quot;&gt;a&lt;/div&gt;
        &lt;div style=&quot;width: 30%;background-color: beige;float: right;&quot;&gt;a&lt;/div&gt;
        &lt;!--解除浮动,把浮动拉取下来固定--&gt;
        &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;
        最后如果不加上这条,他就会跳出父标签,
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/float.png" alt="浮动"></p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>内边距</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        .content{
            /*设置内边距*/
            padding: 100px;
            height: 500px;
            width: 500px;
            background-color: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;div class=&quot;test&quot; style=&quot;font-size: 48px; color: red&quot;&gt;TEST&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/padding.png" alt="内边距"></p>
<h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>外边距</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        .content{
            height: 500px;
            width: 500px;
            background-color: blue;
        }
        .font{
            color: red;
            font-size: 48px;
            display: inline-block;
            margin-left: 200px;
            margin-top: 200px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;shell&quot;&gt;
        &lt;div class=&quot;content&quot;&gt;
            &lt;div class=&quot;font&quot;&gt;TEST&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/margin.png" alt="外边距"></p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>定位,position的四个属性值：static, fixed, relative, absolute<br>每个模式都能使用top, bottom, left, right, 这个四个属性来指定位置</p>
<p><strong>1、absolute</strong><br>单独使用会根据父标签进行定位</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        .content{
            height: 500px;
            width: 500px;
            background-color: blue;
        }
        .font{
            color: red;
            font-size: 48px;
            display: inline-block;
            position: absolute;
            top: 200px;
            left: 200px;

        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;shell&quot;&gt;
        &lt;div class=&quot;content&quot;&gt;
            &lt;div class=&quot;font&quot;&gt;TEST&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/absolute.png" alt="相对定位"></p>
<p><strong>2、relative</strong></p>
<p>绝对定位,relative单独使用没有意义,需要和absolute配合使用,他就相当于把absolute之前定位转移到自己身上,那么absolute就不再是根据父标签定位了,而是根据relative的位置来确定自己的位置.</p>
<blockquote>
<p>Note: 如果absolute标签的父标签里面有多个relative的标签,那么它向上查找,找到第一个relative就不会再找了.</p>
</blockquote>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
    &lt;style&gt;
        .shell{
            position: relative;
        }
        .content{
            height: 500px;
            width: 500px;
            background-color: blue;
        }
        .font{
            color: red;
            font-size: 48px;
            display: inline-block;
            position: absolute;
            right: 0px;
            top: 0px;

        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;shell&quot;&gt;
        &lt;div class=&quot;content&quot;&gt;
            &lt;div class=&quot;font&quot;&gt;TEST&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/relative.png" alt="绝对定位"></p>
<p><strong>3、fixed</strong></p>
<p>fixed是特殊的absolute，即fixed总是以body为定位对象的，按照浏览器的窗口进行定位。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div style=&quot;height: 2000px;background-color: #ddd;&quot;&gt;&lt;/div&gt;
    &lt;!--永远跟在窗口右下角,fixed根据窗口进行定位--&gt;
    &lt;div style=&quot;position: fixed;bottom: 0px;right: 0px&quot;&gt;返回顶部&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/fixed.png" alt="窗口定位"></p>
<h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>对超出的内容添加一个滚动条</p>
<pre><code class="html">&lt;!--如果内容超出添加滚动条--&gt;
&lt;div style=&quot;height: 300px; width: 200px;overflow: auto&quot;&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
    &lt;p&gt;test&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/overflow.png" alt="自动添加滚动条"></p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>优先级,浏览器比作桌面,浏览器上的内容比作卡片,那么优先级就是用来比较那张卡片放在上面,哪张卡片放在下面.数字大的放在上面.数字越大,优先级越高.</p>
<pre><code class="html">&lt;div style=&quot;width: 100%; height: 50px; position: fixed;top: 0px; background-color: green;z-index: 2;&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;width: 100%; height: 50px; position: fixed;top: 30px; background-color: red;z-index: 1&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/z-index.png" alt="层叠优先级"></p>
<h3 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h3><p>设置透明度,0~1:1为不透明,0为完全透明.</p>
<pre><code class="html">&lt;div style=&quot;width: 100%; height: 50px; position: fixed;top: 0px; background-color: green;z-index: 2;opacity: 0.6&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;width: 100%; height: 50px; position: fixed;top: 30px; background-color: red;z-index: 1&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/opactiy.png" alt="透明度"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML 基础]]></title>
      <url>http://www.liangxiansen.cn/2016/09/27/html/</url>
      <content type="html"><![CDATA[<h2 id="什么是HTML？"><a href="#什么是HTML？" class="headerlink" title="什么是HTML？"></a>什么是HTML？</h2><p><code>HTML(HyperText MarkUp Language)</code>超文本标记语言,通过使用标记来描述文档结构和表现形式的一种语言,由浏览器进行解析,然后把结果显示在网页上，通俗的讲它就是服务器发送的字符串到浏览器，通过浏览器能解析的规则用HTML来描述， 它是网页构成的基础,你见到的所有网页都离不开HTML,所以学习HTML是基础中的基础</p>
<blockquote>
<ul>
<li>HTML语言是一种标记语言,不需要编译,直接由浏览器执行</li>
<li>HTML文件是一个文本文件,包含了一些HTML元素, HTML文件是一个文本文件,包含了一些HTML元素,标签等.</li>
<li>HTML文件必须使用html或htm为文件名后缀</li>
<li>HTML是大小写不敏感的,HTML与html是一样的</li>
<li>html标签都是由&lt;??&gt;&lt;/??&gt;得形势存在的,&lt;??&gt;表示这个标签的开始&lt;/??&gt;表示这个标签的结束,中间这是这个标签的内容.</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="Html和CSS、js的关系"><a href="#Html和CSS、js的关系" class="headerlink" title="Html和CSS、js的关系"></a>Html和CSS、js的关系</h3><p>如果把Html比作一个赤裸裸的人，那么css就是给这个人穿上华丽的服装，js就是可以把这个人动起来。</p>
<p>HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。<br>CSS样式是表现(外观控制)。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。<br>JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。<br>知道了概念性的知识，下面来看看Html的组成部分；</p>
<h3 id="第一个HTML"><a href="#第一个HTML" class="headerlink" title="第一个HTML"></a>第一个HTML</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;index&lt;/title&gt;
&lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Doctype"><a href="#Doctype" class="headerlink" title="Doctype"></a>Doctype</h3><p><code>Doctype</code>定义html解释标准,告诉浏览器使用什么样的html或xhtml规范来解析html文档，也就是用哪一种规则来将html变成用户看到的内容。</p>
<p><strong>有和无的区别:</strong></p>
<p><code>BackCompat</code>：标准兼容模式未开启（或叫怪异模式[Quirks mode]、混杂模式）<br><code>CSS1Compat</code>：标准兼容模式已开启（或叫严格模式[Standards mode/Strict mode]）</p>
<p>这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,这也就是恶魔的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了，总之而言就是要告诉浏览器，你要用标准的规则来来解析html,而不是用自己浏览器的规则来解析html。</p>
<p>如下就是列举出来的部分解析html的规则。</p>
<p><img src="http://www.liangxiansen.cn/images/前端/html_doctype.png" alt="Doctype"></p>
<h2 id="head部分"><a href="#head部分" class="headerlink" title="head部分"></a>head部分</h2><h3 id="Meta-metadata-information"><a href="#Meta-metadata-information" class="headerlink" title="Meta(metadata information)"></a>Meta(metadata information)</h3><p>提供有关页面的元信息，例：页面编码、刷新、跳转、针对搜索引擎和更新频度的描述和关键词</p>
<p>1、页面编码</p>
<pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;  #指定编码类型为UTF-8
</code></pre><p>2、刷新和跳转</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot;&gt;  #指定每5秒刷新一次
&lt;meta http-equiv=&quot;refresh&quot; Content=&quot;1;|Url=http://www.cnblogs.com/luotianshuai/&quot; /&gt; #指定1秒之后跳转页面至另一个网页
</code></pre><p>3、关键字</p>
<p>关键字的作用：一般是让爬虫之类的收录程序，当他们在爬你的网站的时候，如果你有关键字，那么他们会优先把关键字收录到他们的记录中，比如百度：如果他们收录之后，他们搜索你的关键字的时候，就能找到咱们的网站。</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;卧槽 ,啪啪啪、 嘿嘿嘿, 爬我呀， 爬我呀&quot; /&gt;
</code></pre><p>4、描述</p>
<p>例如cnblog里的就是一个描述：</p>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;博客园是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界。&quot;&gt;
</code></pre><p>5、X-UA-Compatible</p>
<p>X-UA-Compatible  这个是IE8特有的，知道即可，因为做前端的同学都很害怕IE因为他们问题比较多各个版本问题很诡异，当IE8的时候微软想把各个版本的统一，那么这个参数就出现了，他为了向下兼容，如下的代码如果使用IE8的时候他会以IE7的模式运行。</p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot; /&gt;
</code></pre><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>网页头部信息</p>
<p>如：加上<code>&lt;title&gt;test1&lt;/title&gt;</code></p>
<p>效果：</p>
<p><img src="http://www.liangxiansen.cn/images/前端/title.png" alt="Title"></p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>网页头部图标</p>
<p>如加上：</p>
<pre><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; /&gt;   #href是图片的路径+名字
</code></pre><p>效果：</p>
<p><img src="http://www.liangxiansen.cn/images/前端/link.png" alt="Link"></p>
<h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><ul>
<li>1、在当前文件中写Css样式</li>
<li>2、在其他文件中写Css样式类似python的模块导入的方式把Css样式导入到当前文件中使用</li>
</ul>
<p>导入CSS类似python中导入模块类似</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/css_model.css&quot; /&gt;
</code></pre><h3 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h3><ul>
<li>1、在当前文件中写JS</li>
<li>2、在其他文件中写JS类似python的模块导入的方式把JS导入到当前文件中使用</li>
</ul>
<p><code>可能细心的同学发现了,之前不是说所有标签都是&lt;???&gt;&lt;/???&gt;的形势形势吗?,但是也有只有一个的&lt;??&gt;就结束的了,这样浏览器在解析得时候认为这个标签没有结束是有问题的,不做解析或者解析报错吗?</code></p>
<blockquote>
<p>这位同学问得非常好! 浏览器会很智能的把有错误的标签内容不解析不做显示,也不会报错,但是&lt;??/&gt; 这种标签不是有问题的,这叫<code>自闭合</code>标签,&lt;??&gt;&lt;/??&gt;这种叫<code>闭合</code>标签,这种形势浏览是能够解析的,自闭合标签&lt;??&gt;标准写法是要写成&lt;??/&gt;在最后”&gt;”要结束的时候前面加个”/“,这是更规范得写法,让阅读代码的人一眼就能明白.</p>
</blockquote>
<h2 id="body部分"><a href="#body部分" class="headerlink" title="body部分"></a>body部分</h2><p>1、body里面分为两类标签：块级标签和内联标签，块级标签占用的是整行，内联标签占用的他所使用的实际大小如下图：</p>
<p><code>块级别标签&amp;内联标签:</code></p>
<p><img src="http://www.liangxiansen.cn/images/前端/body1.png" alt="label"></p>
<p>2、特殊符号特殊处理<br>如<code>&lt;h1&gt;</code>这是个标签，如果我只想在页面上这个<code>&lt;h1&gt;</code>字符串，就是不想让浏览器解释这个字符的样式， 这里就需要做特殊处理了，特殊符号有自己定的规则如以下：</p>
<center><img src="http://www.liangxiansen.cn/images/前端/特殊字符.png" alt="特殊字符"></center>


<table>
<thead>
<tr>
<th>HTML原代码</th>
<th>显示结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;lt;</code></td>
<td>&lt;</td>
<td>小于号或显示标记</td>
</tr>
<tr>
<td><code>&amp;gt;</code></td>
<td>&gt;</td>
<td>大于号或显示标记</td>
</tr>
<tr>
<td><code>&amp;amp;</code></td>
<td>&amp;</td>
<td>可用于显示其它特殊字符</td>
</tr>
<tr>
<td><code>&amp;quot;</code></td>
<td>“</td>
<td>引号</td>
</tr>
<tr>
<td><code>&amp;reg;</code></td>
<td>®</td>
<td>已注册</td>
</tr>
<tr>
<td><code>&amp;copy;</code></td>
<td>©</td>
<td>版权</td>
</tr>
<tr>
<td><code>&amp;trade;</code></td>
<td>™</td>
<td>商标</td>
</tr>
<tr>
<td><code>&amp;ensp;</code></td>
<td> </td>
<td>半个空白位</td>
</tr>
<tr>
<td><code>&amp;emsp;</code></td>
<td> </td>
<td>一个空白位</td>
</tr>
<tr>
<td><code>&amp;nbsp;</code></td>
<td></td>
<td>不断行的空白</td>
</tr>
</tbody>
</table>
<h3 id="p标签和br标签"><a href="#p标签和br标签" class="headerlink" title="p标签和br标签"></a>p标签和br标签</h3><p><code>&lt;p&gt;&lt;/p&gt;</code>标签:段落标签,每一对p标签为一段,代码如下:</p>
<pre><code class="html">&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
</code></pre>
<p><code>&lt;br/&gt;</code>标签：换行标签；有一个<code>&lt;br/&gt;</code>为一个换行，看下面的代码:</p>
<pre><code class="html">&lt;p&gt;段落段落段落段落段落段落段&lt;br/&gt;落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
&lt;p&gt;段落段落段落段落段落段落段落段落段落段落段落段落段落&lt;/p&gt;
</code></pre>
<h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p><code>&lt;a&gt;&lt;/a&gt;</code>标签用来跳转和锚</p>
<p><strong>1、跳转:</strong><br>默认如果在<code>&lt;a&gt;&lt;a/&gt;</code>标签中不设置那么他仅仅在浏览器中显示文本，如下面代码:</p>
<pre><code class="html">&lt;a&gt;不能跳转&lt;/a&gt;
&lt;a href=&quot;https://liangxiansen.github.io/&quot;&gt;能跳转&lt;/a&gt;
</code></pre>
<p>点击后将跳转到指定的连接地址~，在当前页面打开的！</p>
<p>如果让他用一个新的标签中打开连接地址代码如下：</p>
<pre><code class="html">&lt;a target=&quot;_blank&quot; href=&quot;https://liangxiansen.github.io/&quot;&gt;跳转到我的博客&lt;/a&gt;
</code></pre>
<p><strong>2、锚:</strong><br>锚的作用是类似于读书时候的书签，当你你点击这个“锚”=“书签”，的时候就跳转到指定的位置</p>
<pre><code class="html">&lt;a href=&quot;#a2&quot;&gt;跳转至第二章&lt;/a&gt;
&lt;!--在标签里，ID是这个标签的唯一的值，我们在做锚的时候指定他的ID即可--&gt;
&lt;!--&lt;a href=&quot;#a2&quot;&gt; 上面的代码href=&quot;#要跳转的标签&quot;--&gt;
&lt;div id=&quot;a1&quot; style=&quot;height:700px;&quot;&gt;第一章&lt;/div&gt;

&lt;div id=&quot;a2&quot; style=&quot;height:700px;&quot;&gt;第二章&lt;/div&gt;
</code></pre>
<p>上面的代码中，如果点击了书签之后，那么就会跳转到id=a2的书签的位置！</p>
<h3 id="h标签"><a href="#h标签" class="headerlink" title="h标签"></a>h标签</h3><p>标题标签,1~6级标题,代码:</p>
<pre><code class="html">&lt;h1&gt;H1&lt;/h1&gt;
&lt;h2&gt;H2&lt;/h2&gt;
&lt;h3&gt;H3&lt;/h3&gt;
&lt;h4&gt;H4&lt;/h4&gt;
&lt;h5&gt;H5&lt;/h5&gt;
&lt;h6&gt;H6&lt;/h6&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/h标签.png" alt="h标签"></p>
<h3 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h3><p>img标签用于在页面上插入图片,img标签图片跳转的时候去边框,IE显示有问题</p>
<pre><code class="html">&lt;!--插入图片--&gt;
&lt;img src=&quot;皮卡丘.jpeg&quot; style=&quot;height: 500px;width: 500px;&quot;&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/img.png" alt="img标签"></p>
<h3 id="Select标签"><a href="#Select标签" class="headerlink" title="Select标签"></a>Select标签</h3><p>未分组select标签:</p>
<pre><code class="html">&lt;select&gt;
    &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;3&quot; selected=&quot;selected&quot;&gt;广州&lt;/option&gt;
    &lt;!--这里默认是广州因为这里设置selected=&quot;selected&quot; 这样页面刚加载完,显示默认选择的就是广州--&gt;
&lt;/select&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/select标签.png" alt="select标签"></p>
<p>分组后select标签:</p>
<pre><code class="html">&lt;select&gt;
    &lt;optgroup label=&quot;河北省&quot;&gt;
        &lt;option&gt;石家庄&lt;/option&gt;
        &lt;option&gt;邯郸&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label=&quot;山西省&quot;&gt;
        &lt;option&gt;太原&lt;/option&gt;
        &lt;option&gt;平遥&lt;/option&gt;
    &lt;/optgroup&gt;
&lt;/select&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/selectgroup.png" alt="SelectGroup"></p>
<p>设置select标签长度:</p>
<pre><code class="html">&lt;select size=&quot;2&quot;&gt;
    &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h3 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h3><p><strong>1、单选框:</strong></p>
<pre><code class="html">&lt;!--第一中情况不互斥--&gt;
男&lt;input type=&quot;radio&quot;/&gt;
女&lt;input type=&quot;radio&quot;/&gt;
&lt;hr/&gt;
&lt;!--对于input标签来说只要，radio的name值相同，那么他们就会互斥--&gt;
男&lt;input type=&quot;radio&quot; name=&quot;gender&quot;/&gt;
女r&lt;input type=&quot;radio&quot; name=&quot;gender&quot;/&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/radio.png" alt="单选框"></p>
<hr>
<p><strong>2、复选框:</strong></p>
<pre><code class="html">娱乐&lt;input type=&quot;checkbox&quot;/&gt;
时尚&lt;input type=&quot;checkbox&quot;/&gt;
音乐&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;
&lt;!--这里加一个标识checked=&quot;checked，为默认选择&quot;--&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/checkbox.png" alt="多选框"></p>
<hr>
<p><strong>3、text&amp;password输入框:</strong></p>
<pre><code class="html">&lt;!--标准的输入框--&gt;
&lt;input type=&quot;text&quot;/&gt;
&lt;!--密码的输入框（输入的内容是保密的）--&gt;
&lt;input type=&quot;password&quot;/&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/text.png" alt="文本框"></p>
<hr>
<p><strong>4、文件上传:</strong></p>
<pre><code class="html">&lt;input type=&quot;file&quot;/&gt;
</code></pre>
<p><img src="http://www.liangxiansen.cn/images/前端/file.png" alt="上传文件"></p>
<hr>
<p><strong>5、多行文本框:</strong></p>
<pre><code class="html">个性签名:&lt;textarea style=&quot;width: 200px; height: 100px&quot;&gt;&lt;/textarea&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/textarea.png" alt="多行文本框"></p>
<hr>
<p><strong>6、Label标签:</strong><br>使用label标签,可以在点击文字的时候将鼠标焦点转移到input内容上,帮助用户选择.</p>
<pre><code class="html">&lt;div&gt;
    &lt;label for=&quot;name_1&quot;&gt;
        姓名:&lt;input id=&quot;name_1&quot; type=&quot;text&quot;/&gt;
    &lt;/label&gt;

    &lt;label for=&quot;name_2&quot;&gt;
        婚否:&lt;input id=&quot;name_2&quot; type=&quot;checkbox&quot;/&gt;
    &lt;/label&gt;
&lt;/div&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/label.png" alt="Label"></p>
<hr>
<p><strong>7、提交表单:</strong><br><code>form</code></p>
<pre><code class="html">&lt;form action=&quot;www.baidu.com&quot; method=&quot;POST&quot; &gt;
    &lt;!--这里action是告诉html提交到哪里--&gt;
    &lt;!--method是通过什么方法去action指定的地址--&gt;
    &lt;p&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/p&gt;
    &lt;!--这里的name属性是当咱们将数据提交到指定的action地址时,服务端接收到的数据后如何去辨别数据--&gt;
    &lt;!--服务端得到数据后,就是一个字典类型,把这里的用户的输入的内容复制给name作为为一个字典key:value形势--&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
    &lt;input type=&quot;button&quot; value=&quot;按钮&quot;/&gt;
    &lt;!--这里提交按钮才有反映，submit是用来提交当前的表单的，当然可以有多个表单--&gt;
    &lt;!--但是，这个submit需要写入表单内，那么提交的时候是提交的当前表单--&gt;
    &lt;!--button按钮是没有任何功能的,需要给他添加上动作(js)--&gt;
&lt;/form&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/form.png" alt="form"></p>
<h3 id="序号标签"><a href="#序号标签" class="headerlink" title="序号标签"></a>序号标签</h3><pre><code class="html">&lt;!--项目序号--&gt;
&lt;ul&gt;
    &lt;li&gt;line1&lt;/li&gt;
    &lt;li&gt;line2&lt;/li&gt;
    &lt;li&gt;line3&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
    &lt;li&gt;line1&lt;/li&gt;
    &lt;li&gt;line2&lt;/li&gt;
    &lt;li&gt;line3&lt;/li&gt;
&lt;/ol&gt;

&lt;dl&gt;
    &lt;dt&gt;北京市&lt;/dt&gt;
    &lt;dd&gt;海淀区&lt;/dd&gt;
    &lt;dd&gt;东城区&lt;/dd&gt;
    &lt;dd&gt;朝阳去&lt;/dd&gt;
    &lt;dt&gt;湖南省&lt;/dt&gt;
    &lt;dd&gt;长沙&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/序号.png" alt="序号"></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code class="html">&lt;!--表格,表格边框1--&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tr&gt;
        &lt;!--列合并居中,colspan指的是合并多少个--&gt;
        &lt;th colspan=&quot;3&quot;&gt;标题一&lt;/th&gt;
        &lt;th&gt;标题二&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;内容一&lt;/td&gt;
        &lt;td&gt;内容二&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;内容一&lt;/td&gt;
        &lt;!--行合并居中--&gt;
        &lt;td rowspan=&quot;2&quot;&gt;内容二&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;内容一&lt;/td&gt;

        &lt;td&gt;内容三&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;内容一&lt;/td&gt;
        &lt;td&gt;内容二&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
        &lt;td&gt;内容三&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


&lt;!--水平线--&gt;
&lt;hr /&gt;


&lt;!--表格,表格边框1--&gt;
&lt;table  border=&quot;1&quot;&gt;
    &lt;thead&gt;
    &lt;!--表头--&gt;
        &lt;tr&gt;
            &lt;th&gt;标题一&lt;/th&gt;
            &lt;th&gt;标题二&lt;/th&gt;
            &lt;th&gt;标题三&lt;/th&gt;
            &lt;th&gt;标题四&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    &lt;!--表格主体--&gt;
        &lt;tr&gt;
            &lt;td&gt;第一列&lt;/td&gt;
            &lt;td&gt;第二列&lt;/td&gt;
            &lt;td&gt;第三列&lt;/td&gt;
            &lt;td&gt;第四列&lt;/td&gt;
        &lt;/tr&gt;
         &lt;tr&gt;
            &lt;td&gt;第一列&lt;/td&gt;
            &lt;td&gt;第二列&lt;/td&gt;
            &lt;td&gt;第三列&lt;/td&gt;
            &lt;td&gt;第四列&lt;/td&gt;
        &lt;/tr&gt;

    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/table.png" alt="table"></p>
<h3 id="ifram标签"><a href="#ifram标签" class="headerlink" title="ifram标签"></a>ifram标签</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;汽车之家&lt;/h1&gt;
    &lt;!--框架嵌入--&gt;
    &lt;iframe style=&quot;width: 100%;height: 2000px;&quot; src=&quot;http://autohome.com.cn&quot;&gt;&lt;/iframe&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/iframe.png" alt="iframe"></p>
<h3 id="fieldset标签"><a href="#fieldset标签" class="headerlink" title="fieldset标签"></a>fieldset标签</h3><pre><code class="html">&lt;fieldset&gt;
    &lt;legend&gt;协议&lt;/legend&gt;
    请仔细阅读协议内容：
&lt;/fieldset&gt;
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/前端/fieldset.png" alt="table"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git 笔记]]></title>
      <url>http://www.liangxiansen.cn/2016/09/14/git_notes/</url>
      <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>git init
</code></pre><h3 id="添加变更"><a href="#添加变更" class="headerlink" title="添加变更"></a>添加变更</h3><pre><code>git add
</code></pre><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><pre><code>git status
</code></pre><h3 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h3><pre><code>git commit -m &quot;message&quot;
git commit -am &quot;message&quot;
git commit  # 打开编辑器编辑日志,注释行不要删，不用管他，内容写在注释上面，保存提交成功
</code></pre><a id="more"></a>
<h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><pre><code>git commit --amend
</code></pre><h3 id="发布变更"><a href="#发布变更" class="headerlink" title="发布变更"></a>发布变更</h3><pre><code>git push
git push -u origin master
git push -u origin {branch-C}
</code></pre><h3 id="从远程获取git仓库"><a href="#从远程获取git仓库" class="headerlink" title="从远程获取git仓库"></a>从远程获取git仓库</h3><pre><code>git clone https://github.com/LiangXianSen/git-test.git
</code></pre><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><pre><code>git log
git log --pretty=short
git log -p file
git log --graph
</code></pre><h3 id="压缩历史日志"><a href="#压缩历史日志" class="headerlink" title="压缩历史日志"></a>压缩历史日志</h3><pre><code>git rebase -i HEAD~2
pick
fixup
</code></pre><h3 id="比较变更"><a href="#比较变更" class="headerlink" title="比较变更"></a>比较变更</h3><pre><code>git diff
</code></pre><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre><code>git branch
git branch -a
</code></pre><h3 id="分支操作-1"><a href="#分支操作-1" class="headerlink" title="分支操作"></a>分支操作</h3><pre><code>git checkout {name}
git checkout -  ＃ 相对向上移动
git checkout ^  ＃ 相对向上移动
git checkout ^^  ＃ 相对向上移动两个
git checkout ~1  ＃ 相对向上移动多个
git checkout -b {name}   # 创建新分支
git checkout -b test-C origin/test-C  # 获取远程分支到本地
</code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre><code>git checkout master
git merge --no-ff {name}
</code></pre><h3 id="回溯历史版本"><a href="#回溯历史版本" class="headerlink" title="回溯历史版本"></a>回溯历史版本</h3><pre><code>git reflog   # 查看历史版本哈希值
git reset --hard
</code></pre><h3 id="创建远仓库"><a href="#创建远仓库" class="headerlink" title="创建远仓库"></a>创建远仓库</h3><pre><code>git remote add origin git@github.com:{用户名}/｛仓库名｝.git
</code></pre><h2 id="git-clone字符事项"><a href="#git-clone字符事项" class="headerlink" title="git clone字符事项"></a>git clone字符事项</h2><blockquote>
<p>CR回车 LF换行Windows/Dos CRLF \r\n<br>Linux/Unix LF \n<br>MacOS CR \r<br>解决方法是：打开命令行，进行设置，如果你是在Windows下开发，建议设置autocrlf为true。<br>补充：如果你文件编码是UTF8并且包含中文文字，那还是把autocrlf设置为false，并且把所有文件转换为Linux编码（即LF\n），开启safecrlf检查。</p>
</blockquote>
<p>一、AutoCRLF<br>提交时转换为LF，检出时转换为CRLF</p>
<pre><code>git config --global core.autocrlf true
</code></pre><p>提交时转换为LF，检出时不转换</p>
<pre><code>git config --global core.autocrlf input
</code></pre><p>提交检出均不转换</p>
<pre><code>git config --global core.autocrlf false
</code></pre><p>二、SafeCRLF</p>
<p>拒绝提交包含混合换行符的文件</p>
<pre><code>git config --global core.safecrlf true
</code></pre><p>允许提交包含混合换行符的文件</p>
<pre><code>git config --global core.safecrlf false
</code></pre><p>提交包含混合换行符的文件时给出警告</p>
<pre><code>git config --global core.safecrlf warn
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Django 学习]]></title>
      <url>http://www.liangxiansen.cn/2016/09/05/Django/</url>
      <content type="html"><![CDATA[<p>Python的WEB框架有Django、Tornado、Flask 等多种，Django相较与其他WEB框架其优势为：大而全，框架本身集成了ORM、模型绑定、模板引擎、缓存、Session等诸多功能。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="创建Django程序"><a href="#创建Django程序" class="headerlink" title="创建Django程序"></a>创建Django程序</h3><ol>
<li>终端命令：<code>django-admin startproject sitename</code></li>
<li>通过IDE(pycharm)创建Django程序，本质上都是自动执行上述命令</li>
</ol>
<p><img src="http://www.liangxiansen.cn/images/django/创建Django.png" alt="创建Django"><br><a id="more"></a></p>
<p>上述的sitename是自己定义的项目名称！<br>其他常用命令：</p>
<pre><code>python manage.py runserver 0.0.0.0:port     # 运行django,指定端口
python manage.py startapp appname           # 创建app
python manage.py syncdb
python manage.py makemigrations             # 建立数据库
python manage.py migrate                    # 初始化数据库
python manage.py createsuperuser            # 创建admin后台用户
</code></pre><h3 id="程序目录"><a href="#程序目录" class="headerlink" title="程序目录"></a>程序目录</h3><p><img src="http://www.liangxiansen.cn/images/django/django目录.png" alt="Django目录"></p>
<p><code>settings.py</code> 配置文件</p>
<p><code>urls.py</code> 存放路由系统（映射）</p>
<p><code>wsgi.py</code>  让你做配置：wsgi有多重一种uwsgi和wsgi，你用那种wsgi来运行Django，一般不用改只有你用到的时候在改</p>
<p><code>manage.py</code>  就是Django的启动管理程序</p>
<p>以上配置文件，如果是初学者当创建完project后都不要修改，因为涉及到很多配置文件需要修改</p>
<h3 id="Project和App概念"><a href="#Project和App概念" class="headerlink" title="Project和App概念"></a>Project和App概念</h3><p>咱们目前创建的是<code>Project</code>，Project下面可以有很多<code>app</code>，原理是什么呢！</p>
<p>我们创建的Project是一个大的工程，下面有很多功能：（一个Project有多个App，其实他就是对你大的工程的一个<code>分类</code>）</p>
<blockquote>
<p>Project<br>    –web     (前台功能)<br>    –admin  （后台管理功能）</p>
</blockquote>
<p>一个Project有多个app，其实他就是对你大的工程的一个分类</p>
<h3 id="创建App"><a href="#创建App" class="headerlink" title="创建App"></a>创建App</h3><pre><code>python manage.py startapp app01
</code></pre><p>如果在创建一个App，我们可以理解为App是手机里的App程序他们之间是<code>完全独立</code>的，好处是降低他们之间的<code>耦合</code>性，不到万不得已不要让他们之间建立关系</p>
<p><img src="http://www.liangxiansen.cn/images/django/django_app.png" alt="Django目录"></p>
<p><code>注册App</code><br>创建的App,需要在工程的<code>settings.py</code>文件里面注册</p>
<pre><code>INSTALLED_APPS = [
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app01&#39;,
]
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>settings.py</code></p>
<p>1、数据库</p>
<pre><code>DATABASES = {
    &#39;default&#39;: {
    &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
    &#39;NAME&#39;:&#39;dbname&#39;,
    &#39;USER&#39;: &#39;root&#39;,
    &#39;PASSWORD&#39;: &#39;xxx&#39;,
    &#39;HOST&#39;: &#39;&#39;,
    &#39;PORT&#39;: &#39;&#39;,
    }
}

# 由于Django内部连接MySQL时使用的是MySQLdb模块，而Python中还无此模块，所以需要使用pymysql来代替

# 如下设置放置的与project同名的配置的 __init__.py文件中

import pymysql
pymysql.install_as_MySQLdb()　
</code></pre><p>2、模板</p>
<pre><code>TEMPLATE_DIRS = (
    os.path.join(BASE_DIR,&#39;templates&#39;),
)
</code></pre><p>3、静态文件</p>
<pre><code># 实际调用得名称
STATIC_URL = &#39;/static/&#39;

# 真实路径
STATICFILES_DIRS = (
    os.path.join(BASE_DIR,&#39;statics&#39;),
)
</code></pre><h3 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h3><p>1、每个路由规则对应<code>view</code>中的一个函数,(处理发来的请求)</p>
<pre><code>url(r&#39;^index/(\d*)&#39;, views.index),
url(r&#39;^manage/(?P&lt;name&gt;\w*)/(?P&lt;id&gt;\d*)&#39;, views.manage),
url(r&#39;^manage/(?P&lt;name&gt;\w*)&#39;, views.manage,{&#39;id&#39;:333}),
</code></pre><p>2、根据app对路由规则进行一次分类</p>
<pre><code>from django.conf.urls import url, include

url(r&#39;^web/&#39;,include(&#39;web.urls&#39;)),
</code></pre><p>django中的路由系统和其他语言的框架有所不同，在django中每一个请求的<code>url</code>都要有一条路由映射，这样才能将请求交给对一个的<code>view</code>中的函数去处理。其他大部分的Web框架则是对一类的url请求做一条路由映射，从而是路由系统变得简洁。</p>
<p>通过<code>反射</code>机制，为django开发一套<code>动态</code>的路由系统:</p>
<pre><code>    (&#39;^(?P&lt;app&gt;(\w+))/(?P&lt;function&gt;(\w+))/(?P&lt;page&gt;(\d+))/(?P&lt;id&gt;(\d+))/$&#39;,process),
    (&#39;^(?P&lt;app&gt;(\w+))/(?P&lt;function&gt;(\w+))/(?P&lt;id&gt;(\d+))/$&#39;,process),
    (&#39;^(?P&lt;app&gt;(\w+))/(?P&lt;function&gt;(\w+))/$&#39;,process),
    (&#39;^(?P&lt;app&gt;(\w+))/$&#39;,process,{&#39;function&#39;:&#39;index&#39;}),
</code></pre><h2 id="MTV操作-Models、Templates、Views"><a href="#MTV操作-Models、Templates、Views" class="headerlink" title="MTV操作(Models、Templates、Views)"></a>MTV操作(Models、Templates、Views)</h2><h3 id="模板-Templates"><a href="#模板-Templates" class="headerlink" title="模板(Templates)"></a>模板(Templates)</h3><p><strong>1、模版的执行</strong><br>模版的创建过程，对于模版，其实就是读取模版（其中嵌套着模版标签），然后将 Model 中获取的数据插入到模版中，最后将模板和数据渲染后最终结果返回给用户。</p>
<pre><code>def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot; % now
    return HttpResponse(html)
</code></pre><pre><code>from django import template
t = template.Template(&#39;My name is {{ name }}.&#39;)
c = t.Context({&#39;name&#39;: &#39;Adrian&#39;})
print(t.render(c))
</code></pre><pre><code>import datetime
from django import template
import DjangoDemo.settings

now = datetime.datetime.now()
fp = open(settings.BASE_DIR+&#39;/templates/Home/Index.html&#39;)
t = template.Template(fp.read())
fp.close()
html = t.render(template.Context({&#39;current_date&#39;: now}))
return HttpResponse(html)
</code></pre><pre><code>from django.template.loader import get_template
from django.template import Context
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    t = get_template(&#39;current_datetime.html&#39;)
    html = t.render(Context({&#39;current_date&#39;: now}))
    return HttpResponse(html)
</code></pre><pre><code>return render_to_response(&#39;Account/Login.html&#39;,data,context_instance=RequestContext(request))
</code></pre><p><strong>2、模版语言</strong></p>
<blockquote>
<p>模板中也有自己的语言，该语言可以实现数据展示</p>
</blockquote>
<pre><code># 引用后台传传来item的值
{{ item }}

# 获取item对象中value的值
{{ item.value }}

# 获取item对象如果是个数组.1 获取索引1对象中value的值
{{ item.1.value }}

# for循环
{% for item in item_list %}
    <a>{{ item }}</a>  # 每一个都创建这样一个A标签
{% endfor %}

    forloop.counter  # for循环的次数
    forloop.first    # 循环的第一个
    forloop.last     # 循环的最后一个

# 条件判断
{% if ordered_warranty %}
    <a>ture</a>
{% else %}
    <a>false</a>
{% endif %}

母板：{% block title %}{% endblock %}
子板：{% extends "base.html" %}
　　　{% block title %}{% endblock %}

内置方法：
{{ item.event_start|date:"Y-m-d H:i:s"}}
{{ bio|truncatewords:"30" }}
{{ my_list|first|upper }}
{{ name|lower }}
</code></pre><p><code>_模板语言中除了内置方法,也有两种方式自己定义方法_</code></p>
<p><strong>3、自定义模板语言方法</strong></p>
<p>1) 在app中创建templatetags模块<br>2) 创建任意 .py 文件，如：xx.py</p>
<pre><code class="python">from django import template
from django.utils.safestring import mark_safe
from django.template.base import Node, TemplateSyntaxError

# 这个是不可变的,必须要写
register = template.Library()

@register.simple_tag
def f1(s1, s2, s3):
    return s1 + s2 + s3
</code></pre>
<p>3) 在使用自定义simple_tag的html文件中导入之前创建的 xx.py 文件</p>
<pre><code>{% load xx %}
</code></pre><p>4) 使用simple_tag</p>
<pre><code class="html">执行自己定义的simple_tag类型方法 f1接收3个参数,传3个参数
{% f1 1 2 3 %}
</code></pre>
<p>5) 自定义<code>filter</code>方法</p>
<pre><code class="python">@register.filter
def f2(value):
    if value == &#39;vvv&#39;:
        return True
    return False
</code></pre>
<p>6) 使用filter</p>
<pre><code>将item值当作参数传递给f2方法
{{ item|f2  }}
额外给f2再传递一个参数
{{ item|f2:"123" }}
</code></pre><blockquote>
<p><code>filter</code>方法和<code>simple_tag</code>方法使用的方式不一样,filter只能接收最多两个参数,simple_tag可以接收任意个参数,他们最大的区别是,filter还能支持<code>if</code>语句条件</p>
</blockquote>
<pre><code>{% if k1|f3 %}
</code></pre><p>7) 在settings中配置当前app，不然django无法找到自定义的方法　</p>
<pre><code class="python">INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app01&#39;,
)
</code></pre>
<p><strong>4、母板</strong><br>首先了解下母板是什么概念？首先已博客园为例：<br>看下面的图片，在点击首页、精华、候选、新闻、管住、我评、我赞的时候  上面、左侧的红色框体都没有变，变得是中间的内容是怎么实现的呢？就是通过母版来实现的</p>
<p><img src="http://www.liangxiansen.cn/images/django/django母版.png" alt="网页母板"></p>
<p>创建一个<code>母板</code>,母板中确定下不变的内容和变动得内容,然后再创建<code>子板</code>,子板继承母板,子板中只需要写变动得内容那块得代码即可.其他的内容都套用母板的.</p>
<p>在templates目录下面创建一个master目录（统一用他吧），然后在master目录下创建一个master_templates.html</p>
<p><img src="http://www.liangxiansen.cn/images/django/创建母板.png" alt="创建母板"></p>
<p><strong><code>母板代码:</code></strong></p>
<p><img src="http://www.liangxiansen.cn/images/django/django母板代码.png" alt="母板代码"></p>
<p>母板一般确定三块变动得区域:<br>    1) 活动css样式代码块,这样子板和子板即可以即有从母板继承下来的代码和样式还有自己的样式<br>    2) 活动主要内容代码块,子板自己的内容<br>    3) 活动js代码块,子板中自己的js代码</p>
<p><strong><code>子板代码:</code></strong><br>子板中引用母板,然后只要写上子板中要写的内容写在母板对应的<code>block</code>语法名称中<br><img src="http://www.liangxiansen.cn/images/django/django子板代码.png" alt="子板代码"></p>
<blockquote>
<p>最后实现的情况如下图,,页眉页脚和左侧菜单不变,变得只是右边绿色框中的内容.</p>
</blockquote>
<p><img src="http://www.liangxiansen.cn/images/django/django母板示例.png" alt="母板示例"></p>
<p><strong>5、小组件</strong><br>还可以单独在一个文件中写一段代码,然后以小组件得形式提供给别的页面使用,这样可以做到一个经常用到的一段代码写成小组件,达到复用得情况:</p>
<p>1) 在<code>templates</code>下新建一个模板文件,然后在里面写上一段代码:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;小黄人&lt;/title&gt;
    &lt;style&gt;
        .huang{
            position: fixed;
            top: 50%;
            margin-top: -240px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--这是一个永远水平居中停靠在窗口左边的小黄人插件--&gt;
    &lt;div&gt;
        &lt;img class=&quot;huang&quot; src=&quot;/static/images/小黄人.jpg&quot; /&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2) 如果要使用这段代码(这个组件),只需要在要使用的html中写:</p>
<pre><code>{% include '小黄人.html' %}
</code></pre><p><code>实际效果:</code></p>
<p><img src="http://www.liangxiansen.cn/images/django/django模板插件.png" alt="模板插件"></p>
<h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h3><p>到目前为止，当我们的程序涉及到数据库相关操作</p>
<blockquote>
<ul>
<li>创建数据库，设计表结构和字段</li>
<li>使用 MySQLdb 来连接数据库，并编写数据访问层代码</li>
<li>业务逻辑层去调用数据访问层执行数据库操作</li>
</ul>
</blockquote>
<p>django为使用一种新的方式，即：关系对象映射（Object Relational Mapping，简称<code>ORM</code>）。</p>
<p>　　 PHP：<code>activerecord</code></p>
<p>　　Java：<code>Hibernate</code></p>
<p>　　  C#：<code>Entity Framework</code></p>
<p>django中遵循 <code>Code Frist</code> 的原则，即：根据代码中定义的类来自动生成数据库表。<br>django默认使用自带的<code>db.sqlite3</code><br><strong>1、创建数据库</strong></p>
<p>1) 创建model类</p>
<pre><code class="python">from django.db import models

class userinfo(models.Model):
    name = models.CharField(max_length=30)
    email = models.EmailField()
    memo = models.TextField()
</code></pre>
<p>2) 执行命令</p>
<pre><code class="bash">　　python manage.py makemigrations
　　python manage.py migrate
</code></pre>
<h4 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h4><pre><code>models.AutoField　　# 自增列 = int(11)
# 如果没有的话，默认会生成一个名称为 id 的列，如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。
models.CharField　　# 字符串字段
# 必须 max_length 参数
models.BooleanField　　# 布尔类型=tinyint(1)
# 不能为空，Blank=True
models.ComaSeparatedIntegerField　　# 用逗号分割的数字=varchar
# 继承CharField，所以必须 max_lenght 参数
models.DateField　　# 日期类型 date
# 对于参数，auto_now = True   # 则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。
models.DateTimeField　　# 日期类型 datetime
# 同DateField的参数
models.Decimal　　# 十进制小数类型 = decimal
# 必须指定整数位max_digits和小数位decimal_places
models.EmailField　　# 字符串类型（正则表达式邮箱） =varchar
# 对字符串进行正则表达式
models.FloatField　　# 浮点类型 = double
models.IntegerField　　# 整形
models.BigIntegerField　　# 长整形
integer_field_ranges = {
　　&#39;SmallIntegerField&#39;: (-32768, 32767),
　　&#39;IntegerField&#39;: (-2147483648, 2147483647),
　　&#39;BigIntegerField&#39;: (-9223372036854775808, 9223372036854775807),
　　&#39;PositiveSmallIntegerField&#39;: (0, 32767),
　　&#39;PositiveIntegerField&#39;: (0, 2147483647),
}
models.IPAddressField　　# 字符串类型（ip4正则表达式）
models.GenericIPAddressField　　# 字符串类型（ip4和ip6是可选的）
# 参数protocol可以是：both、ipv4、ipv6
# 验证时，会根据设置报错
models.NullBooleanField　　# 允许为空的布尔类型
models.PositiveIntegerFiel　　# 正Integer
models.PositiveSmallIntegerField　　# 正smallInteger
models.SlugField　　# 减号、下划线、字母、数字
models.SmallIntegerField　　# 数字
# 数据库中的字段有：tinyint、smallint、int、bigint
models.TextField　　# 字符串=longtext
models.TimeField　　# 时间 HH:MM[:ss[.uuuuuu]]
models.URLField　　# 字符串，地址正则表达式
models.BinaryField　　  # 二进制
models.ImageField      # 图片
models.FilePathField   # 文件
</code></pre><h4 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h4><pre><code>null=True
# 数据库中字段是否可以为空
blank=True
# django的 Admin 中添加数据时是否可允许空值
primary_key = False
# 主键，对AutoField设置主键后，就会代替原来的自增 id 列
auto_now 和 auto_now_add
  auto_now   # 自动创建---无论添加或修改，都是当前操作的时间
  auto_now_add  # 自动创建---永远是创建时的时间
choices
GENDER_CHOICE = (
        (u&#39;M&#39;, u&#39;Male&#39;),
        (u&#39;F&#39;, u&#39;Female&#39;),
    )
gender = models.CharField(max_length=2,choices = GENDER_CHOICE)
max_length
default　　# 默认值
verbose_name　　# Admin中字段的显示名称
name|db_column　　# 数据库中的字段名称
unique=True　　# 不允许重复
db_index = True　　# 数据库索引
editable=True　　# 在Admin里是否可编辑
error_messages=None　　# 错误提示
auto_created=False　　# 自动创建
help_text　　# 在Admin中提示帮助信息
validators=[]
upload-to
</code></pre><p><strong>2、连表结构</strong></p>
<ul>
<li>一对多：models.ForeignKey(其他表)</li>
<li>多对多：models.ManyToManyField(其他表)</li>
<li>一对一：models.OneToOneField(其他表)</li>
</ul>
<blockquote>
<p>应用场景：</p>
<ul>
<li>一对多：当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）<br>  例如：创建用户信息时候，需要选择一个用户类型【普通用户】【金牌用户】【铂金用户】等。</li>
<li>多对多：在某表中创建一行数据是，有一个可以多选的下拉框<br>  例如：创建用户信息，需要为用户指定多个爱好</li>
<li>一对一：在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了<br>  例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据</li>
</ul>
</blockquote>
<p><strong>3、操作表</strong><br>1) 基本操作</p>
<pre><code class="python"># 增
models.Tb1.objects.create(c1=&#39;xx&#39;, c2=&#39;oo&#39;)  # 增加一条数据，可以接受字典类型数据 **kwargs

obj = models.Tb1(c1=&#39;xx&#39;, c2=&#39;oo&#39;)
obj.save()

# 查
models.Tb1.objects.get(id=123)         # 获取单条数据，不存在则报错（不建议）
models.Tb1.objects.all()               # 获取全部
models.Tb1.objects.filter(name=&#39;seven&#39;) # 获取指定条件的数据

# 删
models.Tb1.objects.filter(name=&#39;seven&#39;).delete() # 删除指定条件的数据

# 改
models.Tb1.objects.filter(name=&#39;seven&#39;).update(gender=&#39;0&#39;)  # 将指定条件的数据更新，均支持 **kwargs
obj = models.Tb1.objects.get(id=1)
obj.c1 = &#39;111&#39;
obj.save()                                                 # 修改单条数据
</code></pre>
<p>2) 进阶操作（了不起的双下划线）</p>
<p>利用双下划线将字段和对应的操作连接起来</p>
<pre><code class="python"># 获取个数
models.Tb1.objects.filter(name=&#39;seven&#39;).count()

# 大于，小于
models.Tb1.objects.filter(id__gt=1)              # 获取id大于1的值
models.Tb1.objects.filter(id__lt=10)             # 获取id小于10的值
models.Tb1.objects.filter(id__lt=10, id__gt=1)   # 获取id大于1 且 小于10的值

# in
models.Tb1.objects.filter(id__in=[11, 22, 33])   # 获取id等于11、22、33的数据
models.Tb1.objects.exclude(id__in=[11, 22, 33])  # not in

# contains
models.Tb1.objects.filter(name__contains=&quot;ven&quot;)
models.Tb1.objects.filter(name__icontains=&quot;ven&quot;) # icontains大小写不敏感
models.Tb1.objects.exclude(name__icontains=&quot;ven&quot;)

# range
models.Tb1.objects.filter(id__range=[1, 2])   # 范围bettwen and

# 其他类似
startswith，istartswith, endswith, iendswith,

# 排序
models.Tb1.objects.filter(name=&#39;seven&#39;).order_by(&#39;id&#39;)    # 生序
models.Tb1.objects.filter(name=&#39;seven&#39;).order_by(&#39;-id&#39;)   # 降序

# limit 、offset
models.Tb1.objects.all()[10:20]

# 返回list中就不再是对象了,而是键值对(字典),
models.Tb1.objects.all().values(&#39;user&#39;)
# [{&#39;user: &#39;alex&#39;, &#39;user&#39;: &#39;eric&#39;}]

# 返回的list是一个一个元祖,元祖里面就是一个个值.
models.Tb1.objects.all().values_list(&#39;user&#39;)
# [(&#39;ales&#39;), (&#39;eric&#39;)]

# group by
from django.db.models import Count, Min, Max, Sum
models.Tb1.objects.filter(c1=1).values(&#39;id&#39;).annotate(c=Count(&#39;num&#39;))
# SELECT &quot;app01_tb1&quot;.&quot;id&quot;, COUNT(&quot;app01_tb1&quot;.&quot;num&quot;) AS &quot;c&quot; FROM &quot;app01_tb1&quot; WHERE &quot;app01_tb1&quot;.&quot;c1&quot; = 1 GROUP BY &quot;app01_tb1&quot;.&quot;id&quot;

</code></pre>
<p>3) 连表操作（了不起的双下划线）</p>
<pre><code class="python">class UserProfile(models.Model):
    user_info = models.OneToOneField(&#39;UserInfo&#39;)
    username = models.CharField(max_length=64)
    password = models.CharField(max_length=64)

    def __unicode__(self):
        return self.username


class UserInfo(models.Model):
    user_type_choice = (
        (0, u&#39;普通用户&#39;),
        (1, u&#39;高级用户&#39;),
    )
    # choices设置别名
    user_type = models.IntegerField(choices=user_type_choice)
    name = models.CharField(max_length=32)
    email = models.CharField(max_length=32)
    address = models.CharField(max_length=128)

    def __unicode__(self):
        return self.name


class UserGroup(models.Model):

    caption = models.CharField(max_length=64)

    user_info = models.ManyToManyField(&#39;UserInfo&#39;)

    def __unicode__(self):
        return self.caption


class Host(models.Model):
    hostname = models.CharField(max_length=64)
    ip = models.GenericIPAddressField()
    user_group = models.ForeignKey(&#39;UserGroup&#39;)

    def __unicode__(self):
        return self.hostname
</code></pre>
<p><code>一对一操作:</code></p>
<pre><code class="python">import os
import django
from mysite import settings
os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;mysite.settings&quot;)
django.setup()


from app01 import models

models.UserInfo.objects.create(name=&#39;liang&#39;,user_type=1,email=&#39;liang@163.com&#39;)
user_info_obj = models.UserInfo.objects.filter(id=1).first()

models.UserProfile.objects.create(user_info=user_info_obj, username=&#39;liang&#39;, password=&#39;123&#39;,)


print(user_info_obj.user_type)
print(user_info_obj.get_user_type_display())
print(user_info_obj.userprofile.password)

user_info_obj = models.UserInfo.objects.filter(id=1).values(&#39;email&#39;, &#39;userprofile__username&#39;).first()   # 双下划线跨表链接另外一个表,然后加字段就可以跨表查询
print(list(user_info_obj.keys()))
print(list(user_info_obj.values()))
</code></pre>
<p><code>多对多操作:</code><br>利用双下划线和 _set 将表之间的操作连接起来</p>
<pre><code class="python">import os
import django
from mysite import settings
os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;mysite.settings&quot;)
django.setup()


from app01 import models

user_info_obj = models.UserInfo.objects.filter(name=&#39;liang&#39;)[0]
user_info_objs = models.UserInfo.objects.all()


models.UserGroup.objects.create(caption=&#39;liang&#39;)
models.UserGroup.objects.create(caption=&#39;lianglian&#39;)


group_obj = models.UserGroup.objects.get(caption=&#39;liang&#39;)
group_objs = models.UserGroup.objects.all()

# 添加数据
group_obj.user_info.add(user_info_obj)
group_obj.user_info.add(*user_info_objs)  # &#39;*kwarg&#39;

# 删除数据
group_obj.user_info.remove(user_info_obj)
group_obj.user_info.remove(*user_info_objs)

# 添加数据
user_info_obj.usergroup_set.add(group_obj)
user_info_obj.usergroup_set.add(*group_objs)

# 删除数据
user_info_obj.usergroup_set.remove(group_obj)
user_info_obj.usergroup_set.remove(*group_objs)

# 获取数据
print(group_obj.user_info.all())
print(group_obj.user_info.all().filter(id=1))

# 获取数据
print(user_info_obj.usergroup_set.all())
print(user_info_obj.usergroup_set.all().filter(caption=&#39;liang&#39;))
print(user_info_obj.usergroup_set.all().filter(caption=&#39;lianglian&#39;))
</code></pre>
<p><code>注意：xx_set中的多对多中的隐含字段,用于反向查询</code></p>
<p><code>跨表操作:</code></p>
<pre><code class="python">class UserType(models.model):
    caption = models.CharField(max_length=32)
    # 普通用户,超级用户,测试用户

class Somthing(models.Model):
    name = models.CharField(max_length=32)
    s = models.ForignKey(&#39;Somthing&#39;)

class UserInfo(models.Model):
    user = models.CharField(max_length=32)
    pwd = models.CharField(max_length=32)
    user_type = models.ForignKey(&#39;UserType&#39;)
    # 在Django数据库表中ForignKey字段其实就是 user_type_id ,带指的就是&#39;UserType&#39;表的id字段

# 双下划线进行跨表查询,UserInfo的user_type字段对应的就是UserType表,再加&#39;__&#39;双下划线就可以跨表查询了.
querset = UserInfo.objects.filter(user_type__caption=&#39;普通用户&#39;)

querset = UserInfo.objects.filter(user_type__s__name=&#39;xx&#39;)

querset = UserInfo.objects.filter(user_type__caption=&#39;普通用户&#39;).values(&#39;user&#39;, &#39;user_type_caption&#39;)

</code></pre>
<blockquote>
<ul>
<li>1、搜索条件使用 __ 连接</li>
<li>2、获取值时使用 .    连接</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Note:</strong> 创建外键数据的时候, <code>UserInfo.objects.create(user=&#39;alex&#39;, pwd=&#39;123&#39;, user_type=UserType.objects.get(id=2))</code> ,这样插一条数据相当于要做两次数据库查询,这样不好对吧, 在Django数据库表中<code>ForignKey</code>字段其实<code>user_type_id</code>带指的就是<code>UserType</code>表的id字段,所以我们直接<code>UserInfo.objects.create(user=&#39;alex&#39;, pwd=&#39;123&#39;, user_type_id=2)</code>就可以了.</p>
</blockquote>
<p><code>其他操作</code></p>
<pre><code class="python"># F 使用查询条件的值
from django.db.models import F
models.Tb1.objects.update(num=F(&#39;num&#39;)+1)

# Q 构建搜索条件
from django.db.models import Q
con = Q()

q1 = Q()
q1.connector = &#39;OR&#39;
q1.children.append((&#39;id&#39;, 1))
q1.children.append((&#39;id&#39;, 10))
q1.children.append((&#39;id&#39;, 9))

q2 = Q()
q2.connector = &#39;OR&#39;
q2.children.append((&#39;c1&#39;, 1))
q2.children.append((&#39;c1&#39;, 10))
q2.children.append((&#39;c1&#39;, 9))

con.add(q1, &#39;AND&#39;)
con.add(q2, &#39;AND&#39;)

models.Tb1.objects.filter(con)

# SQL
from django.db import connection
cursor = connection.cursor()
cursor.execute(&quot;SELECT * from tb where name = %s&quot;, [&#39;Lennon&#39;])
row = cursor.fetchone()
</code></pre>
<p>4) 扩展</p>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><p>django中的Form一般有两种功能：</p>
<ul>
<li>验证用户输入</li>
<li>自动插入html表单</li>
</ul>
<p>Django<code>forms</code>模块提供表单验证,前端js只能做简单判断,最后还是都要到后端来处理,forms模块提供</p>
<hr>
<p><strong>1、验证用户输入</strong><br>前端Ajax发送表单内容到后端验证,后端验证后将结果返回给ajax,显示到页面上.</p>
<p><code>views:</code></p>
<pre><code class="python">from django.shortcuts import render, HttpResponse

# Create your views here.
import json
import re
from django import forms
from django.core.exceptions import ValidationError


# 自己写一个验证规则函数
def mobile_validate(value):
    mobile_re = re.compile(r&#39;^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$&#39;)  # 将正则表达式编译成对象,方法直接用这个正则去套结果
    if not mobile_re.match(value):
        raise ValidationError(&#39;手机号码格式错误&#39;)


# 写一个Form表单验证规则
class LoginForm(forms.Form):
    # 每个字段名要是前端form表单中的name数据值,一一对应,不然分辨不了,无法做验证.
    user = forms.CharField(required=True, error_messages={&#39;required&#39;: &#39;用户名不能为空&#39;})
    password = forms.CharField(required=True,
                               min_length=6,
                               max_length=12,
                               # 每个key对应一个触发条件,value则是消息
                               error_messages={&#39;required&#39;: &#39;密码不能为空&#39;, &#39;min_length&#39;: &#39;最少6位&#39;, &#39;max_length&#39;: &#39;最多12位&#39;})
    phone = forms.CharField(required=True,
                               validators=[mobile_validate, ],   # 指定验证器为自己定义的验证规则函数
                               error_messages={&#39;required&#39;: &#39;手机号不能为空&#39;})

    url = forms.URLField(required=True, error_messages={&#39;required&#39;: &#39;url不能为空&#39;,&#39;invalid&#39;: &#39;请输入url&#39;})

    email = forms.EmailField(required=True, error_messages={&#39;required&#39;: &#39;email不能为空&#39;, &#39;invalid&#39;: &#39;请输入邮箱格式&#39;})


def login(request):
    if request.method == &#39;POST&#39;:
        result = {&#39;status&#39;: False, &#39;message&#39;: None}
        obj = LoginForm(request.POST)  # 前端提交的POST请求数据是创建一个对象
        ret = obj.is_valid()   # 验证用户输入,只要有一个为空就是False
        if ret:
            print(obj.clean())   #返回字典对象
            result[&#39;status&#39;] = True
        else:
            result[&#39;status&#39;] = False
            print(type(obj.errors), obj.errors.as_json())  # 字典对象,转换成json格式
            error_str = obj.errors.as_json()
            result[&#39;message&#39;] = json.loads(error_str)
        return HttpResponse(json.dumps(result))

    return render(request, &#39;login.html&#39;)
</code></pre>
<p><code>templates:</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;login&lt;/title&gt;
    &lt;style&gt;
        .error-msg{
            color: red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div&gt;
        &lt;div&gt;
            &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;text&quot; name=&quot;phone&quot; /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;
        &lt;/div&gt;
        &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;DoSubmit();&quot; /&gt;
    &lt;/div&gt;

    &lt;script src=&quot;/static/js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function DoSubmit() {
            var input_dict = {};
            $(&#39;input&#39;).each(function () {
               var v = $(this).val();
                var n = $(this).attr(&#39;name&#39;);
                input_dict[n] = v;
            });
            console.log(input_dict);
            $(&#39;.error-msg&#39;).remove();  //在每次提交(验证)之前把之前的错误信息先删除掉
            $.ajax({
                url: &#39;/login/&#39;,
                type: &#39;POST&#39;,
                data: input_dict,
                dataType: &#39;json&#39;,
                success: function (result) {
                    console.log(result);
                    if(result.status){
                        location.href = &#39;/index/&#39;
                    }else {
                        $.each(result.message, function (k, v) {
                            console.log(k,v[0].message);
                            // &lt;span class=&quot;error-msg&quot;&gt;错误信息&lt;/span&gt;
                            var tag = document.createElement(&#39;span&#39;);
                            tag.className = &#39;error-msg&#39;;
                            tag.innerText = v[0].message;
                            // input[name=&quot;user&quot;]
                            $(&#39;input[name=&quot;&#39; + k + &#39;&quot;]&#39;).after(tag);
                        })
                    }
                },
                error: function () {

                }
            })
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<p><strong>2、自动插入html表单</strong><br>前端不用写html表单代码和js,ajax代码,只需要遵循django的模板语言编写对应的内容,就可以实现表单验证.</p>
<p><code>views:</code></p>
<pre><code class="python">from django.shortcuts import render, HttpResponse

# Create your views here.
import json
import re
from django import forms
from django.core.exceptions import ValidationError


# 自己写一个验证规则函数
def mobile_validate(value):
    mobile_re = re.compile(r&#39;^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$&#39;)  # 将正则表达式编译成对象,方法直接用这个正则去套结果
    if not mobile_re.match(value):
        raise ValidationError(&#39;手机号码格式错误&#39;)


# 写一个Form表单验证规则
class LoginForm(forms.Form):
    # 每个字段名要是前端form表单中的name数据值,一一对应,不然分辨不了,无法做验证.
    user = forms.CharField(required=True, error_messages={&#39;required&#39;: &#39;用户名不能为空&#39;})
    password = forms.CharField(required=True,
                               min_length=6,
                               max_length=12,
                               # 每个key对应一个触发条件,value则是消息
                               error_messages={&#39;required&#39;: &#39;密码不能为空&#39;, &#39;min_length&#39;: &#39;最少6位&#39;, &#39;max_length&#39;: &#39;最多12位&#39;})

    phone = forms.CharField(required=True,
                               validators=[mobile_validate, ],   # 指定验证器为自己定义的验证规则函数
                               error_messages={&#39;required&#39;: &#39;手机号不能为空&#39;})

    url = forms.URLField(required=True, error_messages={&#39;required&#39;: &#39;url不能为空&#39;, &#39;invalid&#39;: &#39;请输入url&#39;})

    email = forms.EmailField(required=True, error_messages={&#39;required&#39;: &#39;email不能为空&#39;, &#39;invalid&#39;: &#39;请输入邮箱格式&#39;})

    countries_choices = (
        (0, &#39;中国&#39;),
        (1, &#39;美国&#39;),
    )

    # widget添加小功能,froms.Select添加select标签
    countries = forms.IntegerField(widget=forms.Select(choices=countries_choices, attrs={&#39;test&#39;: &#39;国家&#39;}))
    # widget添加小功能,froms.Select添加Textarea标签
    note = forms.CharField(widget=forms.Textarea(attrs={&#39;class&#39;: &#39;note&#39;, &#39;test&#39;: &#39;消息&#39;}))


def login(request):
    if request.method == &#39;POST&#39;:
        # 用户Post传到后台的数据.创建的对象带用户得内容和html,这样用户不会每次点提交表格中的内容都要重新输入了
        objPost = LoginForm(request.POST)
        ret = objPost.is_valid()   # 验证用户输入,只要有一个为空就是False
        if ret:
            print(objPost.clean())   #返回字典对象
        else:
            # from django.forms.utils import ErrorDict;  objPost继承ErrorDict,继承了字典.
            for k,v in objPost.errors.items():
                print(k, v)

        return render(request, &#39;login.html&#39;, {&#39;obj&#39;: objPost})
    else:
        # 用户Get页面的时候,这个没参数,LoginForm默认只是给我生成了html标签
        objGet = LoginForm()
        return render(request, &#39;login.html&#39;, {&#39;obj&#39;: objGet})

</code></pre>
<p><code>templates:</code></p>
<p><img src="http://www.liangxiansen.cn/images/django/form_templates.png" alt="templates"></p>
<p><a href="http://www.liangxiansen.cn/source_code/django/login">点击下载源码</a></p>
<blockquote>
<p>自动插入html的这种方法前端不用写js代码,html和ajax代码,很大程度得减少了前端代码量,也可以避免js被用户摘掉,在前端看不到form表单验证方式,但是前端提交智能使用表单提交,不能用ajax;第一种就和常规的写法没什么却别,只是后端验证方面提供了一个模块,更方便了些,这两种方法都可以使用,在使用前根据利弊关系选择(我在栽跟头了,都用第二种方式写,后端逻辑都写完了,前端有个地方需要用ajax,结果那块地方重新用第一种方式写了遍.)</p>
</blockquote>
<hr>
<p><strong>3、扩展:ModelForm</strong></p>
<p>在使用Model和Form时,都需要对字段进行定义并定义类型,通过ModelFrom可以根据model中的定义省去From中字段的定义</p>
<pre><code class="python">class AdminModelForm(forms.ModelForm):

    class Meta:
        model = models.Admin
        #fields = &#39;__all__&#39;
        fields = (&#39;username&#39;, &#39;email&#39;)

        widgets = {
            &#39;email&#39; : forms.PasswordInput(attrs={&#39;class&#39;:&quot;alex&quot;}),
        }
</code></pre>
<blockquote>
<p>这种方式可能更简便,但是不利于解藕,与后端数据库绑定死了;如有数据库字段变更,那么前端提交数据对不上提交则会失败.</p>
</blockquote>
<h3 id="跨站请求-CSRF"><a href="#跨站请求-CSRF" class="headerlink" title="跨站请求(CSRF)"></a>跨站请求(CSRF)</h3><p>一、简介</p>
<p>django为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。</p>
<p>全局：<br>    <code>settings:</code><br>　　中间件 <code>django.middleware.csrf.CsrfViewMiddleware</code></p>
<p>局部：<br><code>装饰器:</code><br><code>@csrf_protect</code>，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。<br><code>@csrf_exempt</code>,取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。</p>
<blockquote>
<p>注：from django.views.decorators.csrf import csrf_exempt,csrf_protect</p>
</blockquote>
<p>二、应用</p>
<p>1、普通表单</p>
<p><img src="http://www.liangxiansen.cn/images/django/csrf.png" alt="CSRF"></p>
<blockquote>
<p>Note: views 中必须用render返回,如果用<code>HttpResponse</code>的话,那再次发POST请求的时候没有Token,会被拒绝连接.</p>
</blockquote>
<pre><code class="python">def csrf(request):

    return render(request, &#39;csrf.html&#39;)
</code></pre>
<p>2、Ajax</p>
<p>对于传统的form，可以通过表单的方式将token再次发送到服务端，而对于ajax的话，使用如下方式。</p>
<p><code>views:</code></p>
<pre><code class="python">def csrf(request):

    return render(request, &#39;csrf.html&#39;)
</code></pre>
<p><code>templates:</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;csrf&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;Ajax提交&quot; onclick=&quot;DoAjax();&quot; /&gt;

    &lt;script src=&quot;/static/js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/static/js/jquery.cookie.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 去cookie中获取值
        var csrftoken = $.cookie(&#39;csrftoken&#39;);

        function csrfSafeMethod(method) {
            // these HTTP methods do not require CSRF protection
            return (/^(GET|HEAD|OPTIONS|TRACE)$/).test(method);
        }

        // 写上这段代码,那么ajax请求都会带着这段代码执行,就不需要分别在每个ajax请求函数里面写token操作了
        $.ajaxSetup({
            beforeSend: function (xhr, settings) {
                if(!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) {
                    xhr.setRequestHeader(&quot;X-CSRFToken&quot;, csrftoken);
                }
            }
        });

        function DoAjax() {
            $.ajax({
                url: &#39;/csrf/&#39;,
                type: &#39;POST&#39;,
                data: {&#39;k1&#39;: &#39;v1&#39;},
                success: function (data) {
                    console.log(data);
                }
            })
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>更多：<a href="https://docs.djangoproject.com/en/dev/ref/csrf/#ajax" target="_blank" rel="noopener">https://docs.djangoproject.com/en/dev/ref/csrf/#ajax</a></p>
</blockquote>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>网站为了辨别用户身份而储存在用户本地终端上的数据,用户通过浏览器请求网站,网站返回用户信息之后,还会偷偷给用户塞给用户网站生成的一个身份证明,上面记录了用户的信息,下次用户来的时候带着这个网站就知道你是谁,就会”智能”得在页面上显示你是谁.登录了关闭浏览器再打开不用再重新登录.</p>
<p><strong>1、获取Cookie：</strong></p>
<pre><code>request.COOKIES[&#39;key&#39;]
request.get_signed_cookie(key, default=RAISE_ERROR, salt=&#39;&#39;, max_age=None)

    参数：
        default: 默认值
           salt: 加密盐
        max_age: 后台控制过期时间
</code></pre><p><strong>2、设置Cookie：</strong></p>
<pre><code>rep = HttpResponse(...) 或 rep ＝ render(request, ...)

rep.set_cookie(key,value,...)
rep.set_signed_cookie(key,value,salt=&#39;加密盐&#39;,...)
    参数：
        key,              键
        value=&#39;&#39;,         值
        max_age=None,     超时时间
        expires=None,     超时时间(IE requires expires, so set it if hasn&#39;t been already.)
        path=&#39;/&#39;,         Cookie生效的路径，/ 表示根路径(全局)，特殊的：根路径的cookie可以被任何url的页面访问
        domain=None,      Cookie生效的域名,只允许该域名的可以访问
        secure=False,     https传输
        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）
</code></pre><p>由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。</p>
<pre><code class="javascript">    &lt;script src=&#39;/static/js/jquery.cookie.js&#39;&gt;&lt;/script&gt;
    $.cookie(&quot;list_pager_num&quot;, 30,{ path: &#39;/&#39; });
</code></pre>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Django中默认支持Session，其内部提供了5种类型的Session供开发者使用：</p>
<blockquote>
<ul>
<li>数据库（默认）</li>
<li>缓存</li>
<li>文件</li>
<li>缓存 + 数据库</li>
<li>加密cookie</li>
</ul>
</blockquote>
<blockquote>
<p>Django的Sessio保存在数据库中,使用之前要记得初始化数据库<br><strong>1、数据库Session:</strong></p>
</blockquote>
<p>Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。</p>
<p>a. 配置 settings.py</p>
<pre><code>SESSION_ENGINE = &#39;django.contrib.sessions.backends.db&#39;   # 引擎（默认）

SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）
SESSION_COOKIE_PATH ＝ &quot;/&quot;                               # Session的cookie保存的路径（默认）
SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）
SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）
SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）
SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）
SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）
</code></pre><p>b. 使用</p>
<pre><code>def index(request):
    # 获取、设置、删除Session中数据
    request.session[&#39;k1&#39;]
    request.session.get(&#39;k1&#39;,None)
    request.session[&#39;k1&#39;] = 123
    request.session.setdefault(&#39;k1&#39;,123) # 存在则不设置
    del request.session[&#39;k1&#39;]

    # 所有 键、值、键值对
    request.session.keys()
    request.session.values()
    request.session.items()
    request.session.iterkeys()
    request.session.itervalues()
    request.session.iteritems()


    # 用户session的随机字符串
    request.session.session_key

    # 将所有Session失效日期小于当前日期的数据删除
    request.session.clear_expired()

    # 检查 用户session的随机字符串 在数据库中是否
    request.session.exists(&quot;session_key&quot;)

    # 删除当前用户的所有Session数据
    request.session.delete(&quot;session_key&quot;)

    ...
</code></pre><hr>
<p><strong>2、缓存Session:</strong></p>
<p>a. 配置 settings.py</p>
<pre><code>SESSION_ENGINE = &#39;django.contrib.sessions.backends.cache&#39;  # 引擎
SESSION_CACHE_ALIAS = &#39;default&#39;                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置

SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                        # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串
SESSION_COOKIE_PATH ＝ &quot;/&quot;                                # Session的cookie保存的路径
SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名
SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie
SESSION_COOKIE_HTTPONLY = True                            # 是否Session的cookie只支持http传输
SESSION_COOKIE_AGE = 1209600                              # Session的cookie失效日期（2周）
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   # 是否关闭浏览器使得Session过期
SESSION_SAVE_EVERY_REQUEST = False                        # 是否每次请求都保存Session，默认修改之后才保存
</code></pre><p>b. 使用</p>
<pre><code>同上
</code></pre><hr>
<p><strong>3、文件Session:</strong></p>
<p>a. 配置 settings.py</p>
<pre><code>SESSION_ENGINE = &#39;django.contrib.sessions.backends.file&#39;    # 引擎
SESSION_FILE_PATH = None                                    # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                                             # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T


SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                          # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串
SESSION_COOKIE_PATH ＝ &quot;/&quot;                                  # Session的cookie保存的路径
SESSION_COOKIE_DOMAIN = None                                # Session的cookie保存的域名
SESSION_COOKIE_SECURE = False                               # 是否Https传输cookie
SESSION_COOKIE_HTTPONLY = True                              # 是否Session的cookie只支持http传输
SESSION_COOKIE_AGE = 1209600                                # Session的cookie失效日期（2周）
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                     # 是否关闭浏览器使得Session过期
SESSION_SAVE_EVERY_REQUEST = False                          # 是否每次请求都保存Session，默认修改之后才保存
</code></pre><p>b. 使用</p>
<pre><code>同上
</code></pre><hr>
<p><strong>4、缓存+数据库Session:</strong></p>
<p>数据库用于做持久化，缓存用于提高效率</p>
<p>a. 配置 settings.py</p>
<pre><code>SESSION_ENGINE = &#39;django.contrib.sessions.backends.cached_db&#39;        # 引擎
</code></pre><p>b. 使用</p>
<pre><code>同上
</code></pre><hr>
<p><strong>5、加密cookie Session:</strong></p>
<p>a. 配置 settings.py</p>
<pre><code>SESSION_ENGINE = &#39;django.contrib.sessions.backends.signed_cookies&#39;   # 引擎
</code></pre><p>b. 使用</p>
<pre><code>同上
</code></pre><p>更多参考：<a href="https://docs.djangoproject.com/en/1.9/ref/settings/#settings-sessions" target="_blank" rel="noopener">猛击这里</a> <a href="https://docs.djangoproject.com/en/1.9/topics/http/sessions/" target="_blank" rel="noopener">设置session</a></p>
<p><strong>扩展：Session用户验证</strong></p>
<pre><code class="python">def login(func):
    def wrap(request, *args, **kwargs):
        # 如果未登陆，跳转到指定页面
        if request.path == &#39;/test/&#39;:
            return redirect(&#39;http://www.baidu.com&#39;)
        return func(request, *args, **kwargs)
    return wrap
</code></pre>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>1、Django内置分页</p>
<pre><code>Paginator
</code></pre><p>2、自定义分页</p>
<p>分页功能在每个网站都是必要的，对于分页来说，其实就是根据用户的输入计算出应该在数据库表中的起始位置。</p>
<p>1、设定每页显示数据条数</p>
<p>2、用户输入页码（第一页、第二页…）</p>
<p>3、根据设定的每页显示条数和当前页码，计算出需要取数据表的起始位置</p>
<p>4、在数据表中根据起始位置取值，页面上输出数据</p>
<hr>
<p>需求又来了，需要在页面上显示分页的页面。如：［上一页］［1］［2］［3］［4］［5］［下一页］<br>1、设定每页显示数据条数</p>
<p>2、用户输入页码（第一页、第二页…）</p>
<p>3、设定显示多少页号</p>
<p>4、获取当前数据总条数</p>
<p>5、根据设定显示多少页号和数据总条数计算出，总页数</p>
<p>6、根据设定的每页显示条数和当前页码，计算出需要取数据表的起始位置</p>
<p>7、在数据表中根据起始位置取值，页面上输出数据</p>
<p>8、输出分页html，如：［上一页］［1］［2］［3］［4］［5］［下一页］</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ajax 学习]]></title>
      <url>http://www.liangxiansen.cn/2016/09/04/Ajax/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于WEB应用程序：用户浏览器发送请求，服务器接收并处理请求，然后返回结果，往往返回就是字符串（HTML），浏览器将字符串（HTML）<code>渲染</code>并显示浏览器上。</p>
<a id="more"></a>
<p>1、 传统的Web应用</p>
<blockquote>
<p>一个页面上的简单操作就需把整个页面重新加载一遍</p>
</blockquote>
<p>2、 AJAX</p>
<blockquote>
<p>AJAX，Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。</p>
</blockquote>
<blockquote>
<ul>
<li><code>异步的JavaScript：</code></li>
</ul>
</blockquote>
<blockquote>
<p>使用 【JavaScript语言】 以及 相关【浏览器提供类库】 的功能向服务端发送请求，当服务端处理完请求之后，【自动执行某个JavaScript的回调函数】。<br>PS：以上请求和响应的整个过程是【偷偷】进行的，页面上无任何感知(页面不会刷新)。</p>
</blockquote>
<blockquote>
<ul>
<li><code>XML:</code></li>
</ul>
</blockquote>
<blockquote>
<p>XML是一种标记语言，是Ajax在和后台交互时传输数据的格式之一</p>
</blockquote>
<blockquote>
<p>利用AJAX可以做：</p>
<ul>
<li>1、注册时，输入用户名自动检测用户是否已经存在。</li>
<li>2、登陆时，提示用户名密码错误</li>
<li>3、删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。（博客园）</li>
</ul>
</blockquote>
<h3 id="‘伪’AJAX"><a href="#‘伪’AJAX" class="headerlink" title="‘伪’AJAX"></a>‘伪’AJAX</h3><p>由于HTML标签的<code>iframe</code>标签具有局部加载内容的特性，所以可以使用其来<code>伪造</code>Ajax请求。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head lang=&quot;en&quot;&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;

        &lt;div&gt;
            &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;
            &lt;p&gt;
                &lt;input id=&quot;url&quot; type=&quot;text&quot; /&gt;
                &lt;input type=&quot;button&quot; value=&quot;刷新&quot; onclick=&quot;LoadPage();&quot;&gt;
            &lt;/p&gt;
        &lt;/div&gt;


        &lt;div&gt;
            &lt;h3&gt;加载页面位置：&lt;/h3&gt;
            &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 800px;&quot;&gt;&lt;/iframe&gt;
        &lt;/div&gt;


        &lt;script type=&quot;text/javascript&quot;&gt;
            // 页面刚刚加载完得时候执行
            window.onload= function(){
                var myDate = new Date();   // 获取当前时间,通过new关键字创建时间对象
                document.getElementById(&#39;currentTime&#39;).innerText = myDate.getTime();

            };

            function LoadPage(){
                var targetUrl =  document.getElementById(&#39;url&#39;).value;
                document.getElementById(&quot;iframePosition&quot;).src = targetUrl;
            }

        &lt;/script&gt;

    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="原生AJAX"><a href="#原生AJAX" class="headerlink" title="原生AJAX"></a>原生AJAX</h2><p>Ajax主要就是使用 <code>【XmlHttpRequest】</code>对象来完成请求的操作，该对象在主流浏览器中均存在(除早起的IE)，Ajax首次出现IE5.5中存在（ActiveX控件）。</p>
<h3 id="XmlHttpRequest对象介绍"><a href="#XmlHttpRequest对象介绍" class="headerlink" title="XmlHttpRequest对象介绍"></a>XmlHttpRequest对象介绍</h3><p>XmlHttpRequest对象的主要方法：</p>
<pre><code>a. void open(String method,String url,Boolen async)
   用于创建请求

   参数：
       method： 请求方式（字符串类型），如：POST、GET、DELETE...
       url：    要请求的地址（字符串类型）
       async：  是否异步（布尔类型）

b. void send(String body)
    用于发送请求

    参数：
        body： 要发送的数据（字符串类型）

c. void setRequestHeader(String header,String value)
    用于设置请求头

    参数：
        header： 请求头的key（字符串类型）
        vlaue：  请求头的value（字符串类型）

d. String getAllResponseHeaders()
    获取所有响应头

    返回值：
        响应头数据（字符串类型）

e. String getResponseHeader(String header)
    获取响应头中指定header的值

    参数：
        header： 响应头的key（字符串类型）

    返回值：
        响应头中指定的header对应的值

f. void abort()

    终止请求
</code></pre><p>XmlHttpRequest对象的主要属性：</p>
<pre><code>a. Number readyState
   状态值（整数）

   详细：
      0-未初始化，尚未调用open()方法；
      1-启动，调用了open()方法，未调用send()方法；
      2-发送，已经调用了send()方法，未接收到响应；
      3-接收，已经接收到部分响应数据；
      4-完成，已经接收到全部响应数据；

b. Function onreadystatechange
   当readyState的值改变时自动触发执行其对应的函数（回调函数）

c. String responseText
   服务器返回的数据（字符串类型）

d. XmlDocument responseXML
   服务器返回的数据（Xml对象）

e. Number states
   状态码（整数），如：200、404...

f. String statesText
   状态文本（字符串），如：OK、NotFound...
</code></pre><h3 id="跨浏览器支持"><a href="#跨浏览器支持" class="headerlink" title="跨浏览器支持"></a>跨浏览器支持</h3><ul>
<li><code>XmlHttpRequest:</code></li>
</ul>
<p>IE7+, Firefox, Chrome, Opera, etc.</p>
<ul>
<li><code>ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</code></li>
</ul>
<p>IE6, IE5</p>
<h3 id="基于原生AJAX-Demo"><a href="#基于原生AJAX-Demo" class="headerlink" title="基于原生AJAX - Demo"></a>基于原生AJAX - Demo</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;h1&gt;XMLHttpRequest - Ajax请求&lt;/h1&gt;
    &lt;input type=&quot;button&quot; onclick=&quot;XmlGetRequest();&quot; value=&quot;Get发送请求&quot; /&gt;
    &lt;input type=&quot;button&quot; onclick=&quot;XmlPostRequest();&quot; value=&quot;Post发送请求&quot; /&gt;

    &lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;

        function GetXHR(){
            var xhr = null;
            if(XMLHttpRequest){
                xhr = new XMLHttpRequest();
            }else{
                xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
            }
            return xhr;

        }

        function XhrPostRequest(){
            var xhr = GetXHR();
            // 定义回调函数
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    // 已经接收到全部响应数据，执行以下操作
                    var data = xhr.responseText;
                    console.log(data);
                }
            };
            // 指定连接方式和地址----文件方式
            xhr.open(&#39;POST&#39;, &quot;/test/&quot;, true);
            // 设置请求头
            xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded; charset-UTF-8&#39;);
            // 发送请求
            xhr.send(&#39;n1=1;n2=2;&#39;);
        }

        function XhrGetRequest(){
            var xhr = GetXHR();
            // 定义回调函数
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    // 已经接收到全部响应数据，执行以下操作
                    var data = xhr.responseText;
                    console.log(data);
                }
            };
            // 指定连接方式和地址----文件方式
            xhr.open(&#39;get&#39;, &quot;/test/&quot;, true);
            // 发送请求
            xhr.send();
        }

    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="jQuery-Ajax"><a href="#jQuery-Ajax" class="headerlink" title="jQuery Ajax"></a>jQuery Ajax</h2><p><code>jQuery</code>其实就是一个<code>JavaScript</code>的<code>类库</code>，其将复杂的功能做了上层封装，使得开发者可以在其基础上写更少的代码实现更多的功能。</p>
<ul>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质 XMLHttpRequest 或 ActiveXObject</li>
</ul>
<p><em>注：2.+版本不再支持IE9以下的浏览器</em></p>
<h3 id="jQuery-Ajax-方法"><a href="#jQuery-Ajax-方法" class="headerlink" title="jQuery Ajax 方法"></a>jQuery Ajax 方法</h3><pre><code class="jquery">    jQuery.get(...)
    所有参数：
         url: 待载入页面的URL地址
        data: 待发送 Key/value 参数。
     success: 载入成功时回调函数。
    dataType: 返回内容格式，xml, json,  script, text, html


    jQuery.post(...)
        所有参数：
             url: 待载入页面的URL地址
            data: 待发送 Key/value 参数
         success: 载入成功时回调函数
        dataType: 返回内容格式，xml, json,  script, text, html


    jQuery.getJSON(...)
        所有参数：
             url: 待载入页面的URL地址
            data: 待发送 Key/value 参数。
         success: 载入成功时回调函数。


    jQuery.getScript(...)
        所有参数：
             url: 待载入页面的URL地址
            data: 待发送 Key/value 参数。
         success: 载入成功时回调函数。


    jQuery.ajax(...)

        部分参数：

            url：请求地址
           type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
           data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）

     beforeSend：发送请求前执行的函数(全局)
       complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)


        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
       dataType：将服务器端返回的数据转换成指定类型
                       &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
                      &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
                      &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
                    &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
                      &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
                     &quot;jsonp&quot;: JSONP 格式
                              使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
                              如果不指定，jQuery 将自动根据HTTP包MIME信息返回相应类型(an XML MIME type will yield XML, in 1.4 JSON will yield a JavaScript object, in 1.4 script willexecute the script, and anything else will be returned as a string)

     converters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数
                     $.ajax({
                          accepts: {
                            mycustomtype: &#39;application/x-some-custom-type&#39;
                          },

                          // Expect a `mycustomtype` back from server
                          dataType: &#39;mycustomtype&#39;

                          // Instructions for how to deserialize a `mycustomtype`
                          converters: {
                            &#39;text mycustomtype&#39;: function(result) {
                              // Do Stuff
                              return newresult;
                            }
                          },
                        });
</code></pre>
<h3 id="基于jQuery-Ajax-Demo"><a href="#基于jQuery-Ajax-Demo" class="headerlink" title="基于jQuery Ajax - Demo"></a>基于jQuery Ajax - Demo</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;p&gt;
        &lt;input type=&quot;button&quot; onclick=&quot;JqSendRequest();&quot; value=&#39;Ajax请求&#39; /&gt;
    &lt;/p&gt;


    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;

        function JqSendRequest(){
            $.ajax({
                url: &quot;http://c2.com:8000/test/&quot;,
                type: &#39;GET&#39;,
                dataType: &#39;text&#39;,
                success: function(data, statusText, xmlHttpRequest){
                    console.log(data);
                }
            })
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="跨域Ajax"><a href="#跨域Ajax" class="headerlink" title="跨域Ajax"></a>跨域Ajax</h2><p>由于浏览器存在同源策略机制，同源策略阻止从一个源加载的文档或脚本获取或设置另一个源加载的文档的属性。</p>
<p>特别的：由于同源策略是浏览器的限制，所以请求的发送和响应是可以进行，只不过浏览器不接受罢了。</p>
<p>浏览器同源策略并不是对所有的请求均制约：</p>
<ul>
<li>制约： XmlHttpRequest</li>
<li>不叼： img、iframe、script等具有src属性的标签</li>
</ul>
<p><em>跨域，跨域名访问，如：<a href="http://www.c1.com" target="_blank" rel="noopener">http://www.c1.com</a> 域名向 <a href="http://www.c2.com域名发送请求。" target="_blank" rel="noopener">http://www.c2.com域名发送请求。</a></em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Web框架]]></title>
      <url>http://www.liangxiansen.cn/2016/09/04/web/</url>
      <content type="html"><![CDATA[<h3 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h3><p>众所周知，对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。</p>
<pre><code class="python">import socket

def handle_request(client):
    buf = client.recv(1024)
    client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)
    client.send(&quot;Hello, Seven&quot;)

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((&#39;localhost&#39;,8000))
    sock.listen(5)

    while True:
        connection, address = sock.accept()
        handle_request(connection)
        connection.close()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<a id="more"></a>
<p>上述通过socket来实现了其本质，而对于真实开发中的python web程序来说，一般会分为两部分：<code>服务器程序</code>和<code>应用程序</code>。服务器程序负责对socket服务器进行<code>封装</code>，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：<code>Django、Flask、web.py</code> 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。</p>
<p><code>WSGI（Web Server Gateway Interface）</code>是一种规范，它定义了使用python编写的<code>web app</code>与<code>web server</code>之间接口格式，实现web app与web server间的<code>解耦</code>。</p>
<p>python标准库提供的独立WSGI服务器称为wsgiref。</p>
<pre><code class="python">from wsgiref.simple_server import make_server

def RunServer(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    return &#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;

if __name__ == &#39;__main__&#39;:
    httpd = make_server(&#39;&#39;, 8000, RunServer)
    print(&quot;Serving HTTP on port 8000...&quot;)
    httpd.serve_forever()
</code></pre>
<h3 id="自定义Web框架"><a href="#自定义Web框架" class="headerlink" title="自定义Web框架"></a>自定义Web框架</h3><p>一、框架<br>通过python标准库提供的wsgiref模块开发一个自己的Web框架</p>
<pre><code class="python">from wsgiref.simple_server import make_server

def index():
    return &#39;index&#39;

def login():
    return &#39;login&#39;

def routers():
    # 路由系统,相应得路径对应对应的响应函数
    urlpatterns = (
        (&#39;/index/&#39;, index),
        (&#39;/login/&#39;, login),
    )

    return urlpatterns

def RunServer(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    url = environ[&#39;PATH_INFO&#39;]
    urlpatterns = routers()
    func = None
    for item in urlpatterns:
        if item[0] == url:
            func = item[1]
            break
    if func:
        return func()
    else:
        return &#39;404 not found&#39;

if __name__ == &#39;__main__&#39;:
    httpd = make_server(&#39;127.0.0.1&#39;, 8000, RunServer)
    print(&quot;Serving HTTP on port 8000...&quot;)
    httpd.serve_forever()
</code></pre>
<h3 id="模板引擎-templates"><a href="#模板引擎-templates" class="headerlink" title="模板引擎(templates)"></a>模板引擎(templates)</h3><p>在上一步骤中，对于所有的login、index均返回给用户浏览器一个简单的字符串，在现实的Web请求中一般会返回一个复杂的符合HTML规则的字符串，所以我们一般将要返回给用户的HTML写在指定文件中，然后再返回。如：</p>
<p><code>index.html</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Index&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>login.html</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        &lt;input type=&quot;text&quot; /&gt;
        &lt;input type=&quot;text&quot; /&gt;
        &lt;input type=&quot;submit&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="python">from wsgiref.simple_server import make_server


def index():
    # return &#39;index&#39;
    f = open(&#39;index.html&#39;)
    data = f.read()
    return data


def login():
    # return &#39;login&#39;
    f = open(&#39;login.html&#39;)
    data = f.read()
    return data


def routers():

    urlpatterns = (
        (&#39;/index/&#39;, index),
        (&#39;/login/&#39;, login),
    )

    return urlpatterns


def run_server(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    url = environ[&#39;PATH_INFO&#39;]
    urlpatterns = routers()
    func = None
    for item in urlpatterns:
        if item[0] == url:
            func = item[1]
            break
    if func:
        return func()
    else:
        return &#39;404 not found&#39;


if __name__ == &#39;__main__&#39;:
    httpd = make_server(&#39;127.0.0.1&#39;, 8000, run_server)
    print(&quot;Serving HTTP on port 8000...&quot;)
    httpd.serve_forever()
</code></pre>
<p>对于上述代码，虽然可以返回给用户HTML的内容以现实复杂的页面，但是还是存在问题：<code>如何给用户返回动态内容？</code></p>
<ul>
<li>自定义一套特殊的语法，进行替换</li>
<li>使用开源工具jinja2，遵循其指定语法</li>
</ul>
<p><code>index.html</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;

    &lt;ul&gt;
        {% for item in user_list %}
        <li>{{item}}</li>
        {% endfor %}
    &lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="python">from wsgiref.simple_server import make_server
from jinja2 import Template


def index():
    # return &#39;index&#39;

    # template = Template(&#39;Hello {{ name }}!&#39;)
    # result = template.render(name=&#39;John Doe&#39;)

    f = open(&#39;index.html&#39;)
    result = f.read()
    template = Template(result)
    data = template.render(name=&#39;John Doe&#39;, user_list=[&#39;alex&#39;, &#39;eric&#39;])
    return data.encode(&#39;utf-8&#39;)


def login():
    # return &#39;login&#39;
    f = open(&#39;login.html&#39;)
    data = f.read()
    return data


def routers():

    urlpatterns = (
        (&#39;/index/&#39;, index),
        (&#39;/login/&#39;, login),
    )

    return urlpatterns


def run_server(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    url = environ[&#39;PATH_INFO&#39;]
    urlpatterns = routers()
    func = None
    for item in urlpatterns:
        if item[0] == url:
            func = item[1]
            break
    if func:
        return func()
    else:
        return &#39;404 not found&#39;


if __name__ == &#39;__main__&#39;:
    httpd = make_server(&#39;127.0.0.1&#39;, 8000, run_server)
    print(&quot;Serving HTTP on port 8000...&quot;)
    httpd.serve_forever()
</code></pre>
<p>遵循jinja2的语法规则，其内部会对指定的语法进行相应的替换，从而达到动态的返回内容，对于模板引擎的本质，参考另外一篇博客：<a href="http://www.www.cnblogs.com/wupeiqi/p/4592637.html" target="_blank" rel="noopener">白话tornado源码之褪去模板外衣的前戏</a></p>
<h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><blockquote>
<p>武沛齐 : <a href="http://www.cnblogs.com/wupeiqi/articles/5237672.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5237672.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DOM 操作]]></title>
      <url>http://www.liangxiansen.cn/2016/09/02/DOM/</url>
      <content type="html"><![CDATA[<p><code>文档对象模型</code>（Document Object Model，DOM）是一种用于HTML和XML文档的编程接口。它给文档提供了一种结构化的表示方法，可以改变文档的内容和呈现方式。我们最为关心的是，DOM把网页和脚本以及其他的编程语言联系了起来。DOM属于浏览器，而不是JavaScript语言规范里的规定的核心内容。</p>
<a id="more"></a>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><pre><code>document.getElementById             根据ID获取一个标签
document.getElementsByName          根据name属性获取标签集合
document.getElementsByClassName     根据class属性获取标签集合
document.getElementsByTagName       根据标签名获取标签集合
</code></pre><h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><pre><code>parentNode                  父节点
childNodes                  所有子节点
firstChild                  第一个子节点
lastChild                   最后一个子节点
nextSibling                 下一个兄弟节点
previousSibling             上一个兄弟节点

parentElement               父节点标签元素
children                    所有子标签
firstElementChild           第一个子标签元素
lastElementChild            最后一个子标签元素
nextElementtSibling         下一个兄弟标签元素
previousElementSibling      上一个兄弟标签元素
</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><pre><code>innerText   文本
outerText
innerHTML   HTML内容
innerHTML
value       值
</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>attributes                // 获取所有标签属性
setAttribute(key,value)   // 设置标签属性
getAttribute(key)         // 获取指定标签属性

/*
var atr = document.createAttribute(&quot;class&quot;);
atr.nodeValue=&quot;democlass&quot;;
document.getElementById(&#39;n1&#39;).setAttributeNode(atr);
*/
</code></pre><p><code>批量操作示例</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;全选&quot;  onclick=&quot;CheckAll();&quot;/&gt;
    &lt;input type=&quot;button&quot; value=&quot;取消&quot; onclick=&quot;CancelAll();&quot;/&gt;
    &lt;input type=&quot;button&quot; value=&quot;反选&quot; onclick=&quot;ReverseCheck();&quot;/&gt;

    &lt;table border=&quot;1&quot; &gt;
        &lt;thead&gt;

        &lt;/thead&gt;
        &lt;tbody id=&quot;tb&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;
                &lt;td&gt;111&lt;/td&gt;
                &lt;td&gt;222&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;
                &lt;td&gt;111&lt;/td&gt;
                &lt;td&gt;222&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;
                &lt;td&gt;111&lt;/td&gt;
                &lt;td&gt;222&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;
                &lt;td&gt;111&lt;/td&gt;
                &lt;td&gt;222&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;script&gt;
        function CheckAll(ths){
            var tb = document.getElementById(&#39;tb&#39;);
            var trs = tb.childNodes;
            for(var i =0; i&lt;trs.length; i++){

                var current_tr = trs[i];
                if(current_tr.nodeType==1){
                    var inp = current_tr.firstElementChild.getElementsByTagName(&#39;input&#39;)[0];
                    inp.checked = true;
                }
            }
        }

        function CancelAll(ths){
            var tb = document.getElementById(&#39;tb&#39;);
            var trs = tb.childNodes;
            for(var i =0; i&lt;trs.length; i++){

                var current_tr = trs[i];
                if(current_tr.nodeType==1){
                    var inp = current_tr.firstElementChild.getElementsByTagName(&#39;input&#39;)[0];
                    inp.checked = false;
                }
            }
        }

        function ReverseCheck(ths){
            var tb = document.getElementById(&#39;tb&#39;);
            var trs = tb.childNodes;
            for(var i =0; i&lt;trs.length; i++){
                var current_tr = trs[i];
                if(current_tr.nodeType==1){
                    var inp = current_tr.firstElementChild.getElementsByTagName(&#39;input&#39;)[0];
                    if(inp.checked){
                        inp.checked = false;
                    }else{
                        inp.checked = true;
                    }
                }
            }
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="class操作"><a href="#class操作" class="headerlink" title="class操作"></a>class操作</h3><pre><code>className                // 获取所有类名
classList.remove(cls)    // 删除指定类
classList.add(cls)       // 添加类
</code></pre><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><p>1) 创建标签</p>
<pre><code>// 方式一
var tag = document.createElement(&#39;a&#39;)
tag.innerText = &quot;wupeiqi&quot;
tag.className = &quot;c1&quot;
tag.href = &quot;http://www.cnblogs.com/wupeiqi&quot;

// 方式二
var tag = &quot;&lt;a class=&#39;c1&#39; href=&#39;http://www.cnblogs.com/wupeiqi&#39;&gt;wupeiqi&lt;/a&gt;&quot;
</code></pre><p>2) 操作标签</p>
<pre><code>// 方式一
var obj = &quot;&lt;input type=&#39;text&#39; /&gt;&quot;;
xxx.insertAdjacentHTML(&quot;beforeEnd&quot;,obj);
xxx.insertAdjacentElement(&#39;afterBegin&#39;,document.createElement(&#39;p&#39;))

//注意：第一个参数只能是&#39;beforeBegin&#39;、 &#39;afterBegin&#39;、 &#39;beforeEnd&#39;、 &#39;afterEnd&#39;

// 方式二
var tag = document.createElement(&#39;a&#39;)
xxx.appendChild(tag)
xxx.insertBefore(tag,xxx[1])
</code></pre><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><pre><code>var obj = document.getElementById(&#39;i1&#39;)

obj.style.fontSize = &quot;32px&quot;;
obj.style.backgroundColor = &quot;red&quot;;
</code></pre><p><code>输入框默认文字示例</code></p>
<pre><code class="html">    &lt;input onfocus=&quot;Focus(this);&quot; onblur=&quot;Blur(this);&quot; id=&quot;search&quot; value=&quot;请输入关键字&quot; style=&quot;color: gray;&quot; /&gt;

    &lt;script&gt;
        function Focus(ths){
            ths.style.color = &quot;black&quot;;
            if(ths.value == &#39;请输入关键字&#39; || ths.value.trim() == &quot;&quot;){

                ths.value = &quot;&quot;;
            }
        }

        function Blur(ths){
            if(ths.value.trim() == &quot;&quot;){
                ths.value = &#39;请输入关键字&#39;;
                ths.style.color = &#39;gray&#39;;
            }else{
                ths.style.color = &quot;black&quot;;
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><pre><code>总文档高度
document.documentElement.offsetHeight

当前文档占屏幕高度
document.documentElement.clientHeight

自身高度
tag.offsetHeight

距离上级定位高度
tag.offsetTop

父定位标签
tag.offsetParent

滚动高度
tag.scrollTop

/*
    clientHeight -&gt; 可见区域：height + padding
    clientTop    -&gt; border高度
    offsetHeight -&gt; 可见区域：height + padding + border
    offsetTop    -&gt; 上级定位标签的高度
    scrollHeight -&gt; 全文高：height + padding
    scrollTop    -&gt; 滚动高度
    特别的：
        document.documentElement代指文档根节点
*/
</code></pre><p><code>滚动菜单</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;

        body{
            margin: 0px;
        }
        img {
            border: 0;
        }
        ul{
            padding: 0;
            margin: 0;
            list-style: none;
        }
        .clearfix:after {
            content: &quot;.&quot;;
            display: block;
            height: 0;
            clear: both;
            visibility: hidden;
        }

        .wrap{
            width: 980px;
            margin: 0 auto;
        }

        .pg-header{
            background-color: #303a40;
            -webkit-box-shadow: 0 2px 5px rgba(0,0,0,.2);
            -moz-box-shadow: 0 2px 5px rgba(0,0,0,.2);
            box-shadow: 0 2px 5px rgba(0,0,0,.2);
        }
        .pg-header .logo{
            float: left;
            padding:5px 10px 5px 0px;
        }
        .pg-header .logo img{
            vertical-align: middle;
            width: 110px;
            height: 40px;

        }
        .pg-header .nav{
            line-height: 50px;
        }
        .pg-header .nav ul li{
            float: left;
        }
        .pg-header .nav ul li a{
            display: block;
            color: #ccc;
            padding: 0 20px;
            text-decoration: none;
            font-size: 14px;
        }
        .pg-header .nav ul li a:hover{
            color: #fff;
            background-color: #425a66;
        }
        .pg-body{

        }
        .pg-body .catalog{
            position: absolute;
            top:60px;
            width: 200px;
            background-color: #fafafa;
            bottom: 0px;
        }
        .pg-body .catalog.fixed{
            position: fixed;
            top:10px;
        }

        .pg-body .catalog .catalog-item.active{
            color: #fff;
            background-color: #425a66;
        }

        .pg-body .content{
            position: absolute;
            top:60px;
            width: 700px;
            margin-left: 210px;
            background-color: #fafafa;
            overflow: auto;
        }
        .pg-body .content .section{
            height: 500px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class=&quot;pg-header&quot;&gt;
        &lt;div class=&quot;wrap clearfix&quot;&gt;
            &lt;div class=&quot;logo&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;
                    &lt;img src=&quot;&quot;&gt;
                &lt;/a&gt;
            &lt;/div&gt;
            &lt;div class=&quot;nav&quot;&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a  href=&quot;#&quot;&gt;首页&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a  href=&quot;#&quot;&gt;功能一&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a  href=&quot;#&quot;&gt;功能二&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;pg-body&quot;&gt;
        &lt;div class=&quot;wrap&quot;&gt;
            &lt;div class=&quot;catalog&quot;&gt;
                &lt;div class=&quot;catalog-item&quot; auto-to=&quot;function1&quot;&gt;&lt;a&gt;第1张&lt;/a&gt;&lt;/div&gt;
                &lt;div class=&quot;catalog-item&quot; auto-to=&quot;function2&quot;&gt;&lt;a&gt;第2张&lt;/a&gt;&lt;/div&gt;
                &lt;div class=&quot;catalog-item&quot; auto-to=&quot;function3&quot;&gt;&lt;a&gt;第3张&lt;/a&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;content&quot;&gt;
                &lt;div menu=&quot;function1&quot; class=&quot;section&quot; style=&#39;background-color:green;&#39;&gt;
                    &lt;h1&gt;第一章&lt;/h1&gt;
                &lt;/div&gt;
                &lt;div menu=&quot;function2&quot; class=&quot;section&quot; style=&#39;background-color:yellow;&#39;&gt;
                    &lt;h1&gt;第二章&lt;/h1&gt;
                &lt;/div&gt;
                &lt;div menu=&quot;function3&quot; class=&quot;section&quot; style=&#39;background-color:red;&#39;&gt;
                    &lt;h1&gt;第三章&lt;/h1&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;

        $(function(){
            // 自动执行
            Init();
        });


        function Init(){


            $(window).scroll(function() {
                // 监听窗口滚动事件


                // 获取滚动条高度
                var scrollTop = $(window).scrollTop();


                // 当滚动到50像素时，左侧带菜单固定
                if(scrollTop &gt; 50){
                    $(&#39;.catalog&#39;).addClass(&#39;fixed&#39;);
                }else{
                    $(&#39;.catalog&#39;).children().removeClass(&#39;active&#39;);
                    $(&#39;.catalog&#39;).removeClass(&#39;fixed&#39;);
                }

                // 循环所有的内容
                $(&#39;.content&#39;).children().each(function(){
                    // 当前标签距离顶部高度
                    var offSet = $(this).offset(); // 高度，左边有多远
                    // offSet.top
                    // offSet.left

                    // 自身高度
                    var height = $(this).height();

                    //offSet&lt;滚动高度&lt;offSet+height


                    // 当前内容位于用户阅览区
                    if(scrollTop&gt;offSet.top &amp;&amp; scrollTop&lt; offSet.top + height){
                        // $(this) 当前内容标签
                        /*
                        var target = $(this).attr(&#39;menu&#39;);
                        $(&#39;.catalog&#39;).find(&#39;div[auto-to=&quot;&#39;+target+&#39;&quot;]&#39;).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;);
                        return false;
                        */

                        var docHeight = $(document).height();
                        var winHeight = $(window).height();
                        // 如果，滚轮到达底部，则显示最后一个菜单
                        if(docHeight == winHeight+scrollTop)
                        {
                            $(&#39;.catalog&#39;).find(&#39;div:last-child&#39;).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;);
                        }else{
                            var target = $(this).attr(&#39;menu&#39;);
                            $(&#39;.catalog&#39;).find(&#39;div[auto-to=&quot;&#39;+target+&#39;&quot;]&#39;).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;);
                        }
                        return false;

                    }
                });

            });


        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><pre><code>document.geElementById(&#39;form&#39;).submit()
</code></pre><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><pre><code>console.log                 输出框
alert                       弹出框
confirm                     确认框

// URL和刷新
location.href               获取URL
location.href = &quot;url&quot;       重定向
location.reload()           重新加载

// 定时器
setInterval                 多次定时器
clearInterval               清除多次定时器
setTimeout                  单次定时器
clearTimeout                清除单次定时器
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><img src="http://www.liangxiansen.cn/images/前端/DOM事件.png" alt="DOM事件"></p>
<p>对于事件需要注意的要点：</p>
<ul>
<li>this</li>
<li>event</li>
<li>事件链以及跳出<br>this标签当前正在操作的标签，event封装了当前事件的内容。</li>
</ul>
<h3 id="操作案例"><a href="#操作案例" class="headerlink" title="操作案例"></a>操作案例</h3><p><code>搜索框</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&#39;utf-8&#39; /&gt;
        &lt;title&gt;&lt;/title&gt;

        &lt;style&gt;
            .gray{
                color:gray;
            }
            .black{
                color:black;
            }
        &lt;/style&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function Enter(){
               var id= document.getElementById(&quot;tip&quot;)
               id.className = &#39;black&#39;;
               if(id.value==&#39;请输入关键字&#39;||id.value.trim()==&#39;&#39;){
                    id.value = &#39;&#39;
               }
            }
            function Leave(){
                var id= document.getElementById(&quot;tip&quot;)
                var val = id.value;
                if(val.length==0||id.value.trim()==&#39;&#39;){
                    id.value = &#39;请输入关键字&#39;
                    id.className = &#39;gray&#39;;
                }else{
                    id.className = &#39;black&#39;;
                }
            }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&#39;text&#39; class=&#39;gray&#39; id=&#39;tip&#39; value=&#39;请输入关键字&#39; onfocus=&#39;Enter();&#39;  onblur=&#39;Leave();&#39;/&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>跑马灯</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;跑马灯&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;msg&quot; style=&quot;display: inline-block;background-color: #C81623; color: white; font-size: 50px;&quot;&gt;祝愿梁先森当上CEO,赢取白富美! &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;

    &lt;script&gt;
        // 计时器,毫秒
        setInterval(&quot;f1()&quot;, 100);

        function f1() {
            // js 获取一个id=&#39;msg&#39;的标签
            var tag = document.getElementById(&quot;msg&quot;);
            // 获取标签内容
            var text = tag.innerText;

            var a = text.charAt(0);
            var sub = text.substring(1,text.length);

            var new_str = sub + a;
            tag.innerText= new_str;
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 学习]]></title>
      <url>http://www.liangxiansen.cn/2016/08/22/JavaScript/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前端开发三要素，HTML（描述网页内容），CSS（描述样式），JavaScript（控制网页行为）。</p>
</blockquote>
<p>JavaScript是一门编程语言，浏览器内置了JavaScript语言的解释器，所以在浏览器上按照JavaScript语言的规则编写相应代码，浏览器可以解释并做出相应的处理。</p>
<p>在学习<code>JavaScript</code>之前,首先对要排除一些误解, 推荐一篇文章,简单看一下即可:<a href="http://www.javascript.crockford.com/zh/javascript.html" target="_blank" rel="noopener">JavaScript–世界上误解最深的语言</a></p>
<a id="more"></a>
<h2 id="JavaScript-初识"><a href="#JavaScript-初识" class="headerlink" title="JavaScript 初识"></a>JavaScript 初识</h2><h3 id="如何编写"><a href="#如何编写" class="headerlink" title="如何编写"></a>如何编写</h3><pre><code class="javascript">&lt;!-- HTML中JS文件的引用 --&gt;
&lt;script type&quot;text/javascript&quot; src=&quot;JS文件路径&quot;&gt;&lt;/script&gt;

&lt;!-- HTML中JS代码块 --&gt;
&lt;script type&quot;text/javascript&quot;&gt;
    Js代码内容
&lt;/script&gt;
</code></pre>
<p>放在<body>标签内的代码底部，为什么不能放在上面呢？为什么css的就可以放在上面呢？<br>html代码是从上往下解释的，上面的html使用css样式，如果css代码块放在下面上面的html就没有办法显示样式了<br>如果把js文件或者js代码放在上面,那么当js文件或者js代码耗时比较久的时候，下面的html代码就无法执行了。</body></p>
<h3 id="如何引用"><a href="#如何引用" class="headerlink" title="如何引用"></a>如何引用</h3><p><strong>JavaScript的引入方法如下：</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Demo Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 以上代码忽略 --&gt;

  &lt;!-- 为性能优化需将 javascript 代码放置在 body 标签的最末端 --&gt;
  &lt;!-- 外联文件 --&gt;
  &lt;script src=&quot;/javascripts/application.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; async defer&gt;&lt;/script&gt;
  &lt;!-- 内嵌代码 --&gt;
  &lt;script&gt;
    document.write(&#39;&gt;&gt;&gt; Hello, world!&#39;);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>JavaScript中代码注释：</p>
<ul>
<li>单行注释: <code>//</code></li>
<li>多行注释: <code>/*  */</code></li>
</ul>
<blockquote>
<p>注意：此注释仅在<code>&lt;script&gt;</code>块中有效。</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>JavaScript中变量的声明是一个非常容易出错的点，<code>局部变量</code>必须一个 var 开头，如果未使用var，则默认表示声明的是<code>全局变量</code>。建议一般情况下都使用局部变量,在必要的时候再用全局变量,因为全局变量想象范围大,容易影起代码执行错误.</p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;

    // 全局变量
    name = &#39;seven&#39;;

    function func() {
        // 局部变量
        var age = 18;

        // 全局变量
        gender = &quot;男&quot;
    }
&lt;/script&gt;
</code></pre>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 中的数据类型分为原始类型和对象类型：</p>
<blockquote>
<p><code>原始类型</code></p>
<ul>
<li>数字</li>
<li>字符串</li>
<li>布尔值</li>
</ul>
</blockquote>
<blockquote>
<p><code>对象类型</code></p>
<ul>
<li>数组</li>
<li>“字典”<br>…</li>
<li>特别的，数字、布尔值、null、undefined、字符串是不可变。</li>
</ul>
</blockquote>
<pre><code>// null、undefined
null是JavaScript语言的关键字，它表示一个特殊值，常用来描述“空值”。
undefined是一个特殊值，表示变量未定义。
</code></pre><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>JavaScript中不区分整数值和浮点数值，JavaScript中所有数字均用浮点数值表示。</p>
<p>转换：</p>
<pre><code>parseInt(..)    将某值转换成数字，不成功则NaN
parseFloat(..) 将某值转换成浮点数，不成功则NaN
</code></pre><p>特殊值：</p>
<pre><code>NaN，非数字。可使用 isNaN(num) 来判断。
Infinity，无穷大。可使用 isFinite(num) 来判断。
</code></pre><p>更多数值计算：</p>
<pre><code>常量

Math.E
常量e，自然对数的底数。

Math.LN10
10的自然对数。

Math.LN2
2的自然对数。

Math.LOG10E
以10为底的e的对数。

Math.LOG2E
以2为底的e的对数。

Math.PI
常量figs/U03C0.gif。

Math.SQRT1_2
2的平方根除以1。

Math.SQRT2
2的平方根。

静态函数

Math.abs( )
计算绝对值。

Math.acos( )
计算反余弦值。

Math.asin( )
计算反正弦值。

Math.atan( )
计算反正切值。

Math.atan2( )
计算从X轴到一个点的角度。

Math.ceil( )
对一个数上舍入。

Math.cos( )
计算余弦值。

Math.exp( )
计算e的指数。

Math.floor( )
对一个数下舍人。

Math.log( )
计算自然对数。

Math.max( )
返回两个数中较大的一个。

Math.min( )
返回两个数中较小的一个。

Math.pow( )
计算xy。

Math.random( )
计算一个随机数。

Math.round( )
舍入为最接近的整数。

Math.sin( )
计算正弦值。

Math.sqrt( )
计算平方根。

Math.tan( )
计算正切值。
</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是由字符组成的数组，但在JavaScript中字符串是不可变的：可以访问字符串任意位置的文本，但是JavaScript并未提供修改已知字符串内容的方法。</p>
<p>常见功能：</p>
<pre><code>obj.length                           长度
obj.trim()                           移除空白
obj.trimLeft()
obj.trimRight)
obj.charAt(n)                        返回字符串中的第n个字符
obj.concat(value, ...)               拼接
obj.indexOf(substring,start)         子序列位置
obj.lastIndexOf(substring,start)     子序列位置
obj.substring(from, to)              根据索引获取子序列
obj.slice(start, end)                切片
obj.toLowerCase()                    小写
obj.toUpperCase()                    大写
obj.split(delimiter, limit)          分割
obj.search(regexp)                   从头开始匹配，返回匹配成功的第一个位置(g无效)
obj.match(regexp)                    全局搜索，如果正则中有g表示找到全部，否则只找到第一个。
obj.replace(regexp, replacement)     替换，正则中有g则替换所有，否则只替换第一个匹配项，
                                     $数字：匹配的第n个组内容；
                                     $&amp;：当前匹配的内容；
                                     $`：位于匹配子串左侧的文本；
                                     $&#39;：位于匹配子串右侧的文本
                                     $$：直接量$符号
</code></pre><h3 id="布尔类型（Boolean）"><a href="#布尔类型（Boolean）" class="headerlink" title="布尔类型（Boolean）"></a>布尔类型（Boolean）</h3><p>布尔类型仅包含真假，与Python不同的是其首字母小写。</p>
<ul>
<li>==      比较值相等</li>
<li>!=       不等于</li>
<li>===   比较值和类型相等</li>
<li>!===  不等于</li>
<li>||        或</li>
<li>&amp;&amp;      且</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JavaScript中的数组类似于Python中的列表</p>
<p>常见功能：</p>
<pre><code>obj.length          数组的大小
obj.push(ele)       尾部追加元素
obj.pop()           尾部获取一个元素
obj.unshift(ele)    头部插入元素
obj.shift()         头部移除元素
obj.splice(start, deleteCount, value, ...)  插入、删除或替换数组的元素
                     obj.splice(n,0,val) 指定位置插入元素
                     obj.splice(n,1,val) 指定位置替换元素
                    obj.splice(n,1)     指定位置删除元素
obj.slice( )        切片
obj.reverse( )      反转
obj.join(sep)       将数组元素连接起来以构建一个字符串
obj.concat(val,..)  连接数组
obj.sort( )         对数组元素进行排序
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code>JSON.stringify(obj)    序列化
JSON.parse(str)        反序列化
</code></pre><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><pre><code>decodeURI( )                   URl中未转义的字符
decodeURIComponent( )          URI组件中的未转义字符
encodeURI( )                   URI中的转义字符
encodeURIComponent( )          转义URI组件中的字符
escape( )                      对字符串转义
unescape( )                    给转义字符串解码
URIError                       由URl的编码和解码方法抛出
</code></pre><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>JavaScript中的eval是Python中eval和exec的合集，既可以编译代码也可以获取返回值。</p>
<pre><code>eval()
EvalError   执行字符串中的JavaScript代码
</code></pre><h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><h3 id="通知方式"><a href="#通知方式" class="headerlink" title="通知方式"></a>通知方式</h3><p><strong>1、消息弹窗:</strong></p>
<pre><code class="javascript">alert(&#39;这是通知消息&#39;)
</code></pre>
<p>效果:</p>
<p><img src="http://www.liangxiansen.cn/images/javascript/alert.png" alt="消息通知"></p>
<p><strong>2、打印日志:</strong></p>
<pre><code class="javascript">console.log(&#39;这是测试消息&#39;)
</code></pre>
<p>效果:<br>鼠标右击选择<code>审查页面元素</code><br><img src="http://www.liangxiansen.cn/images/javascript/console_log.png" alt="打印日志"></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>1、<code>定义正则表达式</code></p>
<p>/…/       用于定义正则表达式<br>/…/g      表示全局匹配<br>/…/i      表示不区分大小写<br>/…/m      表示多行匹配</p>
<p>JS正则匹配时本身就是支持多行，此处多行匹配只是影响正则表达式<code>^</code>和<code>$</code>，<code>m</code>模式也会使用<code>^</code>,<code>$</code>来匹配换行的内容)</p>
<blockquote>
<p>注：定义正则表达式也可以  <code>reg = new RegExp()</code></p>
</blockquote>
<p>2、<code>匹配</code></p>
<p><strong> JavaScript中支持正则表达式，其主要提供了两个功能: </strong></p>
<p>   1) test(string)     检查字符串中是否和正则匹配</p>
<pre><code>n = &#39;uui99sdf&#39;
reg = /\d+/
reg.test(n)  ---&gt; true

# 只要正则在字符串中存在就匹配，如果想要开头和结尾匹配的话，就需要在正则前后加 ^和$
</code></pre><p>   2) exec(string)    获取正则表达式匹配的内容，如果未匹配，值为null，否则，获取匹配成功的数组。</p>
<pre><code>非全局模式
    获取匹配结果数组，注意：第一个元素是第一个匹配的结果，后面元素是正则子匹配（正则内容分组匹配）
    var pattern = /\bJava\w*\b/;
    var text = &quot;JavaScript is more fun than Java or JavaBeans!&quot;;
    result = pattern.exec(text)

    var pattern = /\b(Java)\w*\b/;
    var text = &quot;JavaScript is more fun than Java or JavaBeans!&quot;;
    result = pattern.exec(text)

全局模式
    需要反复调用exec方法，来一个一个获取结果，直到匹配获取结果为null表示获取完毕
    var pattern = /\bJava\w*\b/g;
    var text = &quot;JavaScript is more fun than Java or JavaBeans!&quot;;
    result = pattern.exec(text)

    var pattern = /\b(Java)\w*\b/g;
    var text = &quot;JavaScript is more fun than Java or JavaBeans!&quot;;
    result = pattern.exec(text)
</code></pre><p>3、 <code>字符串中相关方法</code></p>
<pre><code>obj.search(regexp)                   获取索引位置，搜索整个字符串，返回匹配成功的第一个位置(g模式无效)
obj.match(regexp)                    获取匹配内容，搜索整个字符串，获取找到第一个匹配内容，如果正则是g模式找到全部
obj.replace(regexp, replacement)     替换匹配替换，正则中有g则替换所有，否则只替换第一个匹配项，
                                        $数字：匹配的第n个组内容；
                                        $&amp;：当前匹配的内容；
                                        $`：位于匹配子串左侧的文本；
                                        $&#39;：位于匹配子串右侧的文本
                                        $$：直接量$符号
</code></pre><h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><p>JavaScript中提供了时间相关的操作，时间操作中分为两种时间：</p>
<ul>
<li>时间统一时间</li>
<li>本地时间（东8区）</li>
</ul>
<p>更多操作参见：<a href="http://www.shouce.ren/api/javascript/main.html" target="_blank" rel="noopener">http://www.shouce.ren/api/javascript/main.html</a></p>
<h3 id="语句和异常"><a href="#语句和异常" class="headerlink" title="语句和异常"></a>语句和异常</h3><p>1、条件语句<br>JavaScript中支持两个中条件语句，分别是：if 和 switch</p>
<p><code>if</code></p>
<pre><code>if(条件){

}else if(条件){

}else{

}
</code></pre><p><code>switch</code></p>
<pre><code>switch(name){
    case &#39;1&#39;:
        age = 123;
        break;
    case &#39;2&#39;:
        age = 456;
        break;
    default :
        age = 777;
}
</code></pre><p>2、循环语句<br>JavaScript中支持三种循环语句，分别是：</p>
<p>方式一:</p>
<pre><code>var names = [&quot;alex&quot;, &quot;tony&quot;, &quot;rain&quot;];

for(var i=0;i&lt;names.length;i++){
    console.log(i);
    console.log(names[i]);
}
</code></pre><p>方式二:</p>
<pre><code>var names = [&quot;alex&quot;, &quot;tony&quot;, &quot;rain&quot;];

for(var index in names){
    console.log(index);
    console.log(names[index]);
}
</code></pre><p>方式三:</p>
<pre><code>while(条件){
    // break;
    // continue;
}
</code></pre><p>3、异常处理</p>
<pre><code>try {
    //这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行
}
catch (e) {
    // 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。
    //e是一个局部变量，用来指向Error对象或者其他抛出的对象
}
finally {
     //无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。
}
</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>1、基本函数</p>
<p>JavaScript中函数基本上可以分为一下三类：</p>
<pre><code>// 普通函数
    function func(arg){
        return true;
    }

// 匿名函数
    var func = function(arg){
        return &quot;tony&quot;;
    }

// 自执行函数
    (function(arg){
        console.log(arg);
    })(&#39;123&#39;)
</code></pre><blockquote>
<p>注意：对于JavaScript中函数参数，实际参数的个数可能小于形式参数的个数，函数内的特殊值arguments中封装了所有实际参数。</p>
</blockquote>
<p>2、作用域<br>JavaScript中每个函数都有自己的作用域，当出现函数嵌套时，就出现了作用域链。当内层函数使用变量时，会根据作用域链从内到外一层层的循环，如果不存在，则异常。</p>
<blockquote>
<p>注意：所有的作用域在创建函数且未执行时候就已经存在。</p>
</blockquote>
<pre><code>function f2(){
    var arg= 111;
    function f3(){
        console.log(arg);
    }

    return f3;
}

ret = f2();
ret();
</code></pre><p>注：声明提前，在JavaScript引擎“预编译”时进行。</p>
<p>更多：<a href="http://www.cnblogs.com/wupeiqi/p/5649402.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/p/5649402.html</a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>「闭包」，是指拥有多个变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>闭包是个函数，而它「记住了周围发生了什么」。表现为由「一个函数」体中定义了「另个函数」<br>由于作用域链只能从内向外找，默认外部无法获取函数内部变量。闭包，在外部获取函数内部的变量。</p>
</blockquote>
<pre><code>(function (s) {
    s = &#39;显示消息:&#39; + s;
    alert(s);
})(str);
</code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre><code>function Foo(name,age) {
    this.Name = name;
    this.Age = age;
    this.Func = function(arg){
        return this.Name + arg;
    }
}

var obj = new Foo(&#39;alex&#39;, 18);
var ret = obj.Func(&quot;sb&quot;);
console.log(ret);
</code></pre><p>对于上述代码需要注意：</p>
<ul>
<li>Foo充当的构造函数</li>
<li>this代指对象</li>
<li>创建对象时需要使用 <code>new</code></li>
</ul>
<p>上述代码中每个对象中均保存了一个相同的Func函数，从而<code>浪费内存</code>。使用原型和可以解决该问题：</p>
<pre><code>function Foo(name,age) {
    this.Name = name;
    this.Age = age;
}

Foo.prototype = {
    GetInfo: function(){
        return this.Name + this.Age
    },
    Func : function(arg){
        return this.Name + arg;
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python对MySQL进行操作]]></title>
      <url>http://www.liangxiansen.cn/2016/08/11/Python-MySQL/</url>
      <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><blockquote>
<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
</blockquote>
<p>想要使用MySQL来存储并操作数据，则需要做几件事情：</p>
<ul>
<li>　a. 安装MySQL服务端</li>
<li>　b. 安装MySQL客户端</li>
<li>　c. 【客户端】连接【服务端】</li>
<li>　d. 【客户端】发送命令给【服务端MySQL】服务的接受命令并执行相应操作(增删改查等)<a id="more"></a>
</li>
</ul>
<pre><code>下载
        http://dev.mysql.com/downloads/mysql/
安装
        windows:
            鼠标一路下一步
        Linux:
            yum install mysql-server
        Mac:
            鼠标一路下一步
</code></pre><h3 id="MySQL基本操作"><a href="#MySQL基本操作" class="headerlink" title="MySQL基本操作"></a>MySQL基本操作</h3><p>1、显示数据</p>
<pre><code>SHOW DATABASES;
</code></pre><p>默认数据库：</p>
<ul>
<li><code>mysql</code> - 用户权限相关数据</li>
<li><code>test</code> - 用于用户测试数据</li>
<li><code>information_schema</code> - MySQL本身架构相关数据</li>
</ul>
<p>2、使用数据库(数据库切换)</p>
<pre><code>USE db_name;
</code></pre><p>3、显示所有表</p>
<pre><code>SHOW TABLES;
</code></pre><p>4、用户授权</p>
<pre><code>创建用户
    create user &#39;用户名&#39;@&#39;IP地址&#39; identified by &#39;密码&#39;;
删除用户
    drop user &#39;用户名&#39;@&#39;IP地址&#39;;
修改用户
    rename user &#39;用户名&#39;@&#39;IP地址&#39;; to &#39;新用户名&#39;@&#39;IP地址&#39;;;
修改密码
    set password for &#39;用户名&#39;@&#39;IP地址&#39; = Password(&#39;新密码&#39;)

PS：用户权限相关数据保存在mysql数据库的user表中，所以也可以直接对其进行操作（不建议）
</code></pre><h3 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h3><pre><code>show grants for &#39;用户&#39;@&#39;IP地址&#39;                  -- 查看权限
grant  权限 on 数据库.表 to   &#39;用户&#39;@&#39;IP地址&#39;      -- 授权
revoke 权限 on 数据库.表 from &#39;用户&#39;@&#39;IP地址&#39;      -- 取消权限
</code></pre><h4 id="对于权限"><a href="#对于权限" class="headerlink" title="对于权限"></a>对于权限</h4><pre><code>all privileges  除grant外的所有权限
select          仅查权限
select,insert   查和插入权限
...
usage                   无访问权限
alter                   使用alter table
alter routine           使用alter procedure和drop procedure
create                  使用create table
create routine          使用create procedure
create temporary tables 使用create temporary tables
create user             使用create user、drop user、rename user和revoke  all privileges
create view             使用create view
delete                  使用delete
drop                    使用drop table
execute                 使用call和存储过程
file                    使用select into outfile 和 load data infile
grant option            使用grant 和 revoke
index                   使用index
insert                  使用insert
lock tables             使用lock table
process                 使用show full processlist
select                  使用select
show databases          使用show databases
show view               使用show view
update                  使用update
reload                  使用flush
shutdown                使用mysqladmin shutdown(关闭MySQL)
super                   􏱂􏰈使用change master、kill、logs、purge、master和set global。还允许mysqladmin􏵗􏵘􏲊􏲋调试登陆
replication client      服务器位置的访问
replication slave       由复制从属使用
</code></pre><h4 id="对于数据库"><a href="#对于数据库" class="headerlink" title="对于数据库"></a>对于数据库</h4><p>对于目标数据库以及内部其他：</p>
<pre><code>数据库名.*           数据库中的所有
数据库名.表          指定数据库中的某张表
数据库名.存储过程     指定数据库中的存储过程
*.*                所有数据库
</code></pre><h4 id="对于用户和IP"><a href="#对于用户和IP" class="headerlink" title="对于用户和IP"></a>对于用户和IP</h4><pre><code>用户名@IP地址         用户只能在该IP下才能访问
用户名@192.168.1.%   用户只能在该IP段下才能访问(通配符%表示任意)
用户名@%             用户可以再任意IP下访问(默认IP地址为%)
</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>grant all privileges on db1.tb1 TO &#39;用户名&#39;@&#39;IP&#39;

grant select on db1.* TO &#39;用户名&#39;@&#39;IP&#39;

grant select,insert on *.* TO &#39;用户名&#39;@&#39;IP&#39;

revoke select on db1.tb1 from &#39;用户名&#39;@&#39;IP&#39;
</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code>create table 表名(
    列名  类型  是否可以为空，
    列名  类型  是否可以为空
)
</code></pre><p>是否可为空</p>
<pre><code>是否可空，null表示空，非字符串
not null    - 不可空
null        - 可空
</code></pre><p>默认值</p>
<pre><code>默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值
create table tb1(
    nid int not null defalut 2,
    num int not null
)
</code></pre><p>自增</p>
<pre><code>自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）
create table tb1(
    nid int not null auto_increment primary key,
    num int not null
)
或
create table tb1(
    nid int not null auto_increment,
    num int not null,
    index(nid)
)
注意：1、对于自增列，必须是索引（含主键）。
     2、对于自增可以设置步长和起始值
         show session variables like &#39;auto_inc%&#39;;
         set session auto_increment_increment=2;
         set session auto_increment_offset=10;

         shwo global  variables like &#39;auto_inc%&#39;;
         set global auto_increment_increment=2;
         set global auto_increment_offset=10;
</code></pre><p>主键</p>
<pre><code>主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。
create table tb1(
    nid int not null auto_increment primary key,
    num int null
)
或
create table tb1(
    nid int not null,
    num int not null,
    primary key(nid,num)
)
</code></pre><p>外键</p>
<pre><code>外键，一个特殊的索引，只能是指定内容
creat table color(
    nid int not null primary key,
    name char(16) not null
)

create table fruit(
    nid int not null primary key,
    smt char(32) null ,
    color_id int not null,
    constraint fk_cc foreign key (color_id) references color(nid)
)
</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre><code>drop table 表名
</code></pre><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><pre><code>delete from 表名
truncate table 表名
</code></pre><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><pre><code>添加列：
    alter table 表名 add 列名 类型
删除列：
    alter table 表名 drop column 列名
修改列：
    alter table 表名 modify column 列名 类型;  -- ALTER TABLE testalter_tbl MODIFY c CHAR(10);
    alter table 表名 change 原列名 新列名 类型; -- ALTER TABLE testalter_tbl CHANGE j j INT;

添加主键：
    alter table 表名 add (primary_key);
删除主键：
    alter table 表名 drop primary_key;

添加外键：
    alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);
删除外键：
    alter table 表名 drop foreign key 外键名称

修改默认值：
    ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
删除默认值：
    ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;
</code></pre><p>基本数据类型</p>
<p>MySQL的数据类型大致分为：数值、时间和字符串<br><a href="http://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-data-types.html</a></p>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><pre><code>insert into 表 (列名,列名...) values (值,值,值...)
insert into 表 (列名,列名...) values (值,值,值...),(值,值,值...)
insert into 表 (列名,列名...) select (列名,列名...) from 表
</code></pre><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><pre><code>delete from 表
delete from 表 where id＝1 and name＝&#39;alex&#39;
</code></pre><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><pre><code>update 表 set name ＝ &#39;alex&#39; where id&gt;1
</code></pre><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><pre><code>select * from 表
select * from 表 where id &gt; 1
select nid,name,gender as gg from 表 where id &gt; 1
</code></pre><h3 id="常用例子"><a href="#常用例子" class="headerlink" title="常用例子"></a>常用例子</h3><pre><code>    1、条件
        select * from 表 where id &gt; 1 and name != &#39;alex&#39; and num = 12;

        select * from 表 where id between 5 and 16;

        select * from 表 where id in (11,22,33)
        select * from 表 where id not in (11,22,33)
        select * from 表 where id in (select nid from 表)

    2、通配符
        select * from 表 where name like &#39;ale%&#39;  - ale开头的所有（多个字符串）
        select * from 表 where name like &#39;ale_&#39;  - ale开头的所有（一个字符）

    3、限制
        select * from 表 limit 5;            - 前5行
        select * from 表 limit 4,5;          - 从第4行开始的5行
        select * from 表 limit 5 offset 4    - 从第4行开始的5行

    4、排序
        select * from 表 order by 列 asc              - 根据 “列” 从小到大排列
        select * from 表 order by 列 desc             - 根据 “列” 从大到小排列
        select * from 表 order by 列1 desc,列2 asc    - 根据 “列1” 从大到小排列，如果相同则按列2从小到大排序

    5、分组
        select num from 表 group by num
        select num,nid from 表 group by num,nid
        select num,nid from 表  where nid &gt; 10 group by num,nid order nid desc
        select num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nid

        select num from 表 group by num having max(id) &gt; 10

        特别的：group by 必须在where之后，order by之前

    6、连表
        无对应关系则不显示
        select A.num, A.name, B.name
        from A,B
        Where A.nid = B.nid

        无对应关系则不显示
        select A.num, A.name, B.name
        from A inner join B
        on A.nid = B.nid

        A表所有显示，如果B中无对应关系，则值为null
        select A.num, A.name, B.name
        from A left join B
        on A.nid = B.nid

        B表所有显示，如果B中无对应关系，则值为null
        select A.num, A.name, B.name
        from A right join B
        on A.nid = B.nid

    7、组合
        组合，自动处理重合
        select nickname
        from A
        union
        select name
        from B

        组合，不处理重合
        select nickname
        from A
        union all
        select name
        from B
</code></pre><h2 id="pymysql模块"><a href="#pymysql模块" class="headerlink" title="pymysql模块"></a>pymysql模块</h2><p>pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。</p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><pre><code>pip3 install pymysql
</code></pre><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><pre><code class="python">import pymysql
# 创建连接
connection = pymysql.connect(host=&#39;127.0.0.1&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;123123&#39;, db=&#39;test&#39;)
# 创建游标
cursor = connection.cursor()

# 执行SQL,并返回受影响行数
effect_row = cursor.execute(&quot;update host set ip = &#39;1.1.1.1&#39;&quot;)

# 执行SQL,并返回受影响行数
effect_row = cursor.execute(&quot;update host set ip = &#39;2.2.2.2&#39; where hostname = &#39;c2&#39;&quot;)

# 执行SQL,插入多行数据并返回受影响行数
effect_row = cursor.executemany(&quot;insert into host(hostname,port,ip)value(%s,%s,%s)&quot;, [(&quot;c6&quot;, 22, &quot;6.6.6.6&quot;), (&quot;c7&quot;, 22, &quot;7.7.7.7&quot;)])
print(effect_row)

# 提交,不然无法保存修改
connection.commit()
# 关闭游标
cursor.close()
# 关闭连接
connection.close()
</code></pre>
<h3 id="获取最新自增ID"><a href="#获取最新自增ID" class="headerlink" title="获取最新自增ID"></a>获取最新自增ID</h3><pre><code class="python">import pymysql
# 创建连接
connection = pymysql.connect(host=&#39;127.0.0.1&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;123123&#39;, db=&#39;test&#39;)
# 创建游标
cursor = connection.cursor()


# 执行SQL,插入多行数据并返回受影响行数
effect_row = cursor.executemany(&quot;insert into host(hostname,port,ip)value(%s,%s,%s)&quot;, [(&quot;c6&quot;, 22, &quot;6.6.6.6&quot;), (&quot;c7&quot;, 22, &quot;7.7.7.7&quot;)])

# 提交,不然无法保存修改
connection.commit()
# 关闭游标
cursor.close()
# 关闭连接
connection.close()

# 获取最新自增ID
new_id = cursor.lastrowid
print(new_id)
</code></pre>
<h3 id="获取查询数据"><a href="#获取查询数据" class="headerlink" title="获取查询数据"></a>获取查询数据</h3><pre><code class="python">import pymysql
# 创建连接
connection = pymysql.connect(host=&#39;127.0.0.1&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;123123&#39;, db=&#39;test&#39;)
# 创建游标
cursor = connection.cursor()

cursor.execute(&quot;select * from host&quot;)

# 获取第一行数据
row_1 = cursor.fetchone()
print(row_1)

# 获取前n行数据
row_3 = cursor.fetchmany(3)
print(row_3)

# 获取所有数据
row_all = cursor.fetchall()
print(row_all)

# 提交,不然无法保存修改
connection.commit()
# 关闭游标
cursor.close()
# 关闭连接
connection.close()
</code></pre>
<h3 id="查询数据指针操作"><a href="#查询数据指针操作" class="headerlink" title="查询数据指针操作"></a>查询数据指针操作</h3><blockquote>
<p>注：在fetch数据时按照顺序进行，可以使用<code>cursor.scroll(num,mode)</code>来移动游标位置，如：</p>
<ul>
<li>cursor.scroll(1,mode=’relative’)  # 相对当前位置移动</li>
<li>cursor.scroll(2,mode=’absolute’) # 相对绝对位置移动</li>
</ul>
</blockquote>
<pre><code class="python">import pymysql
# 创建连接
connection = pymysql.connect(host=&#39;127.0.0.1&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;123123&#39;, db=&#39;test&#39;)
# 创建游标
cursor = connection.cursor()

cursor.execute(&quot;select * from host&quot;)

# 获取第一行数据
row = cursor.fetchone()
print(row)

# 绝对位置获取
cursor.scroll(7, mode=&#39;absolute&#39;)
row_8 = cursor.fetchone()
print(row_8)


# 正数向下移动指针
cursor.scroll(1, mode=&#39;relative&#39;)
row_3 = cursor.fetchone()
print(row_3)

# 负数向上移动指针
cursor.scroll(-1, mode=&#39;relative&#39;)
row_1 = cursor.fetchone()
print(row_1)

# 提交,不然无法保存修改
connection.commit()
# 关闭游标
cursor.close()
# 关闭连接
connection.close()
</code></pre>
<h3 id="fetch数据类型"><a href="#fetch数据类型" class="headerlink" title="fetch数据类型"></a>fetch数据类型</h3><p>关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即：</p>
<pre><code class="python">import pymysql
# 创建连接
connection = pymysql.connect(host=&#39;127.0.0.1&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;123123&#39;, db=&#39;test&#39;)
# 创建游标,设置为字典类型
cursor = connection.cursor(cursor=pymysql.cursors.DictCursor)

cursor.execute(&quot;select * from host&quot;)

# 获取第一行数据
row = cursor.fetchone()
print(row)

# 提交,不然无法保存修改
connection.commit()
# 关闭游标
cursor.close()
# 关闭连接
connection.close()
</code></pre>
<h2 id="SQLAchemy"><a href="#SQLAchemy" class="headerlink" title="SQLAchemy"></a>SQLAchemy</h2><p>曾几何时，程序员因为惧怕SQL而在开发的时候小心翼翼的写着sql，心中总是少不了恐慌，万一不小心sql语句出错，搞坏了数据库怎么办？又或者为了获取一些数据，什么内外左右连接，函数存储过程等等。毫无疑问，不搞懂这些，怎么都觉得变扭，说不定某天就跳进了坑里，叫天天不应，喊地地不答。</p>
<p>python中比较著名的ORM框架有很多，大名顶顶的 SQLAlchemy 是python世界里当仁不让的ORM框架。江湖中peewee，strom， pyorm，SQLObject 各领风骚，可是最终还是SQLAlchemy 傲视群雄。</p>
<p><code>SQLAlchemy</code>是Python编程语言下的一款<code>ORM框架</code>，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简而言之便是：<code>将对象转换成SQL</code>，然后使用数据API执行SQL然后获取执行结果。</p>
<p><img src="http://www.liangxiansen.cn/images/mysql/SQLAchemy.png" alt="SQLAchemy结构"></p>
<p>ORM方法论基于三个核心原则：</p>
<blockquote>
<ul>
<li>简单：以最基本的形式建模数据。</li>
<li>传达性：数据库结构被任何人都能理解的语言文档化。</li>
<li>精确性：基于数据模型创建正确标准化了的结构。</li>
</ul>
</blockquote>
<h3 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h3><p><code>SQLAlchemy</code>本身无法操作数据库，其必须依赖pymsql等第三方插件，<code>Dialect</code>用于和数据API进行交流，根据配置文件的不同,调用不同的数据库API，从而实现对数据库的操作.</p>
<p>Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如：</p>
<p>‘数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名’</p>
<blockquote>
<p>数据库类型://用户名:密码(没有密码则为空，不填)@数据库主机地址/数据库名?编码</p>
</blockquote>
<pre><code>MySQL-Python
    mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;

pymysql
    mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]

MySQL-Connector
    mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;

cx_Oracle
    oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]
</code></pre><blockquote>
<p>2.7版本使用mysqldb<br>3.5版本使用pymysql</p>
</blockquote>
<p>更多详见：<a href="http://docs.sqlalchemy.org/en/latest/dialects/index.html" target="_blank" rel="noopener">http://docs.sqlalchemy.org/en/latest/dialects/index.html</a></p>
<p>在sqlalchemy.schema包里有数据库关系的描述，列举几个最常用的：</p>
<blockquote>
<ul>
<li>字段：Column</li>
<li>索引：Index</li>
<li>表：Table</li>
</ul>
</blockquote>
<p>数据类型在sqlalchemy.types包，列举几个最常用的:</p>
<blockquote>
<ul>
<li>二进制：BIGINT</li>
<li>布尔：BOOLEAN</li>
<li>字符：CHAR</li>
<li>可变字符：VARCHAR</li>
<li>日期：DATETIME</li>
</ul>
</blockquote>
<p>其他方法 execute,update,insert,select,delete,join等</p>
<p>使用 Engine/ConnectionPooling/Dialect 进行数据库操作，Engine使用ConnectionPooling连接数据库，然后再通过Dialect执行SQL语句。</p>
<pre><code class="python">from sqlalchemy import create_engine, Table, Column, Integer, String, MetaData, ForeignKey

engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test?charset=utf8&quot;,encoding=&quot;utf-8&quot;, max_overflow=5)
&#39;&#39;&#39;
    max_overflow是最大连接数
    其他方法：
    “charset”指定了连接时使用的字符集（可省略）=utf8
    echo 参数为 True 时，会显示每条执行的 SQL 语句，生产环境下关闭。
&#39;&#39;&#39;
# 连接数据库
conn = engine.connect()
# 获取数据库表元数据,创建表必须
metadata = MetaData()
# 定义表
user = Table(&#39;user&#39;, metadata,
    Column(&#39;id&#39;, Integer, primary_key=True),
    Column(&#39;name&#39;, String(20)),
    )

color = Table(&#39;color&#39;, metadata,
    Column(&#39;id&#39;, Integer, primary_key=True),
    Column(&#39;name&#39;, String(20)),
    )

# 创建数据表，如果数据表存在，则忽视
metadata.create_all(engine)

# user表创建SQL语句，INSERT INTO &quot;user&quot; (id, name) VALUES (:id, :name)
sql = user.insert().values(id=666, name=&#39;liang&#39;)
conn.execute(sql)

# 删除一条user表里的 条件是id大于1的
sql = user.delete().where(user.c.id &gt; 1)
conn.execute(sql)

# 更新
sql = user.update().where(user.c.name == &#39;liang&#39;).values(name=&#39;lianglian&#39;)
conn.execute(sql)

from sqlalchemy import select  # 其他模块相同
sql = select([user, ])
res =conn.execute(sql)
print(res.fetchall())


# 也可以直接写SQL执行
cur = engine.execute(&quot;update user set name = &#39;lianglian&#39; where name = &#39;liang&#39;&quot;)

# 执行SQL
cur = engine.execute(&quot;insert into user(id,name)value(%s,%s)&quot;, [(2, &quot;aaa&quot;), (3, &quot;bbb&quot;)])
# 获取最新自增ID
print(cur.lastrowid)
# 执行SQL
cur = engine.execute(&quot;select * from user&quot;)
# 获取第一行数据
cur.fetchone()
# 获取第n行数据
cur.fetchmany(3)
# 获取所有数据
cur.fetchall()
conn.close()
</code></pre>
<pre><code class="python">from sqlalchemy import create_engine

engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test&quot;, max_overflow=5)

# 事务操作
with engine.begin() as conn:
    conn.execute(&quot;insert into table (x, y, z) values (1, 2, 3)&quot;)
    conn.execute(&quot;my_special_procedure(5)&quot;)

conn = engine.connect()
# 事务操作
with conn.begin():
       conn.execute(&quot;some statement&quot;, {&#39;x&#39;: 5, &#39;y&#39;: 10})
</code></pre>
<h3 id="ORM方式操作mysql"><a href="#ORM方式操作mysql" class="headerlink" title="ORM方式操作mysql"></a>ORM方式操作mysql</h3><blockquote>
<p>使用 ORM/Schema Type/SQL Expression Language/Engine/ConnectionPooling/Dialect 所有组件对数据进行操作。根据类创建对象，对象转换成SQL，然后执行SQL。</p>
</blockquote>
<h3 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="python">from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine

# 生成一个SqlORM 基类
Base = declarative_base()
# 创建数据库引擎
engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test&quot;, echo=True)
# 定义表结构
class Host(Base):
    # 表名为hosts
    __tablename__ = &#39;hosts&#39;
    # 表结构
    # primary_key等于主键
    # unique唯一
    # nullable非空
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(64), unique=True, nullable=False)
    ip_addr = Column(String(128), unique=True, nullable=False)
    port = Column(Integer, default=22)

Base.metadata.create_all(engine)   # 创建所有表结构

if __name__ == &#39;__main__&#39;:
    SessionCls = sessionmaker(bind=engine)
    # bind绑定
    # 创建与数据库的会话session class
    # 注意,这里返回给session的是个class,不是实例
    session = SessionCls()
    #插入字段
    h1 = Host(hostname=&#39;redhat&#39;, ip_addr=&#39;1.1.1.1&#39;)
    h2 = Host(hostname=&#39;ubuntu&#39;, ip_addr=&#39;2.2.2.2&#39;, port=80)
    h3 = Host(hostname=&#39;mysql&#39;, ip_addr=&#39;3.3.3.3&#39;, port=3306)
    # 添加一个字段
    # session.add(h3)
    # 添加多个字段
    session.add_all([h1, h2, h3])
    # 修改字段名字,只要没提交,此时修改也没问题
    # h2.hostname = &#39;ubuntu_test&#39;
    # 支持数据回滚
    # session.rollback()
    # 提交
    session.commit()
</code></pre>
<blockquote>
<p>注：SQLAlchemy无法修改表结构，如果需要可以使用SQLAlchemy开发者开源的另外一个软件<code>Alembic</code>来完成。</p>
</blockquote>
<h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><pre><code class="python">########### 增 ##########
# 定义一个字段
zenjia = Host(hostname=&#39;aaa&#39;, ip_addr=&#39;4.4.4.4&#39;)
# 添加字段
session.add(zenjia)
# 添加多个字段
session.add_all([
    Host(hostname=&#39;bbb&#39;, ip_addr=&#39;5.5.5.5&#39;),
    Host(hostname=&#39;ccc&#39;, ip_addr=&#39;6.6.6.6&#39;)
])
# 提交以上操作
session.commit()
</code></pre>
<h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><pre><code class="python">########## 删除 ##########
# 过滤user表中id大于3的数据删除
session.query(Host).filter(Host.id &gt; 3).delete()
session.commit()
</code></pre>
<h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><pre><code class="python">########## 修改 ##########
session.query(Host).filter(Host.hostname == &#39;ccc&#39;).update({&quot;hostname&quot;: &quot;c6&quot;})
session.query(Host).filter(Host.hostname == &#39;c6&#39;).update({Host.hostname: Host.hostname + &quot;ccc&quot;}, synchronize_session=False)
session.query(Host).filter(Host.id &gt; 3).update({Host.port: Host.port + 1}, synchronize_session=&quot;evaluate&quot;)
session.commit()
</code></pre>
<h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><pre><code class="python">######### 查询 ##########
查询Host表中hostname=&#39;aaa&#39;的所有数据
ret = session.query(Host).filter_by(hostname=&#39;aaa&#39;).all()
print(ret)
for i in ret:
    print(i.hostname, i.ip_addr, i.port)


# 查询Host表中hostname=&#39;aaa&#39;的第一条数据
ret = session.query(Host).filter_by(hostname=&#39;aaa&#39;).first()
print(ret.hostname, ret.ip_addr, ret.port)


# 查询Host表中ip_addr字段里面有等于1.1.1.1或者等于3.3.3.3的数据
ret = session.query(Host).filter(Host.ip_addr.in_([&#39;1.1.1.1&#39;, &#39;3.3.3.3&#39;])).all()
for i in ret:
    print(i.hostname, i.ip_addr, i.port)


# 可以给返回结果起一个别名
ret = session.query(Host.hostname.label(&#39;alias&#39;)).all()
print(ret, type(ret))

# 查询Host表,根据id排序
ret = session.query(Host).order_by(Host.id)[0:3]
for i in ret:
    print(i.id, i.hostname, i.ip_addr, i.port,)


# 创建query查询,filter是where条件,最后调用one()返回唯一行,如果调用all()则返回所有行:
host = session.query(Host).filter(Host.hostname == &#39;aaa&#39;).one()
print(host.id, host.hostname, host.ip_addr, host.port, )
</code></pre>
<h3 id="高级例子"><a href="#高级例子" class="headerlink" title="高级例子"></a>高级例子</h3><pre><code class="python"># 条件
filter规则匹配,filter_by精确匹配table中字段内容.
ret = session.query(Users).filter_by(name=&#39;alex&#39;).all()
ret = session.query(Users).filter(Users.id &gt; 1, Users.name == &#39;eric&#39;).all()
ret = session.query(Users).filter(Users.id.between(1, 3), Users.name == &#39;eric&#39;).all()
ret = session.query(Users).filter(Users.id.in_([1,3,4])).all()
ret = session.query(Users).filter(~Users.id.in_([1,3,4])).all()
ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name=&#39;eric&#39;))).all()
from sqlalchemy import and_, or_
ret = session.query(Users).filter(and_(Users.id &gt; 3, Users.name == &#39;eric&#39;)).all()
ret = session.query(Users).filter(or_(Users.id &lt; 2, Users.name == &#39;eric&#39;)).all()
ret = session.query(Users).filter(or_(Users.id &lt; 2,and_(Users.name == &#39;eric&#39;, Users.id &gt; 3),Users.extra != &quot;&quot;)).all()


# 通配符
ret = session.query(Users).filter(Users.name.like(&#39;e%&#39;)).all()
ret = session.query(Users).filter(~Users.name.like(&#39;e%&#39;)).all()

# 限制
ret = session.query(Users)[1:2]

# 排序
ret = session.query(Users).order_by(Users.name.desc()).all()
ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()

# 分组
from sqlalchemy.sql import func

ret = session.query(Users).group_by(Users.extra).all()
ret = session.query(
    func.max(Users.id),
    func.sum(Users.id),
    func.min(Users.id)).group_by(Users.name).all()

ret = session.query(
    func.max(Users.id),
    func.sum(Users.id),
    func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) &gt;2).all()

# 连表
ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()
ret = session.query(Person).join(Favor).all()
ret = session.query(Person).join(Favor, isouter=True).all()


# 组合
q1 = session.query(Users.name).filter(Users.id &gt; 2)
q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)
ret = q1.union(q2).all()

q1 = session.query(Users.name).filter(Users.id &gt; 2)
q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)
ret = q1.union_all(q2).all()
</code></pre>
<h3 id="外键关联"><a href="#外键关联" class="headerlink" title="外键关联"></a>外键关联</h3><blockquote>
<p>由于关系数据库的多个表还可以用外键实现一对多、多对多等表与表之间进行关联，ORM框架同理实现表与表之间进行关联.</p>
</blockquote>
<h3 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h3><blockquote>
<p>一对多关联,一个用户可以同时看多本书</p>
</blockquote>
<center><img src="http://www.liangxiansen.cn/images/mysql/外键.jpg" alt="一对多关联"></center>

<pre><code class="python">from sqlalchemy import create_engine, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship

# 生成sqlorm基类
Base = declarative_base()
# 创建数据库连接
engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test?charset=utf8&quot;, encoding=&quot;utf-8&quot;, echo=True)
# 目的是一个人可以拥有多本书，那么在数据库里的一对多关系


class User(Base):
    # 表名
    __tablename__ = &#39;user&#39;
    # id字段
    id = Column(String(20), primary_key=True)
    # 名字字段
    name = Column(String(20))
    &#39;&#39;&#39;
    内容不是表名而是定义的表结构名字,与生成表结构无关，用于正向查询方便,
    例如: User.books可以连接到 Book表详细调用情况请看最后例子.
    &#39;&#39;&#39;
    books = relationship(&#39;Book&#39;)


class Book(Base):
    # 表名
    __tablename__ = &#39;book&#39;
    # id字段
    id = Column(String(20), primary_key=True)
    # 名字字段
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    # ForeignKey是外键 关联user表的id字段
    user_id = Column(String(20), ForeignKey(&#39;user.id&#39;))

# 创建所有表结构
Base.metadata.create_all(engine)

if __name__ == &#39;__main__&#39;:
    # 绑定,生成会话
    SessionCls = sessionmaker(bind=engine)
    session = SessionCls()
    # 创建用户
    lianglian = User(id=&#39;1&#39;, name=&#39;lianglian&#39;)
    jack = User(id=&#39;2&#39;, name=&#39;jack&#39;)
    # 添加字段
    session.add_all([lianglian, jack])
    # 提交
    session.commit()
    # 创建白鹿原这本书，指定谁是拥有者
    Whitedeer = Book(id=&#39;1&#39;, name=&#39;White_deer&#39;, user_id=&#39;1&#39;)
    # 创建三体这本书，指定谁是拥有者
    Threebody1 = Book(id=&#39;2&#39;, name=&#39;Three_body&#39;, user_id=&#39;1&#39;)
    Threebody2 = Book(id=&#39;3&#39;, name=&#39;Three_body&#39;, user_id=&#39;2&#39;)
    La_traviata = Book(id=&#39;4&#39;, name=&#39;茶花女&#39;, user_id=&#39;2&#39;)
    # 添加字段
    session.add_all([Whitedeer, Threebody1, Threebody2, La_traviata])
    # 提交
    session.commit()


    # 获取每个用户下面的书名称
    ret = session.query(User).filter_by(name=&#39;lianglian&#39;).first()
    for i in ret.books:
        print(i.name)

    ret = session.query(User).filter_by(name=&#39;jack&#39;).first()
    for i in ret.books:
        print(i.name)

    &#39;&#39;&#39;
    上面的例子,就是加了一个books属性relationship指定了User和Book表结构之间的关系,可以相互快速的查询对应的内容
    &#39;&#39;&#39;
</code></pre>
<h3 id="多对多关联"><a href="#多对多关联" class="headerlink" title="多对多关联"></a>多对多关联</h3><p>建立一个双向一对多关系,“反向”是一个许多人,指定一个额外的relationship()函数<br>并连接两个使用relationship.back_populates参数<br>简单来说, relationship函数是sqlalchemy对关系之间提供的一种便利的调用方式, backref参数则对关系提供反向引用的声明。</p>
<center><img src="http://www.liangxiansen.cn/images/mysql/外键1.jpg" alt="多对多关联"></center>


<pre><code class="python">from sqlalchemy import create_engine, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship

# 生成sqlorm基类
Base = declarative_base()
# 创建数据库连接
engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test?charset=utf8&quot;, encoding=&quot;utf-8&quot;, echo=True)
# 目的是一个人可以拥有多本书，那么在数据库里的一对多关系


class User(Base):
    # 表名
    __tablename__ = &#39;user&#39;
    # id字段
    id = Column(String(20), primary_key=True)
    # 名字字段
    name = Column(String(20))
    &#39;&#39;&#39;
    内容不是表名而是定义的表结构名字,与生成表结构无关，仅用于查询方便,
    例如: User.books可以连接到 Book表详细调用情况请看最后例子.
    &#39;&#39;&#39;
    books = relationship(&#39;Book&#39;, backref=&#39;u&#39;)


class Book(Base):
    # 表名
    __tablename__ = &#39;book&#39;
    # id字段
    id = Column(String(20), primary_key=True)
    # 名字字段
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    # ForeignKey是外键 关联user表的id字段
    user_id = Column(String(20), ForeignKey(&#39;user.id&#39;))

# 创建所有表结构
Base.metadata.create_all(engine)

if __name__ == &#39;__main__&#39;:
    # 绑定,生成会话
    SessionCls = sessionmaker(bind=engine)
    session = SessionCls()
    # 创建用户
    lianglian = User(id=&#39;1&#39;, name=&#39;lianglian&#39;)
    jack = User(id=&#39;2&#39;, name=&#39;jack&#39;)
    # 添加字段
    session.add_all([lianglian, jack])
    # 提交
    session.commit()
    # 创建白鹿原这本书，指定谁是拥有者
    Whitedeer = Book(id=&#39;1&#39;, name=&#39;White_deer&#39;, user_id=&#39;1&#39;)
    # 创建三体这本书，指定谁是拥有者
    Threebody1 = Book(id=&#39;2&#39;, name=&#39;Three_body&#39;, user_id=&#39;1&#39;)
    Threebody2 = Book(id=&#39;3&#39;, name=&#39;Three_body&#39;, user_id=&#39;2&#39;)
    La_traviata = Book(id=&#39;4&#39;, name=&#39;茶花女&#39;, user_id=&#39;2&#39;)
    # 添加字段
    session.add_all([Whitedeer, Threebody1, Threebody2, La_traviata])
    # 提交
    session.commit()


    # 获取每个用户下面的书名称
    ret = session.query(User).filter_by(name=&#39;lianglian&#39;).first()
    for i in ret.books:
        print(i.name)

    ret = session.query(User).filter_by(name=&#39;jack&#39;).first()
    for i in ret.books:
        print(i.name)

    ret = session.query(Book).filter(Book.name == &quot;Three_body&quot;).all()
    for i in ret.u:
        print(i.u.name)


    &#39;&#39;&#39;
    上面的例子,就是加了一个books属性relationship指定了User和Book表结构之间的关系,可以相互快速的查询对应的内容,通过这个books去查询叫做正向查询

    backref=&#39;u&#39;,表示Book表结构中可以通过backref中指定的u关键字查询User表中的数据.通过&#39;u&#39;去查询的方式叫做反向查询.
    &#39;&#39;&#39;
</code></pre>
<blockquote>
<p>看出和上面的区别了吧,两个表之间通过<code>relationship.backref</code>实现可以做正向查询和反向查询,实现多对多.而之前那个例子限制只能从单独方向正向查询.</p>
</blockquote>
<p><strong>多对多还可以两个表都做正向查询</strong><br>在最新版本的sqlalchemy中对relationship引进了back_populates参数。</p>
<blockquote>
<p>通过使用<code>relationship.back_populates</code>在多个表之间相互指定要关联的对方表中对应的<code>relationship.back_populates</code>属性名称,具体例子看下面代码.</p>
</blockquote>
<pre><code class="python">from sqlalchemy import Column, Sequence, String, Integer, ForeignKey
from sqlalchemy import create_engine   # 导入创建连接驱动
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import relationship, backref

engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test?charset=utf8&quot;, encoding=&quot;utf-8&quot;, echo=True)
# 生成了declarative基类, 以后的model继承此类
Base = declarative_base()


class Hosts(Base):
    __tablename__ = &#39;hosts&#39;
    id = Column(Integer, primary_key=True, unique=True, autoincrement=True)
    name = Column(String(64), unique=True, nullable=False)
    ip_addr = Column(String(128), unique=True, nullable=False)
    port = Column(Integer, default=22)
    group_id = Column(Integer, ForeignKey(&#39;group.id&#39;))
    group_re = relationship(&quot;Group&quot;, back_populates=&quot;hosts_re&quot;)

class Group(Base):
    __tablename__ = &#39;group&#39;
    id = Column(Integer, primary_key=True, unique=True, autoincrement=True)
    name = Column(String(64), unique=True, nullable=False)
    hosts_re = relationship(&quot;Hosts&quot;, back_populates=&quot;group_re&quot;)

Base.metadata.create_all(engine)   # 创建所有表结构

if __name__ == &#39;__main__&#39;:
    SessionCls = sessionmaker(bind=engine)
    # 创建与数据库的会话session class ,注意,这里返回给session的是个class,不是实例
    session = SessionCls()
    g1 = Group(name=&#39;g1&#39;)
    g2 = Group(name=&#39;g2&#39;)
    a1 = Hosts(name=&#39;a1&#39;, ip_addr=&#39;1.1.1.1&#39;, group_id=1)
    a2 = Hosts(name=&#39;a2&#39;, ip_addr=&#39;2.2.2.2&#39;, group_id=1)
    b1 = Hosts(name=&#39;b1&#39;, ip_addr=&#39;3.3.3.3&#39;, group_id=2)
    b2 = Hosts(name=&#39;b2&#39;, ip_addr=&#39;4.4.4.4&#39;, group_id=2)
    session.add_all([g1, g2, a1, a2, b1, b2])
    session.commit()

    # 查询主机组
    ret = session.query(Hosts).filter(Hosts.name == &quot;a1&quot;).all()
    for i in ret:
        print(i.group_re.name)

    # 从主机组中查询主机
    ret = session.query(Group).filter(Group.name == &quot;g1&quot;).all()
    for i in ret:
        for h in i.hosts_re:
            print(h.name)
</code></pre>
<h3 id="多对多关联优化"><a href="#多对多关联优化" class="headerlink" title="多对多关联优化"></a>多对多关联优化</h3><blockquote>
<p>上面的方法关联的表少还好,如果关联得表多了,每个相互得表中relationship.back_populates函数之间都得互相指定,这样一个表结构建立起来就相当啰嗦和复杂了,<br>整个表的相互关联关系也不好区分,如果我们把表与表之间的相互关联关系单独放到一张表里面,要去找关联关系的时候都通过这张表去找这么样?</p>
</blockquote>
<center><img src="http://www.liangxiansen.cn/images/mysql/外键2.jpg" alt="多对多关联"></center>

<pre><code class="python">from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
# 创建数据库引擎
engine = create_engine(&quot;mysql+pymysql://root:123123@127.0.0.1:3306/test?charset=utf8&quot;, encoding=&quot;utf-8&quot;, echo=True)
# 生成一个SqlORM 基类
Base = declarative_base()

# 定义表结构,继承SqlORM基类
class HostToHostUser(Base):
    &quot;&quot;&quot;关联表&quot;&quot;&quot;
    __tablename__ = &#39;host_to_host_user&#39;
    nid = Column(Integer, primary_key=True, autoincrement=True)

    # 外键,建立两个表中数据与数据对应关系,正向通过这个表这个字段可以找到host表中的nid对于
    host_id = Column(Integer, ForeignKey(&#39;host.nid&#39;))
    # 外键,建立两个表中数据与数据对应关系,正向通过这个表这个字段可以找到host_user表中的nid对应
    host_user_id = Column(Integer, ForeignKey(&#39;host_user.nid&#39;))

    # 关联,通过这个可以联系到host表
    host = relationship(&quot;Host&quot;, backref=&#39;h&#39;)
    # 关联,通过这个可以联系到host_user表
    host_user = relationship(&quot;HostUser&quot;, backref=&#39;u&#39;)


class HostUser(Base):
    __tablename__ = &#39;host_user&#39;
    nid = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(32))


class Host(Base):
    __tablename__ = &#39;host&#39;
    nid = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(32))
    port = Column(String(32))
    ip = Column(String(32))

    # 间接建立关联,基于通过HostToHostUser表找到HostUser表结构的关联关系上建立我这个Host表直接与HostUser表的关联关系,
    # 这里有backref,你猜猜能不能从HostUser反向查询?? 答案是可以的! 通过关系表搭桥找到你心中的那个她~
    host_user = relationship(&quot;HostUser&quot;, secondary=lambda: HostToHostUser.__table__, backref=&#39;h&#39;)


def init_db():
    &quot;&quot;&quot;
    创建所有表
    :return:
    &quot;&quot;&quot;
    Base.metadata.create_all(engine)


def drop_db():
    &quot;&quot;&quot;
    删除所有表
    :return:
    &quot;&quot;&quot;
    Base.metadata.drop_all(engine)

init_db()

# bind绑定
# 创建与数据库的会话session class
# 注意,这里返回给Session的是个class,不是实例
Session = sessionmaker(bind=engine)
session = Session()


session.add_all([
    Host(hostname=&#39;c1&#39;,port=&#39;22&#39;,ip=&#39;1.1.1.1&#39;),
    Host(hostname=&#39;c2&#39;,port=&#39;22&#39;,ip=&#39;1.1.1.2&#39;),
    Host(hostname=&#39;c3&#39;,port=&#39;22&#39;,ip=&#39;1.1.1.3&#39;),
    Host(hostname=&#39;c4&#39;,port=&#39;22&#39;,ip=&#39;1.1.1.4&#39;),
    Host(hostname=&#39;c5&#39;,port=&#39;22&#39;,ip=&#39;1.1.1.5&#39;),
])
session.commit()


session.add_all([
    HostUser(username=&#39;root&#39;),
    HostUser(username=&#39;db&#39;),
    HostUser(username=&#39;nb&#39;),
    HostUser(username=&#39;sb&#39;),
])
# 提交修改
session.commit()

session.add_all([
    HostToHostUser(host_id=1,host_user_id=1),
    HostToHostUser(host_id=1,host_user_id=2),
    HostToHostUser(host_id=1,host_user_id=3),
    HostToHostUser(host_id=2,host_user_id=2),
    HostToHostUser(host_id=2,host_user_id=4),
    HostToHostUser(host_id=2,host_user_id=3),
])
session.commit()

# 获取主机1中所有用户
# 传统方法
# 查询Host表中hostname等于&#39;c1&#39;的,等到匹配数据的Host类对象(因为那一行是用Host类创建的)
host_obj = session.query(Host).filter(Host.hostname == &#39;c1&#39;).first()
# 查询HostToHostUser表结构中host_id == 1(host表中&#39;c1&#39;主机的nid)得到对应的host_user_id
host_2_host_user = session.query(HostToHostUser.host_user_id).filter(HostToHostUser.host_id == host_obj.nid).all()

r = zip(*host_2_host_user)  # 将得到的host_user_id数据去掉list中的元祖
users = session.query(HostUser.username).filter(HostUser.nid.in_(list(r)[0])).all()
print(users)


# 新方法
host_obj = session.query(Host).filter(Host.hostname == &#39;c1&#39;).first()
# 通过反向查找找到关系关联表,然后通过关系表中与host_user关联直接便可得到host_user表中相应的数据
for item in host_obj.h:
    print(item.host_user.username)

# 走Host表通过HostToHostUser搭桥建立的关联关系正向查询
host_obj = session.query(Host).filter(Host.hostname == &#39;c1&#39;).first()
for item in host_obj.host_user:
    print(item.username)

# 走Host表通过HostToHostUser搭桥建立的关联关系反向查询
host_obj = session.query(HostUser).filter(HostUser.username == &#39;nb&#39;).first()
for item in host_obj.h:
    print(item.hostname)
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>本人理解能力有限,可以对照官方API文档中内容理解:</p>
<ul>
<li><code>relationship_api</code>: <a href="http://docs.sqlalchemy.org/en/latest/orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" target="_blank" rel="noopener">http://docs.sqlalchemy.org/en/latest/orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates</a></li>
<li>更多关联: <a href="http://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html#many-to-many" target="_blank" rel="noopener">http://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html#many-to-many</a></li>
<li>刘耀: <a href="http://www.cnblogs.com/liu-yao/p/5342656.html" target="_blank" rel="noopener">http://www.cnblogs.com/liu-yao/p/5342656.html</a></li>
<li>简书: <a href="http://www.jianshu.com/p/e6bba189fcbd" target="_blank" rel="noopener">http://www.jianshu.com/p/e6bba189fcbd</a></li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python之路：(十六）socketserver模块]]></title>
      <url>http://www.liangxiansen.cn/2016/08/10/socketserver/</url>
      <content type="html"><![CDATA[<p>回顾原生socket模块,一次只能处理一个客户端请求,当这个客户端请求全部完成断开连接了,再去处理另外一个客户端得请求.这样服务端得资源其实还有很多是处于空闲状态的.然后我们又通过IO多路复用的方式解决了因为网络IO繁忙而造成浪费服务端资源得问题,通过select侦听网路IO,并以<code>读写分离得形式</code>实现了接受处理多个请求.</p>
<p>然而这样并不完善,如果同时来多个请求,还是会挂起堵塞.无法并发得处理客户端得请求.还好python给我们提供了一个并发处理socket得功能,那就是socketserver模块.</p>
<blockquote>
<p>socketserver内部使用 IO多路复用 以及 <code>多线程</code> 和 <code>多进程</code> ，从而实现并发处理多个客户端请求的socket服务端。即：每个客户端请求连接到服务器时socket服务端都会在服务器是创建一个<code>线程</code>或者<code>进程</code> 专门负责处理当前客户端的所有请求。　　</p>
</blockquote>
<a id="more"></a>
<p>如下图：</p>
<p>第一次连接后，数据通讯就通过线程或进程进行数据交换（红色箭头）</p>
<p><img src="/images/socket编程/socketserver拓扑.png" alt="socketserver拓扑图"></p>
<h2 id="ThreadingTCPServer"><a href="#ThreadingTCPServer" class="headerlink" title="ThreadingTCPServer"></a>ThreadingTCPServer</h2><blockquote>
<p><code>ThreadingTCPServer</code>实现的soket服务器内部会为每个client创建一个 <code>线程</code>，该线程用来和客户端进行交互。</p>
</blockquote>
<h3 id="ThreadingTCPServer基础"><a href="#ThreadingTCPServer基础" class="headerlink" title="ThreadingTCPServer基础"></a>ThreadingTCPServer基础</h3><p><strong>使用ThreadingTCPServer:</strong></p>
<ul>
<li>创建一个继承自 socketserver.BaseRequestHandler 的类</li>
<li>类中必须定义一个名称为 handle 的方法</li>
<li>启动ThreadingTCPServer</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="python">import socketserver


class MyServer(socketserver.BaseRequestHandler):

    def handle(self):
        conn = self.request  # 接受连接请求,获取客户端socket对象
        conn.sendall(&#39;欢迎致电 10086，请输入1xxx,0转人工服务.&#39;)  # 回一条消息给客户端
        while True:
            data = str(conn.recv(1024), encoding=&#39;utf-8&#39;)
            # 如果客户端没有输入内容则跳出本次循环什么都不执行
            if data == len(data):
                break
            # 根据用户输入的内容执行相应的操作
            elif data == &#39;0&#39;:
                conn.sendall(&#39;通过可能会被录音.balabala一大推&#39;)
            else:
                conn.sendall(&#39;请重新输入.&#39;)


if __name__ == &#39;__main__&#39;:
    # 实例话对象,传递一个元祖设置启动的IP/PORT,第二个参数把自己定义的类写上作为SocketServer.ThreadingTCPServer的构造函数
    server = socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8000), MyServer)
    # 对象调用父类的启动方法
    server.serve_forever()
</code></pre>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="python">import socket


ip_port = (&#39;127.0.0.1&#39;,8000)
sk = socket.socket()
sk.connect(ip_port)
sk.settimeout(5)

while True:
    data = sk.recv(1024)
    print(&#39;receive: %s&#39;,data)
    inp = input(&#39;please input:&#39;)
    sk.sendall(bytes(inp), encoding=&#39;utf-8&#39;)
    if inp == &#39;exit&#39;:
        break

sk.close()
</code></pre>
<h3 id="ThreadingTCPServer源码剖析"><a href="#ThreadingTCPServer源码剖析" class="headerlink" title="ThreadingTCPServer源码剖析"></a>ThreadingTCPServer源码剖析</h3><p>ThreadingTCPServer的类图关系如下：</p>
<p><img src="/images/socket编程/ThreadingTCPServer类.png" alt="ThreadingTCPServer类结构"></p>
<p>学会看源码非常重要！不能仅仅光会用！大赞~ 知道他的过程和实现~ 怎么学会看源码呢？多看然后画类图，如上图！！！</p>
<p>在理解的时候可以把他们想象为，把所有需要用的方法，都在ThreadingTCPServer中</p>
<p>内部调用流程为：</p>
<ol>
<li>运行服务端程序</li>
<li>执行 TCPServer.<strong>init</strong>方法，创建服务端Socket对象并绑定 IP 和 端口</li>
<li>执行 BaseServer.<strong>init</strong>方法，将自定义的继承自SocketServer.BaseRequestHandler 的类 MyRequestHandle,赋值给 self.RequestHandlerClass</li>
<li>执行 BaseServer.server_forever 方法，While 循环一直监听是否有客户端请求到达 …</li>
<li>当客户端连接到达服务器执行 ThreadingMixIn.process_request 方法，创建一个 “线程” 用来处理请求<br>执行 ThreadingMixIn.process_request_thread 方法<br>执行 BaseServer.finish_request 方法，执行 self.RequestHandlerClass()  即：执行 自定义 MyRequestHandler 的构造方法（自动调用基类BaseRequestHandler的构造方法，在该构造方法中又会调用 MyRequestHandler的handle方法）</li>
</ol>
<h3 id="源码精简版"><a href="#源码精简版" class="headerlink" title="源码精简版"></a>源码精简版</h3><pre><code class="python">import socket
import threading
import select


def process(request, client_address):  # 模拟定义的handle()方法，这个方法内的代码是socket server与Client端交互代码
    print(request,client_address)
    conn = request
    conn.sendall(&#39;欢迎致电 10086，请输入1xxx,0转人工服务.&#39;)
    flag = True
    while flag:
        data = conn.recv(1024)
        if data == &#39;exit&#39;:
            flag = False
        elif data == &#39;0&#39;:
            conn.sendall(&#39;通过可能会被录音.balabala一大推&#39;)
        else:
            conn.sendall(&#39;请重新输入.&#39;)


sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sk.bind((&#39;127.0.0.1&#39;, 8002))
sk.listen(5)

while True:  # 监控sk文件句柄,循环接受连接请求
    r, w, e = select.select([sk, ], [], [], 1)
    print(&#39;looping&#39;)
    if sk in r:  # 当sk文件句柄发生变化的时候说明是新的客户端连接过来了
        print(&#39;get request&#39;)
        request, client_address = sk.accept()
        t = threading.Thread(target=process, args=(request, client_address))  # 创建一个线程，并调用自己定义的process方法执行~然后样客户端与之交互
        t.daemon = False
        t.start()

sk.close()
</code></pre>
<blockquote>
<p>如精简代码可以看出，SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 <code>select</code> 和 <code>Threading</code> 两个东西，其实本质上就是在服务器端为每一个客户端创建一个线程，当前线程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p>
</blockquote>
<h2 id="ForkingTCPServer"><a href="#ForkingTCPServer" class="headerlink" title="ForkingTCPServer"></a>ForkingTCPServer</h2><p>ForkingTCPServer和ThreadingTCPServer的使用和执行流程基本一致，只不过在内部分别为请求者建立 “线程”  和 “进程”。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><pre><code class="python">import socketserver

class MyServer(socketserver.BaseRequestHandler):

    def handle(self):
        # print self.request,self.client_address,self.server
        conn = self.request
        conn.sendall(&#39;欢迎致电 10086，请输入1xxx,0转人工服务.&#39;)
        Flag = True
        while Flag:
            data = conn.recv(1024)
            if data == &#39;exit&#39;:
                Flag = False
            elif data == &#39;0&#39;:
                conn.sendall(&#39;通过可能会被录音.balabala一大推&#39;)
            else:
                conn.sendall(&#39;请重新输入.&#39;)


if __name__ == &#39;__main__&#39;:
    # 这里使用socketserver ForkingTCPServer类创建对象
    server = socketserver.ForkingTCPServer((&#39;127.0.0.1&#39;,8000),MyServer)
    server.serve_forever()
</code></pre>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="python">import socket


ip_port = (&#39;127.0.0.1&#39;,8000)
sk = socket.socket()
sk.connect(ip_port)
sk.settimeout(5)

while True:
    data = sk.recv(1024)
    print(&#39;receive:&#39;,data)
    inp = input(&#39;please input:&#39;)
    sk.sendall(inp)
    if inp == &#39;exit&#39;:
        break

sk.close()
</code></pre>
<p>以上<code>ForkingTCPServer</code>只是将 <code>ThreadingTCPServer</code> 实例中的代码：</p>
<pre><code>server = SocketServer.ThreadingTCPServer((&#39;127.0.0.1&#39;,8000),MyRequestHandler)
变更为：
server = SocketServer.ForkingTCPServer((&#39;127.0.0.1&#39;,8000),MyRequestHandler)
</code></pre><p>SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 <code>select</code> 和 <code>os.fork</code> 两个东西，其实本质上就是在服务器端为每一个客户端创建一个<code>进程</code>，当前新创建的进程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p>
<blockquote>
<p>源码剖析参考: ThreadingTCPServer</p>
</blockquote>
<h2 id="socketserver-模块练习"><a href="#socketserver-模块练习" class="headerlink" title="socketserver 模块练习"></a>socketserver 模块练习</h2><blockquote>
<p>开发一个支持多用户在线的FTP程序</p>
</blockquote>
<p><strong>要求：</strong></p>
<ol>
<li>用户加密认证</li>
<li>允许同时多用户登录</li>
<li>每个用户有自己的家目录 ，且只能访问自己的家目录</li>
<li>对用户进行磁盘配额，每个用户的可用空间不同</li>
<li>允许用户在ftp server上随意切换目录</li>
<li>允许用户查看当前目录下文件</li>
<li>允许上传和下载文件，保证文件一致性</li>
<li>文件传输过程中显示进度条</li>
<li>附加功能：支持文件的断点续传</li>
</ol>
<p>可参考: <a href="https://github.com/LiangXianSen/python_-study/tree/master/day9/FTP" target="_blank" rel="noopener">https://github.com/LiangXianSen/python_-study/tree/master/day9/FTP</a></p>
<div class="github-widget" data-repo="LiangXianSen/python_-study/tree/master/day9/FTP"></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python之路：(十五）进程、线程和协程]]></title>
      <url>http://www.liangxiansen.cn/2016/08/08/python-thread-process-gevent/</url>
      <content type="html"><![CDATA[<h2 id="Python线程"><a href="#Python线程" class="headerlink" title="Python线程"></a>Python线程</h2><blockquote>
<p>python中<code>threading</code>模块用于提供线程相关的操作，线程是应用程序中工作的最小单元，擅长IO操作</p>
</blockquote>
<pre><code class="python">import threading
import time

# 创建一个任务
def show(arg):
    time.sleep(1)
    print(&#39;thread&#39;+str(arg))

# 循环创建10个线程去并发都去执行这个任务
for i in range(10):
    # 创建线程,target=函数,去执行这个函数 args=参数,给这个函数传的参数
    t = threading.Thread(target=show, args=(i,))
    # 运行线程
    t.start()

print(&#39;main thread stop&#39;)
</code></pre>
<a id="more"></a>
<p>上述代码创建了10个“前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。<br>更多方法：</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>   线程准备就绪，等待CPU调度</p>
<h3 id="setName"><a href="#setName" class="headerlink" title="setName"></a>setName</h3><p>   为线程设置名称</p>
<h3 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h3><p>   获取线程名称</p>
<h3 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon"></a>setDaemon</h3><p>   设置为后台线程或前台线程（默认）</p>
<ul>
<li>如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止</li>
<li>如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>   逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>   线程被cpu调度后自动执行线程对象的run方法</p>
<h4 id="自己创建一个线程类"><a href="#自己创建一个线程类" class="headerlink" title="自己创建一个线程类"></a>自己创建一个线程类</h4><pre><code class="python"># 自己创建一个线程类,继承threading.Thread类, 重写run方法,start()方法调用内部run()方法
class MyThread(threading.Thread):

    # 初始化接受两个参数
    def __init__(self, func, args):
        self.func = func
        self.args = args

        # super主动调用父类__init__()方法
        super(MyThread, self).__init__()

    # 执行start()方法,我继承类Thread类,它会调用自己的run方法,
    # 我重写了run方法,根据类的继承关系,执行方法先找自己,如果自己有则我自己写的run方法
    def run(self):
        self.func(self.args)


def f2(arg):
    print(arg)


for i in range(10):
    obj = MyThread(f2, i)
    obj.start()
</code></pre>
<blockquote>
<p>从上面的例子可以更好的理解上面的<code>threading.Thread</code>类<code>run()</code>方法</p>
</blockquote>
<h3 id="线程锁（Lock、RLock）"><a href="#线程锁（Lock、RLock）" class="headerlink" title="线程锁（Lock、RLock）"></a>线程锁（Lock、RLock）</h3><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，所以，出现了线程锁 - 同一时刻允许一个线程执行操作。</p>
<h4 id="未加锁"><a href="#未加锁" class="headerlink" title="未加锁"></a>未加锁</h4><pre><code class="python">import threading
import time

NUM = 10

def func(arg):
    global NUM
    NUM -= 1
    time.sleep(1)
    print(NUM)

for i in range(10):
    t = threading.Thread(target=func, args=(i, ))
    t.start()
</code></pre>
<h4 id="加锁版本-一"><a href="#加锁版本-一" class="headerlink" title="加锁版本(一)"></a>加锁版本(一)</h4><pre><code class="python">import threading
import time

NUM = 10

def func(lock):
    global NUM
    #上锁
    lock.acquire()
    NUM -= 1
    time.sleep(2)
    print(NUM)
    # 开锁
    lock.release()

lock = threading.Lock()  # 创建锁对象(只能锁一次)
# lock = threading.RLock()   # 创建锁对象(能迭代锁多次)

for i in range(10):
    # 把所对象当作参数传递到任务函数里面
    t = threading.Thread(target=func, args=(lock, ))
    t.start()
</code></pre>
<h4 id="加锁版本-二"><a href="#加锁版本-二" class="headerlink" title="加锁版本(二)"></a>加锁版本(二)</h4><pre><code class="python">import threading
import time

NUM = 10

def func(lock):
    global NUM
    #上锁
    lock.acquire()  # 锁1,锁住
    NUM -= 1
    lock.acquire()  # 锁2,锁住
    time.sleep(2)
    lock.release()  # 锁2,解锁
    print(NUM)
    # 开锁
    lock.release()  # 锁1,解锁

# lock = threading.Lock()  # 创建锁对象(只能锁一次)
lock = threading.RLock()   # 创建锁对象(能迭代锁多次)

for i in range(10):
    # 把所对象当作参数传递到任务函数里面
    t = threading.Thread(target=func, args=(lock, ))
    t.start()
</code></pre>
<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><blockquote>
<p><code>互斥锁</code> 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。</p>
</blockquote>
<pre><code class="python">import threading
import time

NUM = 10

def func(i,lock):
    global NUM
    # 上锁5
    lock.acquire()
    NUM -= 1
    time.sleep(1)
    print(NUM, i)
    # 开锁5
    lock.release()

lock = threading.BoundedSemaphore(5)   # 一次锁多个,释放多个

for i in range(10):
    t = threading.Thread(target=func, args=(i, lock, ))
    t.start()
</code></pre>
<h3 id="事件（event）"><a href="#事件（event）" class="headerlink" title="事件（event）"></a>事件（event）</h3><p>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 <code>set</code>、<code>wait</code>、<code>clear</code>。</p>
<p>事件处理的机制：全局定义了一个<code>“Flag”</code>，如果<code>“Flag”</code>值为 <code>False</code>，那么当程序执行到 <code>event.wait</code>（检查） 方法时就会阻塞，如果<code>“Flag”</code>值为<code>True</code>，那么<code>event.wait</code> 方法时便不再阻塞。</p>
<ul>
<li><code>clear</code>：将“Flag”设置为<code>False</code></li>
<li><code>set</code>：将“Flag”设置为<code>True</code></li>
</ul>
<pre><code class="python">import threading


def func(i, e):
    print(i)
    e.wait()   # 检测是什么灯,如果是红灯停;绿灯行
    print(i+100)


event = threading.Event()

for i in range(10):
    t = threading.Thread(target=func, args=(i, event, ))
    t.start()

event.clear()  # 设置成红灯
inp = input(&quot;&gt;&gt;&gt;&quot;)
if inp == &quot;1&quot;:
    event.set()  # 设置成绿灯
</code></pre>
<h3 id="条件（Condition）"><a href="#条件（Condition）" class="headerlink" title="条件（Condition）"></a>条件（Condition）</h3><p>使得线程等待，只有满足某条件时，才释放n个线程</p>
<pre><code class="python"># 输入多少放出多少
import threading
def func(i, con):
    print(i)
    con.acquire()
    con.wait()    # 对应到notify的输入多少放出多少
    print(i+100)
    con.release()


c = threading.Condition()

for i in range(10):
    t = threading.Thread(target=func, args=(i, c, ))
    t.start()


while True:
    inp = input(&#39;&gt;&gt;&gt;&#39;)
    if inp == &#39;q&#39;:
        break
    c.acquire()
    c.notify(int(inp))
    c.release()
</code></pre>
<pre><code class="python"># 当某个执行结果为真就放出一个
import threading


def condition():
    ret = False
    r = input(&#39;&gt;&gt;&gt;&#39;)
    if r == &#39;1&#39;:
        ret = True
    else:
        ret = False
    return ret


def func(i, con):
    print(i)
    con.acquire()
    con.wait_for(condition)  # 检测condition函数执行结果,True放出一个
    print(i+100)
    con.release()

con = threading.Condition()

for i in range(10):
    t = threading.Thread(target=func, args=(i, con, ))
    t.start()
</code></pre>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><pre><code class="python"># 设置这个线程执行一次要多久
from threading import Timer


def hello():
    print(&quot;hello, world&quot;)

t = Timer(10, hello)  # hello任务执行设置执行10秒
t.start()  # after 1 seconds, &quot;hello, world&quot; will be printed
</code></pre>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote>
<p>什么是线程池？<br>诸如web服务器、数据库服务器、文件服务器和邮件服务器等许多服务器应用都面向处理来自某些远程来源的<code>大量短小的任务</code>。<br>构建服务器应用程序的一个过于简单的模型是：每当一个请求到达就创建一个新的服务对象，然后在新的服务对象中为请求服务。<br>但当有大量请求并发访问时，服务器不断的创建和销毁对象的开销很大。<br>所以提高服务器效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这样就引入了“池”的概念，<br><code>“池”的概念使得人们可以定制一定量的资源，然后对这些资源进行复用，而不是频繁的创建和销毁。</code></p>
</blockquote>
<p><strong>线程池的注意事项:</strong><br>虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。在使用线程池时需注意线程池大小与性能的关系，注意并发风险、死锁、资源不足和线程泄漏等问题。</p>
<ol>
<li><blockquote>
<p>线程池大小。多线程应用并非线程越多越好，需要根据系统运行的软硬件环境以及应用本身的特点决定线程池的大小。一般来说，如果代码结构合理的话，线程数目与CPU 数量相适合即可。<br>如果线程运行时可能出现阻塞现象，可相应增加池的大小；如有必要可采用自适应算法来动态调整线程池的大小，以提高CPU 的有效利用率和系统的整体性能。</p>
</blockquote>
</li>
<li><blockquote>
<p>并发错误。多线程应用要特别注意并发错误，要从逻辑上保证程序的正确性，注意避免死锁现象的发生。</p>
</blockquote>
</li>
<li><blockquote>
<p>线程泄漏。这是线程池应用中一个严重的问题，当任务执行完毕而线程没能返回池中就会发生线程泄漏现象。</p>
</blockquote>
</li>
</ol>
<h4 id="线程池需求"><a href="#线程池需求" class="headerlink" title="线程池需求"></a>线程池需求</h4><ol>
<li>能够调整线程池大小<br>比如：<br>任务数是3，进程池20  ，那么咱们只需要开启3个线程就行了。<br>任务数是500，进程池是20，那么咱们只开20个线程就可以了。</li>
</ol>
<ol start="2">
<li><p>实现线程池正在运行，有一个查看的功能，查看一下现在线程里面活跃的线程是多少等待的是多少？<br>线程总共是多少，等待中多少，正在运行中多少<br>作用：<br>方便查看当前线程池状态<br>能获取到这个之后就可以当线程一直处于空闲状态<br>查看状态用：上下文管理来做，非常nice的一点</p>
</li>
<li><p>关闭线程</p>
</li>
</ol>
<h4 id="自己实现线程池"><a href="#自己实现线程池" class="headerlink" title="自己实现线程池"></a>自己实现线程池</h4><pre><code class="python">import queue
import threading
import contextlib
import time

StopEvent = object()


class ThreadPool(object):

    def __init__(self, max_num):
        # 创建任务队列
        self.q = queue.Queue()
        # 获取最大数设置
        self.max_num = max_num

        self.terminal = False
        # 创建任务线程的list
        self.generate_list = []
        # 创建存放空闲进程的list
        self.free_list = []

    def run(self, func, args, callback=None):
        &quot;&quot;&quot;
        线程池执行一个任务
        :param func: 任务函数
        :param args: 任务函数所需参数
        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）
        :return: 如果线程池已经终止，则返回True否则None
        &quot;&quot;&quot;
        # 空闲的线程等于0,并且已经生成的线程小于线程最大设置就生成一个线程
        if len(self.free_list) == 0 and len(self.generate_list) &lt; self.max_num:
            # 创建线程
            self.generate_thread()
        # 获取的任务
        w = (func, args, callback,)
        # 放进队列里面
        self.q.put(w)

    def generate_thread(self):
        &quot;&quot;&quot;
        创建一个线程
        &quot;&quot;&quot;
        # 创建一个线程去队列中取一个任务执行
        t = threading.Thread(target=self.call)
        # 运行线程
        t.start()

    def call(self):
        &quot;&quot;&quot;
        循环去获取任务函数并执行任务函数
        &quot;&quot;&quot;
        # 创建线程
        current_thread = threading.currentThread
        # 将线程加到任务线程列表中
        self.generate_list.append(current_thread)
        # 从队列中获取任务
        event = self.q.get()
        while event != StopEvent:
            # 得到任务元祖(函数,参数,函数名)
            func, arguments, callback = event
            try:
                # 执行函数得到返回值结果
                result = func(*arguments)
                success = True
            except Exception as e:
                success = False
                result = None
            # 如果有第二个函数
            if callback is not None:
                try:
                    # 执行第二个函数
                    callback(success, result)
                except Exception as e:
                    pass
            # 线程执行完任务放到调用任务状态转换得方法,将执行完的线程放到空闲的list中
            with self.worker_state(self.free_list, current_thread):
                # 判断是否终止
                if self.terminal:
                    # 终止循环
                    event = StopEvent
                else:
                    # 有则继续取任务,执行任务
                    event = self.q.get()
        else:
            # 线程执行完从已经创建得线程列表中删除
            self.generate_list.remove(current_thread)

    def close(self):
        &quot;&quot;&quot;
        执行完所有的任务后，所有线程停止
        &quot;&quot;&quot;
        full_size = len(self.generate_list)
        while full_size:
            self.q.put(StopEvent)
            full_size -= 1

    def terminate(self):
        &quot;&quot;&quot;
        无论是否还有任务，终止线程
        &quot;&quot;&quot;
        self.terminal = True

        while self.generate_list:
            self.q.put(StopEvent)

        self.q.empty()


    @contextlib.contextmanager
    def worker_state(self, state_list, worker_thread):
        &quot;&quot;&quot;
        用于记录线程中正在等待的线程数
        &quot;&quot;&quot;
        state_list.append(worker_thread)
        try:
            yield
        finally:
            state_list.remove(worker_thread)
</code></pre>
<h2 id="Python进程"><a href="#Python进程" class="headerlink" title="Python进程"></a>Python进程</h2><pre><code class="python"># 创建进程
from multiprocessing import Process


def foo(i):
    print(&#39;say hi&#39;,i)

for i in range(10):
    p = Process(target=foo,args=(i,))
    p.start()
</code></pre>
<blockquote>
<p>注意：由于进程之间的数据需要各自持有一份，所以创建进程需要的非常大的开销。<code>并且python不能再Windows下创建进程！</code></p>
<ul>
<li>并且在使用多进程的时候，最好是创建多少个进程？：<code>和CPU核数相等</code></li>
</ul>
</blockquote>
<h3 id="进程数据共享"><a href="#进程数据共享" class="headerlink" title="进程数据共享"></a>进程数据共享</h3><blockquote>
<p>进程各自持有一份数据，默认无法共享数据,就得有个特殊的数据结构，这个数据结构就可以理解为他有<code>穿墙</code>的功能<br>如果你能穿墙的话两边就都可以使用了<br>使用了3种方法</p>
</blockquote>
<pre><code class="python"># 进程间默认无法数据共享
from multiprocessing import Process

li = []


def foo(i):
    li.append(i)
    print(&#39;say hi&#39;, li)

for i in range(10):
    p = Process(target=foo, args=(i,))
    p.start()

# 进程中数据不共享,这里主进程的li列表中还是空
print(&#39;ending&#39;, li)
</code></pre>
<h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><pre><code class="python">from multiprocessing import Process, Array
#通过特殊的数据结构：数组（Array）
temp = Array(&#39;i&#39;, [11, 22, 33, 44])   # 这里的i是C语言中的数据结构，通过他来定义你要共享的内容的类型！

# 创建一个只包含数字类型的数组（python中叫列表）
# 并且数组是不可变的，在C，或其他语言中，数组是不可变的，之后再python中数组（列表）是可以变得
# 当然其他语言中也提供可变的数组
# 在C语言中数组和字符串是一样的，如果定义一个列表，如果可以增加，那么我需要在你内存地址后面再开辟一块空间，那我给你预留多少呢？
#在python中的list可能用链表来做的，我记录了你前面和后面是谁。   列表不是连续的，数组是连续的

def Foo(i):
    temp[i] = 100+i
    for item in temp:
        # 打印子进程中得value
        print(i, &#39;-----&gt;&#39;, item)

for i in range(2):
    p = Process(target=Foo, args=(i,))
    p.start()
</code></pre>
<h4 id="Array类型定义对应表"><a href="#Array类型定义对应表" class="headerlink" title="Array类型定义对应表"></a>Array类型定义对应表</h4><pre><code>&#39;c&#39;: ctypes.c_char,  &#39;u&#39;: ctypes.c_wchar,
&#39;b&#39;: ctypes.c_byte,  &#39;B&#39;: ctypes.c_ubyte,
&#39;h&#39;: ctypes.c_short, &#39;H&#39;: ctypes.c_ushort,
&#39;i&#39;: ctypes.c_int,   &#39;I&#39;: ctypes.c_uint,
&#39;l&#39;: ctypes.c_long,  &#39;L&#39;: ctypes.c_ulong,
&#39;f&#39;: ctypes.c_float, &#39;d&#39;: ctypes.c_double
</code></pre><h3 id="manage-dict-共享数据"><a href="#manage-dict-共享数据" class="headerlink" title="manage.dict()共享数据"></a>manage.dict()共享数据</h3><pre><code class="python">from multiprocessing import Process, Manager   # 这个特殊的数据类型Manager

manage = Manager()
dic = manage.dict()  # 这里调用的时候，使用字典，这个字典和咱们python使用方法是一样的！


def Foo(i):
    dic[i] = 100+i
    print(dic.values())

for i in range(10):
    p = Process(target=Foo, args=(i,))
    p.start()
    p.join()
</code></pre>
<h3 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h3><pre><code class="python">from multiprocessing import Process, Queue


def f(i,q):
    print(i, q.get())

if __name__ == &#39;__main__&#39;:
    q = Queue()
    q.put(&quot;h1&quot;)
    q.put(&quot;h2&quot;)
    q.put(&quot;h3&quot;)

    for i in range(10):
        p = Process(target=f, args=(i, q,))
        p.start()
</code></pre>
<h3 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h3><p>当创建进程时（非使用时），共享数据会被拿到子进程中，当进程中执行完毕后，再赋值给原值。</p>
<pre><code class="python"># 进程锁
from multiprocessing import Process, Array, RLock


def Foo(lock, temp, i):
    &quot;&quot;&quot;
    将第0个数加100
    &quot;&quot;&quot;
    lock.acquire()
    temp[0] += 100
    for item in temp:
        print(i, &#39;-----&gt;&#39;, item)
    lock.release()

lock = RLock()
temp = Array(&#39;i&#39;, [11, 22, 33, 44])

for i in range(10):
    p = Process(target=Foo,args=(lock, temp, i,))
    p.start()
</code></pre>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p>进程池中有两个方法：</p>
<ul>
<li>apply</li>
<li>apply_async</li>
</ul>
<pre><code class="python">from multiprocessing import Process, Pool
import time


def Foo(i):
    time.sleep(2)
    return i+100


def Bar(arg):
    print(arg)

pool = Pool(5)  # 创建一个进程池
# print(pool.apply(Foo,(1,)))  #去进程池里去申请一个进程去执行Foo方法
# print(pool.apply_async(func=Foo, args=(1,)).get())  # 同上一个意思

for i in range(10):
    # print(pool.apply(Foo, (i,)))
    pool.apply_async(func=Foo, args=(i,),callback=Bar)

print(&#39;end&#39;)
pool.close()
# pool.terminate()  # 立即结束
pool.join()  # 主进程等待进程池中子进程执行完毕后再关闭，如果注释，那么程序直接关闭。

&#39;&#39;&#39;
pool.apply 主动的去执行
pool.apply_async(func=Foo, args=(i,),callback=Bar) 相当于异步，当申请一个线程之后，执行FOO方法就不管了，执行完之后就再执行callback ，当你执行完之后，再执行一个方法告诉我执行完了
callback 有个函数，这个函数就是操作的Foo函数的返回值！
&#39;&#39;&#39;
</code></pre>
<h2 id="Python协程"><a href="#Python协程" class="headerlink" title="Python协程"></a>Python协程</h2><p>首先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API<br>而对于协程来说它和系统毫无关系！<br>他就和程序员有关系，对于线程和进程来说，调度是由CPU来决定调度的！<br>对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里</p>
<blockquote>
<p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p>
</blockquote>
<p><code>适用场景：</code>其实在其他语言中，协程的意义其实不大,多线程即可已解决I/O的问题，但是在python因为他有GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，所以：<code>如果一个线程里面I/O操作特别多，协程就比较适用</code></p>
<h3 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h3><pre><code class="python">from greenlet import greenlet


def test1():
    print(12)      # (1)
    gr2.switch()   # 遇到这个跳到下一个
    print(34)      # (3)
    gr2.switch()


def test2():
    print(56)      # (2)
    gr1.switch()
    print(78)      # (4)

# 创建两个协程,协程运行遇到IO操作需要等待得时候执行另一个协程
gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch()  # 执行第一个协程

&#39;&#39;&#39;
比I/O操作，如果10个I/O，我程序从上往下执行，如果同时发出去了10个I/O操作，那么返回的结果如果同时回来了2个
，是不是就节省了很多时间？

如果一个线程里面I/O操作特别多，使用协程是不是就非常适用了！

如果一个线程访问URL通过协程来做，协程告诉它你去请求吧，然后继续执行，但是如果不用协程就得等待第一个请求完毕之后返回之后才
继续下一个请求。

协程：把一个线程分成了多个协程操作，每个协程做操作
多线程：是把每一个操作，分为多个线程做操作，但是python中，在同一时刻只能有一个线程操作，并且有上下文切换。但是如果上下文切换非常频繁的话
是非常耗时的，但对于协程切换就非常轻便了~
&#39;&#39;&#39;
</code></pre>
<blockquote>
<p>协程就是对线程的分片，上面的例子需要手动操作可能用处不是很大,助于了解原理，看下面的例子：</p>
</blockquote>
<h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><p>上面的greenlet是需要认为的制定调度顺序的，所以又出了一个<code>gevent</code>他是对<code>greenlet</code>功能进行封装,遇到I/O自动切换</p>
<pre><code class="python">from gevent import monkey; monkey.patch_all()
import gevent
import requests


def f(url):
    print(&#39;GET: %s&#39; % url)
    resp = requests.get(url)
    data = resp.text
    print(&#39;%d bytes received from %s.&#39; % (len(data), url))


gevent.joinall([
    gevent.spawn(f, &#39;https://www.python.org/&#39;),  # 这里的f是调用的任务,第二个是给这个任务传的参数
    gevent.spawn(f, &#39;https://www.yahoo.com/&#39;),
    gevent.spawn(f, &#39;https://www.github.com/&#39;),
])

&#39;&#39;&#39;
当遇到I/O操作的时候就会调用协程操作，然后继续往下走，然后这个协程就卡在这里等待数据的返回
&#39;&#39;&#39;
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python之路：(十二）队列(queue)]]></title>
      <url>http://www.liangxiansen.cn/2016/08/05/python-queue/</url>
      <content type="html"><![CDATA[<h2 id="Queue-先进先出队列"><a href="#Queue-先进先出队列" class="headerlink" title="Queue(先进先出队列)"></a>Queue(先进先出队列)</h2><h3 id="队列特点"><a href="#队列特点" class="headerlink" title="队列特点"></a>队列特点</h3><blockquote>
<p>队列特点：先进先出（FIFO)——先进队列的元素先出队列。来源于我们生活中的队列（先排队的先办完事）。</p>
</blockquote>
<pre><code class="python">import queue

q = queue.Queue() #调用队列生成对象
q.put(1)  #存放第一个值到队列
q.put(2)  #存放第二个值到队列

print(&#39;get frist one:%s&#39; % q.get())  # 获取队列的第一个值
print(&#39;get second on:%s &#39; % q.get())  # 获取队列的第二个值
</code></pre>
<ul>
<li>先进先出原则第一次存放的是1，第二次存放的是2，那么我们在获取值得时候，第一次获取的就是1，第二次就是2</li>
</ul>
<a id="more"></a>
<p><strong>看下面的例子如果队列里没有值怎么办？他会等待直到有数据为止：</strong></p>
<pre><code class="python">import queue

q = queue.Queue()  # 调用队列生成对象

q.put(1)  #存放第一个值到队列
q.put(2)  #存放第二个值到队列

a = q.get()  # 获取队列的第一个值
print(&#39;get frist one:%s&#39; % a)
b = q.get()  # 获取队列的第二个值
print(&#39;get second one:%s&#39; % b)
c = q.get()  # 获取队列的第三个值
print(&#39;get third one:%s&#39; % c)

#结果:
&#39;&#39;&#39;
get frist one:1
get second one:2
#这里没有获取到值堵塞住,一直在等待着值进来~
&#39;&#39;&#39;
</code></pre>
<ul>
<li>如果不想让他等待，不管是否队列里都取数据，可以使用<code>get_nowait()</code>，但是如果队列中没有数据就会报错！</li>
</ul>
<pre><code class="python">import queue

q = queue.Queue()  # 调用队列生成对象

q.put(1)  #存放第一个值到队列
q.put(2)  #存放第二个值到队列

a = q.get()  # 获取队列的第一个值
print(&#39;get frist one:%s&#39; % a)
b = q.get()  # 获取队列的第二个值
print(&#39;get second one:%s&#39; % b)
c = q.get_nowait()  # 获取队列的第三个值,使用：get_nowait() 不堵塞!
print(&#39;get third one:%s&#39; % c)
</code></pre>
<ul>
<li>如果队列为空的时候可以通过异常处理进行捕获：</li>
</ul>
<pre><code class="python">import queue

q = queue.Queue()  # 调用队列生成对象

q.put(1)  #存放第一个值到队列
q.put(2)  #存放第二个值到队列

try:
    a = q.get()  # 获取队列的第一个值
    print(&#39;get frist one:%s&#39; % a)
    b = q.get()  # 获取队列的第二个值
    print(&#39;get second one:%s&#39; % b)
    c = q.get_nowait()  # 获取队列的第三个值,使用：get_nowait() 不堵塞!
    print(&#39;get third one:%s&#39; % c)
except queue.Empty as q_error:
    print(&#39;The Queue is empty!&#39;)
</code></pre>
<ul>
<li>同样的如果队列长度为2，如果队列满了之后，同样他也是等待，直到有位置才会继续如下代码：</li>
</ul>
<pre><code class="python">import queue

q = queue.Queue(2)  # 调用队列生成对象,2:设置队列长度为2

q.put(1)  # 存放第一个值到队列
print(&#39;put value 1 done&#39;)
q.put(2)  # 存放第二个值到队列
print(&#39;put vlaue 2 done&#39;)
q.put(3)  # 存放第三个值到队列
print(&#39;put value 3 done&#39;)

#结果：
&#39;&#39;&#39;
put value 1 done
put vlaue 2 done
#这里会一直等待~
&#39;&#39;&#39;
</code></pre>
<ul>
<li>同样如果存放数值的时候如果不想让他等待，使用<code>put_nowait()</code>但是队列无法存放后会报错！</li>
</ul>
<pre><code class="python">import queue

q = queue.Queue(2)  # 调用队列生成对象,2:设置队列长度为2

q.put(1)  # 存放第一个值到队列
print(&#39;put value 1 done&#39;)
q.put(2)  # 存放第二个值到队列
print(&#39;put vlaue 2 done&#39;)
# q.put(33, block=False)  # 不堵塞
# q.put(33, block=False, timeout=2)  # 不堵塞,等待2秒
q.put_nowait(3)  # 存放第三个值到队列,使用：put_nowait() 不堵塞!
print(&#39;put value 3 done&#39;)
</code></pre>
<ul>
<li>也可以使用empty()方法判断队列是否为空</li>
</ul>
<pre><code class="python">import queue

# 队列最大长度,
# qsize()真实队列个数
# maxsize 最大支持的个数

q = queue.Queue(2)  # 队列最大长度
print(q.empty())    # 检查是否为空(初始默认是空)
q.put(11)
q.put(22)
print(q.empty())
print(q.qsize())   # 获取队列长度
</code></pre>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p><strong>什么是生产者消费者模型?</strong></p>
<blockquote>
<p>在工作中，大家可能会碰到这样一种情况：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产 生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产者负责往仓库了进商 品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模型。结构图如下：</p>
</blockquote>
<p><img src="http://www.liangxiansen.cn/images/socket编程/queue.jpg" alt="生产者消费者模型"></p>
<p>生产者消费者模型的优点：</p>
<p>1、解耦</p>
<p>假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化， 可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。</p>
<p>举个例子，我们去邮局投递信件，如果不使用邮筒（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须 得认识谁是邮递员，才能把信给他（光凭身上穿的制服，万一有人假冒，就惨了）。这就产生和你和邮递员之间的依赖（相当于生产者和消费者的强耦合）。万一哪天邮递员换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮筒相对来说比较固定，你依赖它的成本就比较低（相当于和缓冲区之间的弱耦合）。</p>
<p>2、支持并发</p>
<p>由于生产者与消费者是两个独立的并发体，他们之间是用缓冲区作为桥梁连接，生产者只需要往缓冲区里丢数据，就可以继续生产下一个数据，而消费者只需要从缓冲区了拿数据即可，这样就不会因为彼此的处理速度而发生阻塞。</p>
<p>接上面的例子，如果我们不使用邮筒，我们就得在邮局等邮递员，直到他回来，我们把信件交给他，这期间我们啥事儿都不能干（也就是生产者阻塞），或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。</p>
<p>3、支持忙闲不均</p>
<p>缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。 等生产者的制造速度慢下来，消费者再慢慢处理掉。</p>
<p>为了充分复用，我们再拿寄信的例子来说事。假设邮递员一次只能带走1000封信。万一某次碰上情人节（也可能是圣诞节）送贺卡，需要寄出去的信超过1000封，这时 候邮筒这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮筒中，等下次过来 时再拿走。</p>
<p><strong> 简单的生产者消费者模型: </strong></p>
<pre><code class="python">import queue
import threading
import time

q = queue.Queue()

# 生成者(client)
def productor(arg):
    # 序号加包子,将做好的包子放到篮子(队列)里
    q.put(str(arg) + &#39;包子&#39;)

# 创建30个包子
for i in range(30):
    t = threading.Thread(target=productor, args=(i,))
    t.start()

# ============================================================== #

# 消费者(server)
def consumer(arg):
    while True:
        # arg(0-3)吃包子得人, q.get()从篮子(队列)里取包子,包子有序号
        print(arg, q.get())
        time.sleep(2)

# 三个线程一起吃包子
for j in range(3):
    t = threading.Thread(target=consumer, args=(j,))
    t.start()
</code></pre>
<h2 id="PriorityQueue-优先级队列"><a href="#PriorityQueue-优先级队列" class="headerlink" title="PriorityQueue(优先级队列)"></a>PriorityQueue(优先级队列)</h2><h3 id="队列特点-1"><a href="#队列特点-1" class="headerlink" title="队列特点"></a>队列特点</h3><blockquote>
<p>队列特点: 根据优先级处理,数字最小的优先级最高</p>
</blockquote>
<pre><code class="python">import queue
q = queue.PriorityQueue()   # 根据优先级处理,数字最小的优先级最高
# put() 参数一为优先级,第二个参数是value
q.put((3, &quot;alex3&quot;))
q.put((2, &quot;alex2&quot;))
q.put((1, &quot;alex1&quot;))
print(q.get())
</code></pre>
<h2 id="deque-双向队列"><a href="#deque-双向队列" class="headerlink" title="deque(双向队列)"></a>deque(双向队列)</h2><h3 id="队列特点-2"><a href="#队列特点-2" class="headerlink" title="队列特点"></a>队列特点</h3><blockquote>
<p>队列特点: 两边都能插入数据,都能取数据</p>
</blockquote>
<pre><code class="python">import queue
q= queue.deque()          #双向队列
q.append((123))
q.append(234)
q.appendleft(456)
print(list(q))
q.pop()
q.popleft()
print(list(q))
</code></pre>
<h3 id="append-x"><a href="#append-x" class="headerlink" title="append(x)"></a>append(x)</h3><p>将x添加到 deque 的右侧。</p>
<h3 id="appendleft-x"><a href="#appendleft-x" class="headerlink" title="appendleft(x)"></a>appendleft(x)</h3><p>将x添加到 deque 的左侧。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>从留下长度为 0 的 deque 中移除所有元素。</p>
<h3 id="count-x"><a href="#count-x" class="headerlink" title="count(x)"></a>count(x)</h3><p>统计 deque 中值为x的个数。</p>
<h3 id="extend-iterable"><a href="#extend-iterable" class="headerlink" title="extend(iterable)"></a>extend(iterable)</h3><p>通过追加元素从可迭代参数扩展的 deque 的右侧。</p>
<h3 id="extendleft-iterable"><a href="#extendleft-iterable" class="headerlink" title="extendleft(iterable)"></a>extendleft(iterable)</h3><p>通过将附加元素从扩展 deque 的左侧可迭代。请注意，左边的一系列附加结果在扭转可迭代参数中元素的顺序。</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p>删除并从右侧的双端队列中返回的元素。如果没有元素存在，提出了IndexError。</p>
<h3 id="popleft"><a href="#popleft" class="headerlink" title="popleft()"></a>popleft()</h3><p>移除并返回一个元素从 deque 的左侧。如果没有元素存在，提出了IndexError。</p>
<h3 id="remove-value"><a href="#remove-value" class="headerlink" title="remove(value)"></a>remove(value)</h3><p>删除值的第一个匹配项。如果未找到，引发ValueError。</p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>翻转 deque 的元素，然后返回None。</p>
<h3 id="rotate-n"><a href="#rotate-n" class="headerlink" title="rotate(n)"></a>rotate(n)</h3><p>deque中的元素向右移动n个位置。如果n是负数的向左移动。向右移动一步相当于： d.appendleft(d.pop())。</p>
<h3 id="maxlen"><a href="#maxlen" class="headerlink" title="maxlen"></a>maxlen</h3><p><code>maxlen</code><br>Deque 的最大长度。如果没有边界，则返回None。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python之路：(十四）I/O多路复用]]></title>
      <url>http://www.liangxiansen.cn/2016/08/05/IO%20Module/</url>
      <content type="html"><![CDATA[<h2 id="回顾原生Socket"><a href="#回顾原生Socket" class="headerlink" title="回顾原生Socket"></a>回顾原生Socket</h2><blockquote>
<p>“他是所有WEB服务器的祖宗”</p>
</blockquote>
<p><code>Socket</code>，用于描述IP地址和端口，是一个通信链的<code>句柄</code>，可以用来实现不同虚拟机或不同计算机之间的通信。在<code>Internet</code>上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个<code>端口</code>上，不同的端口对应于不同的服务,这些服务通过Socket向网络发出请求或者应答网络请求。</p>
<p><code>pupepet、ansible、他们也可以通过输入命令然后返回结果这个也是基于Socket来实现的。</code><br><a id="more"></a></p>
<p>上一篇《初识socket》：server端他们仅能处理一个请求在有连接过来的时候，如果第一个请求在和服务器连接中，那么第二个只能等待第一个断开后第二个才能连接</p>
<p><img src="http://www.liangxiansen.cn/images/socket编程/socket请求流程.png" alt="socket拓扑图"></p>
<p><strong> 过程：</strong><br>第一请求发送了一个操作，server端还未返回，那么现在两头都在等待着输入。<br>那么这段时间第二客户端过来的请求被挂起处于等待状态！</p>
<blockquote>
<p>现在服务端是不是在空闲着呢？他只占着I/O资源，CPU是不是空闲着呢？他阻塞着后面的请求无法进来。<br><code>不急继续往下看</code>！</p>
</blockquote>
<h2 id="网络IO阻塞模型"><a href="#网络IO阻塞模型" class="headerlink" title="网络IO阻塞模型"></a>网络IO阻塞模型</h2><p><strong> 介绍：</strong><br>  网络I/O模型讨论的背景是Linux环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX? Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。</p>
<h3 id="什么是I-O"><a href="#什么是I-O" class="headerlink" title="什么是I/O"></a>什么是I/O</h3><ol>
<li><p><strong>先了解什么是I/O：</strong></p>
<ul>
<li>I/O（input/output），即输入/输出端口。每个设备都会有一个专用的I/O地址，用来处理自己的输入输出信息。</li>
</ul>
</li>
<li><p><strong>I/O models：</strong></p>
<ul>
<li>阻塞:blocking IO</li>
<li>非阻塞:non-blocking IO</li>
<li>同步:synchronous  IO</li>
<li>异步:asynchronous IO</li>
</ul>
</li>
<li><p><strong>IO发生时涉及的对象和步骤：</strong>以输入操作的socket为例：第一步：首先等待网络数据到达，当数据接收就会复制到内核缓冲区中，第二步:复制从内核缓冲区到应用缓冲区</p>
<ul>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中(Copying the data from the kernel to the process)  <code>记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。</code></li>
</ul>
</li>
</ol>
<h3 id="Blocking-I-O-Model"><a href="#Blocking-I-O-Model" class="headerlink" title="Blocking I/O Model"></a>Blocking I/O Model</h3><p>默认情况下所有的Socket是阻塞，看下面的图例:</p>
<p><img src="http://www.liangxiansen.cn/images/socket编程/iomodel1.png" alt="I/O Model"></p>
<blockquote>
<p>当用户进程(<code>应用程序</code>)调用了<code>recvfrom</code>这个系统接口，<code>kernel</code>就开始了IO的<code>第一个阶段</code>：<code>准备数据</code>。对于<code>network io</code>来说，很多时候数据在一开始还没有到达（<code>比如没有收到一个完整的TCP/UDP包</code>），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到<code>数据准备好了</code>，它就会将数据从kernel中<code>拷贝</code>到<code>用户内存</code>，然后<code>kernel返回结果</code>，用户进程才解除 <code>block的状态</code>，重新运行起来。</p>
</blockquote>
<p>所以阻塞:<code>blocking IO</code>的特点是I/O执行时的两个操作（<code>等待数据准备</code>(Waiting for the data to be ready)、<code>将数据从内核拷贝到进程中</code>(Copying the data from the kernel to the process)）<code>都是阻塞的</code>。</p>
<p><strong>Python socket中：accept()  recv() 是阻塞的</strong></p>
<blockquote>
<p>所以，所谓阻塞型接口是指系统调用（一般是IO接口）如果不返回结果就一直阻塞，就是socket经常说的，有发就有收收发必相等如果两边都在同时收，是不是阻塞着后面的代码就无法执行？</p>
</blockquote>
<p><strong> 那既然原生的Socket是阻塞的，那有什么办法来解决呢？</strong></p>
<blockquote>
<p>使用<code>多线程（或多进程）</code>的目的是让每个连接都拥有独立的线程（或进程），这样任何<code>一个连接的阻塞都不会影响其他的连接</code>。</p>
</blockquote>
<p>我们假设对上述的服务器 / 客户机模型，提出更高的要求，即让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型。</p>
<p><img src="http://www.liangxiansen.cn/images/socket编程/iomodel2.png" alt="I/O Model"></p>
<p>在上述的线程 / 时间图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。</p>
<blockquote>
<p>很多人可能不明白为何一个socket可以accept多次。实际上socket的设计者可能特意为多客户机的情况留下了伏笔，让accept()能够返回一个新的socket对象。</p>
</blockquote>
<ul>
<li>执行完bind()和listen()后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。</li>
</ul>
<ul>
<li>调用accept()接口正是从的请求队列抽取第一个连接信息，创建一个新的socket返回句柄。新的socket句柄即是后续read()和recv()的输入参数。如果请求队列当前没有请求，则accept()将进入阻塞状态直到有请求进入队列。</li>
</ul>
<p><code>上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。</code></p>
<blockquote>
<p>很多程序员可能会考虑使用“<code>线程池</code>”或“<code>进程池</code>”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“进程池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。</p>
</blockquote>
<p>这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如<code>websphere</code>、<code>tomcat</code>和各种数据库等。但是，“<code>线程池</code>”和“<code>进程池</code>”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“<code>池</code>”始终有其<code>上限</code>，当请求大大超过上限时，“<code>池</code>”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“<code>池</code>”必须考虑其面临的响应规模，并根据响应规模调整“<code>池</code>”的大小。</p>
<blockquote>
<p>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“进程池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</p>
</blockquote>
<h3 id="非阻塞-non-blocking-IO"><a href="#非阻塞-non-blocking-IO" class="headerlink" title="非阻塞:non-blocking IO"></a>非阻塞:non-blocking IO</h3><pre><code class="python">import time
import socket

sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)  # 创建socket对象
sk.setsockopt
sk.bind((&#39;127.0.0.1&#39;,6666))  # 设置监听的IP与端口
sk.listen(5)  # 设置client最大等待连接数
sk.setblocking(False) # 这里设置setblocking为False accept将不在阻塞，但是如果没有收到请求就会报错

while True:  # 循环
    try:
        print(&#39;waiting client connection .......&#39;)
        # accept()接受客户端发送过来的请求:connection代表客户端对象，address是客户端的IP
        connection, address = sk.accept()
        # recv()接收客户端信息
        client_messge = connection.recv(1024)
        # 打印客户端信息
        print(&#39;client send %s&#39; % client_messge)
        # 发送回执信息给client
        connection.sendall(bytes(&#39;僵尸吃了你的脑子!!!&#39;, encoding=&#39;utf-8&#39;))
        # connection.send()
        # 关闭和client的连接
        connection.close()
    except Exception as error:
        print(error)
    time.sleep(4)
</code></pre>
<p>看上面的代码，修改了setblocking的值，那么现在accept()将不再阻塞。所以他类似下面的图：</p>
<p><img src="http://www.liangxiansen.cn/images/socket编程/iomodel3.png" alt="I/O Model"></p>
<p>EWOULDBLOCK 意思是说：该操作可能会被阻塞。WOULD BLOCK是可能会被阻塞的意思。</p>
<blockquote>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从 用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
</blockquote>
<p>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。     非阻塞的接口相比于阻塞型接口的显著差异在于:<code>在被调用之后立即返回。python中的  sk.setblocking(False)   accept() 将不会阻塞</code></p>
<h3 id="多路复用IO（IO-multiplexing）"><a href="#多路复用IO（IO-multiplexing）" class="headerlink" title="多路复用IO（IO multiplexing）"></a>多路复用IO（IO multiplexing）</h3><p><code>IO multiplexing</code>这个词可能有点陌生，但是如果我说<code>select/epoll/poll</code>，大概就都能明白了。有些地方也称这种IO方式为<code>事件驱动IO(event driven IO)</code>。我们都知道，select/epoll/poll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll/poll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了,就通知用户进程。它的流程如图：</p>
<p><img src="http://www.liangxiansen.cn/images/socket编程/iomodel4.png" alt="I/O Model"></p>
<blockquote>
<p>I/O多路复用指：通过一种机制，可以监视多个描述符，监听的描述符发生了改变，可读了或者可写了，一旦他发生了改变，那我就可以得到一个回调信息或者我主动的去，去知道系统发生变化了,达到一个<code>上下文切换</code>的目的！</p>
</blockquote>
<p>Python中有一个select模块，其中提供了：select、poll、epoll三个方法，分别调用系统的 select，poll，epoll 从而实现IO多路复用。</p>
<blockquote>
<p><strong><code>select:</code></strong></p>
</blockquote>
<blockquote>
<p>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。<br>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p>
</blockquote>
<blockquote>
<p><strong><code>poll:</code></strong></p>
</blockquote>
<blockquote>
<p>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。<br></p>
</blockquote>
<blockquote>
<p><strong><code>epoll:</code></strong></p>
</blockquote>
<blockquote>
<p>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。<br>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。（回调机制决定了epoll不需要像select、poll那样循环得方式去检查文件描述符是否发生改变，而是在一个文件描述符上加一层回调，在使用这个文件描述符得时候会被激活得到通知。）</p>
</blockquote>
<p><code>根据系统不同：他支持的也不同:</code></p>
<pre><code>Windows Python：
    提供： kqueue、select
Mac Python：
    提供： kqueue、select
Linux Python：
    提供： select、poll、epoll、kqueue
</code></pre><blockquote>
<p><strong>注意：</strong>网络操作、文件操作、终端操作等均属于IO操作，对于windows只支持Socket操作，其他系统支持其他IO操作，但是无法检测 普通文件操作 自动上次读取是否已经变化。</p>
</blockquote>
<h4 id="对于Select"><a href="#对于Select" class="headerlink" title="对于Select"></a>对于Select</h4><pre><code>句柄列表11, 句柄列表22, 句柄列表33 = select.select(句柄序列1, 句柄序列2, 句柄序列3, 超时时间)

参数： 可接受四个参数（前三个必须）
返回值：三个列表

select方法用来监视文件句柄，如果句柄发生变化，则获取该句柄。
1、当 参数1 序列中的句柄发生可读时（accetp和read），则获取发生变化的句柄并添加到 返回值1列表中
2、当 参数2 序列中含有句柄时，则将该序列中所有的句柄添加到 返回值2列表中
3、当 参数3 序列中的句柄发生错误时，则将该发生错误的句柄添加到 返回值3列表中
4、当 超时时间 未设置，则select会一直阻塞，直到监听的句柄发生变化
5、当 超时时间 ＝ 1时，那么如果监听的句柄均无任何变化，则select会阻塞 1 秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。
</code></pre><h5 id="利用select监听终端操作实例"><a href="#利用select监听终端操作实例" class="headerlink" title="利用select监听终端操作实例:"></a>利用select监听终端操作实例:</h5><pre><code class="python">import select
import sys

while True:
    readable, writeable, error = select.select([sys.stdin, ], [], [], 1)
    &#39;&#39;&#39;select.select([sys.stdin,],[],[],1)用到I/O多路复用，第一个参数是列表，我放进去的是stdin就是我输入进去东西的描述符,
       相当于打开一个文件，和obj = socket()，类似的文件描述符，
       sys.stdin 他只是一个特殊的文件描述符= 终端的输入，一旦你输入OK select I/O多路复用他就感知到了。
       先看readable这个参数，其他的先不用看一旦你发生了我就他他放到readable里了,readable是一个列表，
       这里添加的就是修改的那个文件描述符，如果你一直没有修改过，那么readable他就是一个空的列表
    &#39;&#39;&#39;
    if sys.stdin in readable:
        message = sys.stdin.readline()
        print(&#39;select get stdin %s&#39; % message)

&#39;&#39;&#39;
注：
1、[sys.stdin,]  以后不管是列表还是元组在最后的元素后面建议增加一个逗号，拿元组举例（1，） | （1） 这两个有区别吗？是不是第二个
更像方法的调用或者函数的调用，加个`，`是不是更容易分清楚。还有就是在以后写django的配置文件的时候，他是必须要加的。写作习惯
2、select第一个参数他就是监听多个文件句柄，当谁改变了我是不是就可以监听到！
3、select参数里1是超时时间，当到select那一行后，如果这里还是没有输入，那么我就继续走！
&#39;&#39;&#39;
</code></pre>
<h6 id="I-O多路复用应用案例-利用select实现伪’同时’处理多个socket客户端请求"><a href="#I-O多路复用应用案例-利用select实现伪’同时’处理多个socket客户端请求" class="headerlink" title="I/O多路复用应用案例:利用select实现伪’同时’处理多个socket客户端请求"></a>I/O多路复用应用案例:利用select实现伪’同时’处理多个socket客户端请求</h6><h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><pre><code class="python"># #!/usr/bin/env python
# # -*- coding:utf-8 -*-
# # Author: Liang Lian
# # Python 3.5

import socket
import select
import queue
import subprocess
import json
sk = socket.socket()  # 创建socket对象
sk.bind((&#39;127.0.0.1&#39;, 6666,))  # 设置监听的IP与端口
sk.listen(5)  # 设置client最大等待连接数
inputs = [sk, ]  # 需要侦听接收消息的socket对象列表
outputs = []  # 所有给server端发过消息的客户端socket列表,都是需要回消息的
messages = {}  # 接受到的消息
# message的样板信息
# message = {
#    &#39;c1&#39;:队列(存放客户端发送过来的消息)
#    &#39;c2&#39;:队列，
# }

while True:  # 循环
    rlist, wlist, e = select.select(inputs, outputs, [], 1)
    meu = &#39;&#39;&#39;
    inputs(侦听已经链接的socket列表): %s
    rlist(侦听的socket中发生变化的socket列表): %s
    wlist(侦听回消息列表,发生变化的socket列表): %s
    outputs(需要回消息的socket列表): %s
    &#39;&#39;&#39;
    print(meu % (len(inputs), len(rlist), len(wlist), len(outputs)))
    # 监听sk(服务器端)对象,如果sk对象发生变化,表示有客户端连接来了,此时rlist值为[sk]
    # 监听connection对象,如果connection发生变化,表示客户端有新消息发过来了,此时rlist的值为[客户端]
    # rlist = [sk,]
    for r in rlist:  # 轮询侦听的socket列表
        if r == sk:  # 如果侦听到是服务端socket发送变化了,说明有新的客户端链接过来了
            connection, address = r.accept()  # 接收客户端对象
            # connection是什么? 其实是客户端socket对象
            inputs.append(connection)  # 加到侦听的socket对象列表中
            messages[connection] = queue.Queue()  # 字典中为这个客户端连接建立一个消息队列
        else:
            &#39;&#39;&#39;
            如果侦听到发送变化的socket对象不是服务端自己的socket,那么就是客户端socket变化了,说明客户端那边发消息过来了
            &#39;&#39;&#39;
            # 有人给我发消息了
            print(&quot;=======&quot;)
            ret = r.recv(1024)  # 接收消息
            if ret:
                p = subprocess.Popen(str(ret, encoding=&#39;utf-8&#39;),
                shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
                res = p.stdout.read()
                if not res:
                    res = &#39;command error&#39;
                # 解决粘包
                msg_size = len(res)
                response_msg = {&#39;status&#39;: &#39;Ready&#39;,
                                &#39;size&#39;: msg_size,
                                &#39;content&#39;: res}
                response_msg = json.dumps(response_msg)
                outputs.append(r)  # 接收完消息后把客户对象加到回消息列表
                messages[r].put(response_msg)  # 把接受到的消息加到字典里面
            else:
                inputs.remove(r)  # 报错,客户端链接断开,删除侦听的客户端socket对象
    # 所有给我发过消息的人
    for w in wlist:
        try:
            msg = messages[w].get_nowait()  # 去指定队列取数据,并且不阻塞
            msg_dict = json.loads(msg)
            w.sendall(bytes(str(msg_dict[&#39;size&#39;]), encoding=&#39;utf-8&#39;))
            recv_tag = w.recv(1024)
            if str(recv_tag, encoding=&#39;utf-8&#39;) == &#39;Start&#39;:
                response = bytes(msg_dict[&#39;content&#39;], encoding=&#39;utf-8&#39;)
                w.sendall(response)     # 反馈消息
                outputs.remove(w)  # 从回消息列表中删除客户端socket对象
            else:
                raise Exception(&#39;断开连接&#39;)
        except Exception as error:  # 发送异常,说明连接中断
            del messages[r]  # 删除接收到的消息

# # rlist = [sk,], rlist=[sk1,],rlist=[sk1,sk2]
# # rlist = []
</code></pre>
<h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import socket
import json
# 侦听的IP和端口
ip_port = (&#39;127.0.0.1&#39;, 6666)
# 创建socket对象
s = socket.socket()
s.connect(ip_port)

while True:
    # 发送消息
    send_data = input(&quot;&gt;&gt;&gt;&quot;).strip()
    # 用户如果没有输入,进入到下一步发送给server端,server接收到空就会堵塞不运行
    if len(send_data) == 0:
        continue
    # 用户输入exit退出
    if send_data == &#39;exit&#39;:
        break
    # 发送用户输入的指令到server端
    s.send(bytes(send_data, encoding=&#39;utf-8&#39;))

    # 接收消息
    # 接收到对方返回结果的准备消息和要返回内容的长度
    msg_szie = 0
    recv_msg = s.recv(1024)
    if recv_msg:
        msg_size = int(str(recv_msg, encoding=&#39;utf-8&#39;))

    # 发送一个&#39;start&#39;给server端,让server端开始发送内容
    start_tag = &#39;Start&#39;
    s.send(bytes(start_tag, encoding=&#39;utf-8&#39;))

    # 通过第一次交互,得知要接受多少数据后,recv_size设置初始值
    recv_size = 0
    recv_msg = b&#39;&#39;

    # 当前接收内容小于总接收内容,则一直持续到接收完
    while recv_size &lt; msg_size:
        recv_data = s.recv(1024)

        # 每次接收内容做拼接
        recv_msg += recv_data
        recv_size += len(recv_data)
    print(str(recv_msg, encoding=&#39;utf-8&#39;))

s.close()
</code></pre>
<blockquote>
<p>如上代码实现可接收接收多个客户端请求和客户端请求的<code>读写分离</code>,但实际上也是一个个处理的,只是把客户端的链接请求和发送消息在服务端分开处理了,分别把变化的记录到list中,然后挨个切换处理,如果同时来大量的话还是会有挂起等待的现象,但是相对原生socket那种<code>原子操作</code>(从连接建立到处理完毕断开连接,整个过程都占用了服务器所有资源)要好很多.</p>
</blockquote>
<h3 id="异步I-O-asynchronous-IO"><a href="#异步I-O-asynchronous-IO" class="headerlink" title="异步I/O(asynchronous IO)"></a>异步I/O(asynchronous IO)</h3><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它收到一个<code>asynchronous</code> read之后，首先它会立刻返回，所以不会对用户进程产生任何<code>block</code>。然后，kernel会等待数据准备完成，然后<code>将数据拷贝到用户内存</code>，当这一切都完成之后，kernel会给用户进程发送一个<code>signal</code>，告诉它read操作完成了。<br>用异步IO实现的服务器这里就不举例了，以后有时间另开文章来讲述。异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>到目前为止，已经将四个IO模型都介绍完了。现在回过头来看下面的问题:</p>
<blockquote>
<p><strong>1、blocking和non-blocking的区别在哪？</strong><br><strong>2、synchronous IO和asynchronous IO的区别在哪？</strong></p>
</blockquote>
<p>回答：</p>
<ul>
<li><strong>1、blocking和non-blocking的区别在哪？</strong><blockquote>
<p><code>blocking</code>与<code>non-blocking</code>。前面的介绍中其实已经很明确的说明了这两者的区别。调用<code>blocking</code> IO会一直block住对应的进程直到操作完成，而<code>non-blocking</code> IO在kernel还在准备数据的情况下会立刻返回。</p>
</blockquote>
</li>
</ul>
<p><img src="http://www.liangxiansen.cn/images/socket编程/iomodel5.png" alt="I/O Model">  <img src="http://www.liangxiansen.cn/images/socket编程/iomodel6.png" alt="I/O Model"></p>
<ul>
<li><strong>2、synchronous IO和asynchronous IO的区别在哪？</strong><br>在说明<code>synchronous IO</code>和<code>asynchronous IO</code>的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<blockquote>
<p>A <code>synchronous I/O</code> operation causes the requesting process to be blocked until that I/O operation completes;<br>An <code>asynchronous I/O</code> operation does not cause the requesting process to be blocked;</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>两者的区别就在于<code>synchronous IO</code>做IO 操作的时候会将进程阻塞。按照这个定义，之前所述的<code>blocking IO</code>，<code>non-blocking IO</code>，IO 多路复用都属于<code>synchronous IO</code>。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个系统调用。</p>
</blockquote>
<ul>
<li>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。</li>
</ul>
<p><img src="http://www.liangxiansen.cn/images/socket编程/iomodel7.png" alt="I/O Model"></p>
<p>而asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h2 id="I-O多路复用的应用场景"><a href="#I-O多路复用的应用场景" class="headerlink" title="I/O多路复用的应用场景"></a>I/O多路复用的应用场景</h2><blockquote>
<ul>
<li>（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</li>
<li>（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
<li>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</li>
</ul>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>罗天帅: <a href="http://www.cnblogs.com/luotianshuai/p/5098408.html" target="_blank" rel="noopener">http://www.cnblogs.com/luotianshuai/p/5098408.html</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python之路：(十三）初识 socket]]></title>
      <url>http://www.liangxiansen.cn/2016/08/05/python-socket/</url>
      <content type="html"><![CDATA[<h2 id="What-is-Socket"><a href="#What-is-Socket" class="headerlink" title="What is Socket"></a>What is Socket</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个<code>socket</code>。<br>Socket的英文原义是<code>孔</code>或<code>插座</code>。作为<code>BSD UNIX</code>的<code>进程通信</code>机制，取后一种意思。通常也称作<code>套接字</code>，用于描述IP地址和端口，是一个通信链的<code>句柄</code>，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务,这些服务通过”套接字”向网络发出请求或者应答网络请求。</p>
<blockquote>
<p>上面是不是很乱？但是概念一定要了解<br>现在是初学，我把Socket理解为一个电话拨通电话，接听电话！通信的一个概念！<br>Scket在写的时候要记住：<code>有发就有收，收发必相等！</code><br><a id="more"></a></p>
</blockquote>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用<code>【打开】【读写】【关闭】</code>模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
<p>socket和file的区别：</p>
<blockquote>
<ul>
<li>file模块是针对某个指定文件进行【打开】【读写】【关闭】</li>
<li>socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】</li>
</ul>
</blockquote>
<h2 id="第一个Socket代码"><a href="#第一个Socket代码" class="headerlink" title="第一个Socket代码"></a>第一个Socket代码</h2><h3 id="socket服务端"><a href="#socket服务端" class="headerlink" title="socket服务端"></a>socket服务端</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import socket

# 创建socket对象
sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
# 设置监听的IP与端口(tuple格式)
sk.bind((&#39;127.0.0.1&#39;,6666))
# 设置client最大等待连接数
sk.listen(5)

while True:  # 循环
    print(&#39;waiting client connection .......&#39;)
    # 只有accept &amp; recv 会阻塞，这里accept阻塞，直到有client连接过来
    # accept()接受客户端发送过来的请求:connection代表客户端对象，address是客户端的IP
    connection, address = sk.accept()
    # recv()接收客户端信息
    client_messge = connection.recv(1024)
    # 接受内容为bytes格式,转换成字符串str;发送消息Python.x只能发送bytes,python2.x能发送str
    client_messge = str(client_messge, encoding=&#39;utf-8&#39;)
    # 打印客户端信息
    print(&#39;client send %s&#39; % client_messge)
    # 发送回执信息给client.
    connection.sendall(bytes(&#39;僵尸吃了你的脑子!!!&#39;, encoding=&#39;utf-8&#39;))
    # 关闭和client的连接
    connection.close()
</code></pre>
<h3 id="socket客户端"><a href="#socket客户端" class="headerlink" title="socket客户端"></a>socket客户端</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import socket

# 端口和IP
ip_port = (&#39;127.0.0.1&#39;, 8888)
# 创建socket对象
sk = socket.socket()
# 创建链接
sk.connect(ip_port)
# 发送消息3.x只能发送bytes,2.x能发送str
sk.sendall(bytes(&#39;请求占领地球&#39;, encoding=&#39;utf-8&#39;))
# 接收数据(1024大小数据(字符))
server_reply = sk.recv(1024)
# 由于client &amp;  Server之前传输的是bytes类型,输出要转换成str类型
print(str(server_reply, encoding=&#39;utf-8&#39;))

sk.close()
</code></pre>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://www.liangxiansen.cn/images/socket编程/socket拓扑.png" alt="socket拓扑图"></p>
<h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><h3 id="socket-socket-socket-AF-INET-socket-SOCK-STREAM-0"><a href="#socket-socket-socket-AF-INET-socket-SOCK-STREAM-0" class="headerlink" title="socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)"></a>socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)</h3><p><strong> 参数一：地址簇 </strong></p>
<blockquote>
<p>socket.AF_INET    IPv4（默认）<br>socket.AF_INET6     IPv6<br>socket.AF_UNIX      只能够用于单一的Unix系统进程间通信</p>
</blockquote>
<p><strong> 参数二：类型 </strong></p>
<blockquote>
<p>socket.SOCK_STREAM    流式socket , for TCP （默认）<br>socket.SOCK_DGRAM       数据报式socket , for UDP<br>socket.SOCK_RAW         原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。<br>socket.SOCK_RDM         是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。<br>socket.SOCK_SEQPACKET   可靠的连续数据包服务</p>
</blockquote>
<p><strong> 参数三：协议 </strong></p>
<blockquote>
<p>0　　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议</p>
</blockquote>
<h4 id="UDP-Dmoe"><a href="#UDP-Dmoe" class="headerlink" title="UDP Dmoe"></a>UDP Dmoe</h4><h5 id="UDP-socket-server"><a href="#UDP-socket-server" class="headerlink" title="UDP socket_server"></a>UDP socket_server</h5><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import socket
ip_port = (&#39;127.0.0.1&#39;,9999)
sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
sk.bind(ip_port)

while True:
    data = sk.recv(1024)
    print(str(data, encoding=&#39;utf-8&#39;))
</code></pre>
<h5 id="UDP-socket-client"><a href="#UDP-socket-client" class="headerlink" title="UDP socket_client"></a>UDP socket_client</h5><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Liang Lian
# Python 3.5

import socket
ip_port = (&#39;127.0.0.1&#39;,9999)

sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0)
while True:
    inp = bytes(input(&#39;数据：&#39;).strip(), encoding=&#39;utf-8&#39;)
    if inp == &#39;exit&#39;:
        break
    sk.sendto(inp, ip_port)

sk.close()
</code></pre>
<h3 id="sk-bind-address"><a href="#sk-bind-address" class="headerlink" title="sk.bind(address)"></a>sk.bind(address)</h3><p>　　s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p>
<h3 id="sk-listen-backlog"><a href="#sk-listen-backlog" class="headerlink" title="sk.listen(backlog)"></a>sk.listen(backlog)</h3><p>　　开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p>
<p>   backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5<br>   这个值不能无限大，因为要在内核中维护连接队列</p>
<h3 id="sk-setblocking-bool"><a href="#sk-setblocking-bool" class="headerlink" title="sk.setblocking(bool)"></a>sk.setblocking(bool)</h3><p>　　是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。</p>
<h3 id="sk-accept"><a href="#sk-accept" class="headerlink" title="sk.accept()"></a>sk.accept()</h3><p>　　接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</p>
<p>　　接收TCP 客户的连接（阻塞式）等待连接的到来</p>
<h3 id="sk-connect-address"><a href="#sk-connect-address" class="headerlink" title="sk.connect(address)"></a>sk.connect(address)</h3><p>　　连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p>
<h3 id="sk-connect-ex-address"><a href="#sk-connect-ex-address" class="headerlink" title="sk.connect_ex(address)"></a>sk.connect_ex(address)</h3><p>　　同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061</p>
<h3 id="sk-close"><a href="#sk-close" class="headerlink" title="sk.close()"></a>sk.close()</h3><p>　　关闭套接字</p>
<h3 id="sk-recv-bufsize-flag"><a href="#sk-recv-bufsize-flag" class="headerlink" title="sk.recv(bufsize[,flag])"></a>sk.recv(bufsize[,flag])</h3><p>　　接受套接字的数据。数据以字符形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p>
<h3 id="sk-recvfrom-bufsize-flag"><a href="#sk-recvfrom-bufsize-flag" class="headerlink" title="sk.recvfrom(bufsize[.flag])"></a>sk.recvfrom(bufsize[.flag])</h3><p>　　与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符，address是发送数据的套接字地址。</p>
<h3 id="sk-send-string-flag"><a href="#sk-send-string-flag" class="headerlink" title="sk.send(string[,flag])"></a>sk.send(string[,flag])</h3><p>　　将string中的数据1以字符的形式发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p>
<h3 id="sk-sendall-string-flag"><a href="#sk-sendall-string-flag" class="headerlink" title="sk.sendall(string[,flag])"></a>sk.sendall(string[,flag])</h3><p>　　将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</p>
<p>   内部通过递归调用send，将所有内容发送出去。</p>
<h3 id="sk-sendto-string-flag-address"><a href="#sk-sendto-string-flag-address" class="headerlink" title="sk.sendto(string[,flag],address)"></a>sk.sendto(string[,flag],address)</h3><p>　　将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。</p>
<h3 id="sk-settimeout-timeout"><a href="#sk-settimeout-timeout" class="headerlink" title="sk.settimeout(timeout)"></a>sk.settimeout(timeout)</h3><p>　　设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）</p>
<h3 id="sk-getpeername"><a href="#sk-getpeername" class="headerlink" title="sk.getpeername()"></a>sk.getpeername()</h3><p>　　返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</p>
<h3 id="sk-getsockname"><a href="#sk-getsockname" class="headerlink" title="sk.getsockname()"></a>sk.getsockname()</h3><p>　　返回套接字自己的地址。通常是一个元组(ipaddr,port)</p>
<h3 id="sk-fileno"><a href="#sk-fileno" class="headerlink" title="sk.fileno()"></a>sk.fileno()</h3><p>　　套接字的文件描述符</p>
<h2 id="socket-练习"><a href="#socket-练习" class="headerlink" title="socket 练习"></a>socket 练习</h2><blockquote>
<p>使用socket实现远程执行命令,并将命令执行结果放回, <code>注意粘包问题</code></p>
</blockquote>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:Liang Lian

import json
import socket
import subprocess

ip_port = (&#39;127.0.0.1&#39;, 8000)
# 创建socket对象
s = socket.socket()
# 侦听的IP和端口
s.bind(ip_port)
# 设置client最大等待连接数,最多等待五个连接,其他的直接报错
s.listen(5)
while True:  # 循环

    # 只有accept &amp; recv 会阻塞，这里accept阻塞，直到有client连接过来
    # accept()接受客户端发送过来的请求:connection代表客户端对象，address是客户端的IP
    connection, address = s.accept()

    while True:
        try:
            # recv()接收客户端信息
            recv_data = connection.recv(1024)

            # 如果为空则退出这层循环,不做操作
            if not recv_data:
                break

            # 接收到client端发送过来的指令并执行
            p = subprocess.Popen(str(recv_data, encoding=&#39;utf-8&#39;), shell=True, stdout=subprocess.PIPE)
            # 获取命令输出结果
            res = p.stdout.read()
            if res:
                send_data = str(res, encoding=&#39;utf-8&#39;)
            else:
                send_data = &#39;cmd error&#39;

            # str转换bytes
            send_data = bytes(send_data, encoding=&#39;utf-8&#39;)

            # 发送准备就绪和准备要发送的内容长度,防止粘包(发送内容超出接收端内容,多出的内容出现在下一次接收得内容中)
            &#39;&#39;&#39;
            粘包: 命令执行结果返回字符串长度为2018,如果客户端只接受1024,就接受了一次,那么多出来的内容回去哪呢,
                  多出来的内容会出现在下一次返回前头,这就是粘包(分包传递,内容接收端发生错误)
            &#39;&#39;&#39;
            # 讲要发送的内容信息json格式发送客户端,客户端好做好准备接收
            ready_dict = {&#39;status&#39;: &#39;Ready&#39;,
                          &#39;msg_size&#39;: len(send_data),}
            ready_tag = json.dumps(ready_dict)
            connection.send(bytes(ready_tag, encoding=&#39;utf-8&#39;))

            # 等待client &#39;Start&#39;信号后开始
            feedback = connection.recv(1024)   # Start
            feedback = str(feedback, encoding=&#39;utf-8&#39;)
            if feedback == &#39;Start&#39;:
                # 发送指令返回结果的内容
                connection.send(send_data)

        except Exception:
            break

    # 关闭和client的连接
    connection.close()
</code></pre>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:Liang Lian

import socket
import json
# 服务端侦听的IP和端口
ip_port = (&#39;127.0.0.1&#39;, 8000)
# 创建socket对象
s = socket.socket()
s.connect(ip_port)

while True:
    # 发送消息
    send_data = input(&quot;&gt;&gt;&gt;&quot;).strip()
    # 用户如果没有输入,进入到下一步发送给server端,server接收到空就会堵塞不运行
    if len(send_data) == 0:
        continue
    # 用户输入exit退出
    if send_data == &#39;exit&#39;:
        break

    # 发送用户输入的指令到server端
    s.send(bytes(send_data, encoding=&#39;utf-8&#39;))

    # 接收到对方返回结果的准备消息和要返回内容的长度
    ready_tag = s.recv(1024)  # Ready json格式
    ready_tag = str(ready_tag, encoding=&#39;utf-8&#39;)
    msg_dict = json.loads(ready_tag)
    if msg_dict[&#39;status&#39;] == &#39;Ready&#39;:
        msg_size = msg_dict[&#39;msg_size&#39;]

    # 发送一个&#39;start&#39;给server端,让server端开始发送内容
    start_tag = &#39;Start&#39;
    s.send(bytes(start_tag, encoding=&#39;utf-8&#39;))

    # 通过第一次交互,得知要接受多少数据后,recv_size设置初始值
    recv_size = 0
    recv_msg = b&#39;&#39;  # 初始化一个bytes格式追加接收内容

    # 当前接收内容小于总接收内容,则一直持续到接收完
    while recv_size &lt; msg_size:
        recv_data = s.recv(1024)

        # 每次接收内容做拼接
        recv_msg += recv_data
        recv_size += len(recv_data)
    # 打印服务端返回结果
    print(str(recv_msg, encoding=&#39;utf-8&#39;))
s.close()
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>罗天帅: <a href="http://www.cnblogs.com/luotianshuai/p/5058562.html" target="_blank" rel="noopener">http://www.cnblogs.com/luotianshuai/p/5058562.html</a></li>
<li>武沛齐: <a href="http://www.cnblogs.com/wupeiqi/articles/5040823.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5040823.html</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[美丽得旅途-云南]]></title>
      <url>http://www.liangxiansen.cn/2016/08/04/%E7%BE%8E%E4%B8%BD%E5%BE%97%E6%97%85%E9%80%94-%E4%BA%91%E5%8D%97/</url>
      <content type="html"><![CDATA[<p> <font size="5">旅行</font>一直是在我脑海里憧憬得画面，从未真正为自己得心踏出过这一步。除了偶尔得家庭组织出去玩和工作得变迁在几个地方待过，真的没怎么出去看过我们生活得这个世界是什么样的。</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/yunnan0.jpg" alt="看看世界"></center><br>在今年得十一月，我有一个必须请假离开北京，回老家得理由。（我弟生日，[笑哭] <code>-_-|||</code> ，他说他过生日我不回去要打死我，<code>╮(╯_╰)╭</code> 我弟只比我小几个月，是表弟！），好吧，虽然你会觉得这个理由有点扯，但是我真的是必须要回去。<br><a id="more"></a><br> 想吧，既然要回去，我就得请假。我正好有五天倒休，加上周末正好七天。七天哇~ <code>&lt;(*￣▽￣*)/</code> 我就光回去陪他过个生日在家呆着是不是有点“浪费”了呢，嘿嘿~。我正好有一个一直想去得城市，想了很久了，以前自己资金薄弱，家里压力大，真心不敢想像我要去旅行我妈会是什么脸色 <code>(╯﹏╰)</code>. 现在我工作稳定，收入还行(主要是有点积蓄了 <code>&lt;(￣︶￣)&gt;</code>）所以我决定是时候应该为自己得心踏出这一步了呢~！<br>我和我弟说我回家给他过完生日我带他去云南玩吧，他同意了，这样我们就愉快得决定了去云南玩儿了，我妈也同意了。——云南（我要来了~ <code>(～￣▽￣)～</code>）<br>公司请好假以后，11月11日我早晨8点便坐上了回家得火车~~ （是的，你没看错是11月11日，这样一个悲伤又改成剁手得日子，我逃离逃离逃离~~    我一天都在火车上，哇哈哈哈~<code>╮(╯▽╰)╭</code>)<br><br><center><img src="http://www.liangxiansen.cn/images/yunnan/images.jpeg" alt="哈哈"></center>

<h2 id="第1天（11-11）"><a href="#第1天（11-11）" class="headerlink" title="第1天（11/11）"></a>第1天（11/11）</h2><p>我都说了我在车上~  一天！！！    晚上11点多我到了长沙，去我姐那，然后第二天回去给我弟过生日，是的他是12号生日。晚上长沙超大得雨，特别特别大，像泼一样！（听我姐说之前还没下的，天呐，这是为了欢迎我来才下得么。。。<code>(#‵′)靠！</code>）在长沙得朋友知道，长沙一下大雨地面就成海洋了。虽然机智得我做了万全准备，带了伞回来，我真的没有查天气，但是我机智得带了，哇哈哈哈~~        然后并没有卵用 〒▽〒，我还是被淋得够惨，伞太小，雨太大，当时得我在自然得力量面前是那么渺小无力。大晚上得，还好姐来接我了，天黑黑得真心有点找不到地，爱你哦~！ 终于到了，衣服、裤子、鞋子都光荣牺牲了，突然发现行李箱里面既然也有些湿了，我觉得没有比当时更惨得事了。晚上用烤炉烤衣服，吃姐姐给我炒的干豆角炒红薯粉，乐观得我觉得之前得事即是五个字：“那都不是事~”  炒粉有点辣，感觉在北方呆久了，我吃辣得能力被他们带到了同一个档次。。。<br>用吹风机吹了会鞋子，感觉差不多了，困得不行躺下睡了。（已是晚上2点多）</p>
<h2 id="第2天（11-12）"><a href="#第2天（11-12）" class="headerlink" title="第2天（11/12）"></a>第2天（11/12）</h2><p>早晨起来，鞋子还有点湿又吹我吹~<br>不得不佩服自己，机智得我带了两双鞋子,我换双鞋穿上，收拾好行李去车站坐车回涟源（我的老家），给我弟过生日，中午十二点顺利得赶到了差点就赶不上了。<code>幸运点1：因为早晨起晚了十点才上的大巴，到涟源快得都要两个半小时，我让师傅快点开，在12点钟的时候我们快到涟源了，我弟他在酒店请客，快开席了，我让跟师傅说了下酒店地址，能不能快送我到那，师傅人挺好的，改变了路线，走经过那得路线，但是整个车上的人都不乐意了，突然改变路线绕别的路，师傅 3q3q3q3q哦~！ 好人~</code><br>在12:25顺利赶到了，看到了家人们，嗨皮得吃~<br>吃饱喝足，我们年轻人换地点继续嗨~~<br>最后结果都跑网吧五黑去了， 在网吧大喊~看我的大宝剑~（德玛）~~<br>晚上换地点继续吃~（生日不就是这样过吗，怪我咯~）<br> 然后继续大宝剑~~  这….    可能下午黑的不够爽吧，我很少玩，被骂的也似不多。。。。</p>
<h2 id="第3天（11-13）"><a href="#第3天（11-13）" class="headerlink" title="第3天（11/13）"></a>第3天（11/13）</h2><p>第二天go go go~<br>订得是长沙飞昆明得机票！<br><code>（攻略1：①机票在去哪儿上订好便宜，当然时间点比较好的也很贵；②提前订，不要当天走当天订贵死你，提前订会很便宜！）</code><br>我们第二天醒了后去车站坐车去长沙，在长沙我姐那里着落下，中午姐姐下厨吃好吃的，厨艺真得是可以嘞~！（可以嫁了）下午陪他们去逛街，走走走 我走~~</p>
<p>快到登记时间了，提前准备好去机场，一切顺顺利利得~！<br>晚上10点到了昆明机场，给家里人打电话报个平安，给在昆明得朋友说了声。出了机场我发现没有机场大巴了，6点就没车了，好吧只能打车离开了。<br>我朋友在安宁市，我们刚出机场有很多人搭讪: 帅哥,你要去哪呀（<code>幸运点2</code>） 我说去安宁多少钱啊，他说280过关费什么得他出。。。。。等跟我说。我心一想，天呐，坐个出租车300？！（在北京过的节省，这价钱不接受了）；我说太贵了吧，他和我解释了一大通怎么怎么怎么的，机智得我出现（双重人格），我想这太贵了我滴滴打车吧，刚发出去就有司机接了，但是那司机直接要300，那个还只要280呢，当时就不乐意了 我说100去不去，他说你开玩笑吧，跟我说有多少公里呢（不记得了），我挂电话了，滴滴又摇了几个车纷纷问了价钱，然后之前第一个拦我 得私家车得人旁边也在和我说，几个司机下来都是要280 300左右 有一个说200多点，旁边得按耐不住时不时降价，降到240了，机智得我对旁边得说我帅得那个人说别人200，还是出租车，我觉得他那个安全点，你还能不能少了，要不我做他那个走了，他最后一次降到180，我看也是只能这样了，别人也不容易，就这样愉快的决定了，180他送我们去安宁。<br>机智得我耍的一手好招~啦啦啦！</p>
<p><code>（攻略2：①货比三家，一不小心就被宰了；当然你要看司机是个怎么样的人，人不老实那种还是做出租车吧，外面安全第一；②可以拍下车牌发给朋友或亲人）</code></p>
<p>师傅人挺好得，一路给我们讲解云南得特色和特色，比如为啥建不了地铁、火车我要了个名片！<br>顺利抵达安宁已经11点多了，我朋友接得我们，我们去吃东西，说说5年没见了呢，但是真是感触时间过得好快啊，不知不觉我们都长大了，都有变化了！<br>随后便回酒店休息了，好累~~！（找的离我朋友家很近得一家酒店）<br>附这位美女照片一张：</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/wenting.jpeg" alt="wenting"></center>

<h2 id="第4天（11-14）"><a href="#第4天（11-14）" class="headerlink" title="第4天（11/14）"></a>第4天（11/14）</h2><p>因为昨天晚上商量今天早点起来去看看这得早晨。。。困~！<br>早晨吃当地当地那个像蛋卷那样得卷饼，但是使用“粑粑”卷的刷点辣酱放点菜挺好吃的，还吃当云南正宗过桥米线咯，其他地吃的对比一下我想哭，其他得太难吃了，这里得好吃呢。这个得里面料自己选：（鸡肉、豆干、木耳、鱼片、火腿肠、豆腐皮。。。等）<br>我们早晨去湖边（宁湖）散步，说是散步哈哈哈 各种拍照~~ （被迷倒了~）<br>这里得空气好好哦~  在北京吸尘器得生活和这里比我感觉来到了天堂。（刚好早晨有雾，是雾不是雾霾）<br>附上仙境般得景色：</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/longhu0.jpeg" alt="龙湖"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/longhu1.jpeg" alt="龙湖"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/longhu2.jpeg" alt="龙湖"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/longhu3.jpeg" alt="龙湖"></center>


<p>下午下午。。我们回来准备一下，去昆明昆明西山风景区玩~</p>
<blockquote>
<p>“睡美人山，龙门飞峙”。远眺西山群峰，既像一尊庞大的睡佛，又似一个美丽曲腿仰卧在滇池畔，象青丝垂海的睡美人。因此西山称为“卧佛山”，又称为“睡美人山”。</p>
</blockquote>
<p>我们做观光大巴上半山腰得，直接到了索道那一块，由于出发之前买了好多吃的，我们坐那边消灭些吃的，我看那边丝巾挺好看得买了几条。<br>坐索道坐索道~~~  碰到了一个导游小妹妹，（<code>幸运点3</code>）他当我们得导游。索道是一次两人得，我和我弟做一块，我朋友和导游坐一块，在索道上往昆明市里面看还是挺美得，特别是滇池整个都能看到，美呆了~   索道上向下看有些地方还是很高得，胆子小的人慎坐，最好有人陪一块儿。<br>下山得时候是最适合拍照得，很多有故事得建筑，导游给我详细的解说着每一块得故事由来，然而我们得心全部都在玩耍拍照上，各种臭美。下山得路特别陡，一定要慢。路是沿着石壁敲凿出来得。从下往上看你人都是在石壁边走，不过那里向下看很美很美，如果说索道上看滇池全景很美是大气得美，而在这看就是更近得去感受去这种美，距离刚刚好，下山得是要经过龙门得，龙门上得珠子摸一下会好运得样子，石壁上左右两边有一条龙和一条鱼，顺着鱼头摸到鱼尾年年有余（哈哈现学现卖，都是听导游说的.）</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/西山.jpeg" alt="西山"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/西山0.jpeg" alt="西山"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/西山1.jpeg" alt="西山"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/西山2.jpeg" alt="西山"></center>


<p>山上各种嗨，去庙里求福，坐下来听当地人解说当地茶和品茶~<br>被山上美景陶醉了，忘了时间，我们下山已经6点了，导游带我们到他们村里那边品尝当地菜，（一个大锅炖好多罗非鱼），导游得妈妈也一块，大家一块吃。 阿姨特别热情，一上来就给我们每个人盛了满满一碗鱼<code>(*＾-＾*)</code>，吃饭中一直叫我们吃，吃完又给我们盛了一大碗[笑哭] X﹏X ，我吃了4个鱼头 X﹏X ，吃的好撑~</p>
<p>吃完饭我们又去滇池公园、滇池大坝去玩 （我们玩得好疯啊！！！）滇池晚上好大得浪，打的岸边溅出好多浪花，浪花都冲上了岸上，根本不敢靠近旁边呢。听导游说如果赶上好时候滇池公园岸边草地上会有好多海鸥呢，好可惜（我要看海鸥~我要抓海鸥~~），接着我们又在滇池大坝上奔跑吵闹，直到玩到大家都累了才离开<code>╮(╯_╰)╭</code><br>我们玩得这么开心，都是导游得功劳呢，之前吃饭听说他们家电脑有问题，我决定帮忙给看一下了，我们回去得时候去他们家给帮忙修了下，比较我是计算机专业得，这点问题还是难不倒我得，搞定了完了都很晚了，导游得叔叔开车送我们去外面等车的地方。<br>大晚上好大得风哦~好冷~  我们在路边等大巴。。。。。<br>那时候已经是10点多了吧，知道等到10:8分确定最后一班车没有了。。。。<br>这之间有一辆黑车曾停下来揽我们，我们没上。。<br><code>（攻略3：在外头，又是晚上不要上黑车，这样很不安全的，没准他给你拖到哪里去了呢）</code><br>导游让他叔叔送我们去，他说他自己找朋友送她回去（帮了我们好多呢，都不好意思了，很感谢她呢）<br>玩得太嗨了~   累~！  我们泡温泉去啦  啦啦啦~<br>天下第一汤！这是要炖了我们的意思嘛~！</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/天下第一汤.jpeg" alt="天下第一汤"></center><br>泡完温泉又吃夜宵，我好幸福~！！ 安宁烤鱼好吃哦~！<br>回酒店了，困呐<del>~ 玩得太疯了</del>! (晚上酒店电视我弟按得放天龙八部  好怀念~  听着声音睡得 电视放了一晚上)<br><br><center><img src="http://www.liangxiansen.cn/images/yunnan/231H12U6-1.jpg" alt="哈哈"></center>

<h2 id="第5天（11-15）"><a href="#第5天（11-15）" class="headerlink" title="第5天（11/15）"></a>第5天（11/15）</h2><p>今天进军“世界恐龙谷”！！</p>
<blockquote>
<p>北有兵马俑，南有恐龙谷！！</p>
</blockquote>
<p>做了几个小时得车，车上吃着东西，经过几个小时的车程我们愉快得到了恐龙谷脚下<br>迷迷糊糊找不到上山得路（看建筑物在山上） 我们沿着山路顺着走上去。。。<br>终于上完一个坡，我不知道还要走到哪，看到一个铁门能进去恐龙谷里面，但是看着好像是锁着得，进不去。但是我又不想再往前面走了。。。。<br>我走到铁门前，发现不是锁着的，（<code>幸运点4</code>）我轻轻推门进去 问有人吗？~<br>我们带着疑问进入到里面得一个建筑物里面问这是不是恐龙谷（我们走的不是正常路线哇）<br>我们走进得是一个很大得餐厅，我们问一个很漂亮得姐姐问他这里是不是恐龙谷呀，他疑惑得问：你们怎么进来得，这里是呀。我指着我们进来的那个门。他有点逗趣得说你们都进来了，票都省了。我们顿时乐了，她让我们快进去吧，别被保安发现了。  我们谢过后快乐得进去了。 哈哈哈！  我们时而高兴得喊一下意识到我们走后门进来得又把声音压低，现在想起来逗死我了!</p>
<p>那天天气好好哦~在恐龙谷里面忍不住又疯狂得各种拍 拍 拍~</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷0.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷1.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷2.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷3.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷4.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷5.jpeg" alt="恐龙谷"></center>

<p>碰上美丽得风景欲罢不能，躺草地上享受贪婪得享受着此刻得美好，一路欢声笑语、拍照逗比~~~！<br>我们光享受外面得美景，忘了这里有恐龙化石博物馆了，要不是看到有导游带游客去博物馆都不知道怎么去，我们跟着一路蹭着导游进入博物馆感受几千年前得恐龙文化和了解他们得生活和毁灭。</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷6.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷7.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷8.jpeg" alt="恐龙谷"></center>

<p>除了博物馆看到真实的恐龙化石旁边还有一个恐龙生活馆，里面有虚拟影视技术播放4D电影，观看恐龙毁灭得原因，但是陨石撞击地球，我们脚下踩得那块铁板猛地震动，一不留神下得不轻，我朋友当时吓到了。<br>恐龙谷里面还有游乐设施我们赶得时机不是很好，只玩了一些，有的不能玩。</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷9.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷10.jpeg" alt="恐龙谷"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/恐龙谷11.jpeg" alt="恐龙谷"></center>

<p>在里面我们玩得跟孩子似得，怪我咯~~！<strong><code>ㄟ( ▔, ▔ )ㄏ</code></strong></p>
<h2 id="第6天（11-16）"><a href="#第6天（11-16）" class="headerlink" title="第6天（11/16）"></a>第6天（11/16）</h2><p>一路向西去大理~~！  （等等，我是纯洁得，我是去看风景得&lt;(￣︶￣)&gt;）<br>我们连夜坐大巴到得大理，在大巴上睡了一晚，第二天早晨8点到得。下车后遇到搭讪得，说帅哥 要住客栈吗？ （又说我帅哥)<br>我觉得合适他接送我们到客栈，客栈也不贵80一晚（差不多都是这个价），很有特色是当地白族人民开的。接送省去了我们很多麻烦，我们也很疲惫了。<br>到了酒店选的2楼得房间，走廊布置得竹编得椅子都很舒服，也能看到一楼。（3楼看不到，中间有层玻璃）我们洗漱躺了会。（洗漱完感觉自己萌萌哒~ 不累了 ）我们便决定出去古城逛逛（选的客栈在古城南门附近，离的很近）<br><code>（攻略4：①不用刻意去回避找你搭讪得人，毕竟他叫你帅哥/美女，不是说人人都是坏人，只要谈得来你觉得可以，可以开心接受他们得热情，毕竟当地他们熟，能省去你很多事；②大理客栈也是旅游得一种特色，选择一间自己喜欢得客栈给旅行加分）</code></p>
<p>进入大理古城，我们买了个帽子顺应当时气氛，当时感觉自己萌萌哒~~</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/大理.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理1.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理0.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理2.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理3.jpeg" alt="大理"></center>


<p>当时天气很好呢，进入古城被两边得店铺吸引了，名俗气息浓厚，各种小饰品、衣服、装饰品、挂件、陶瓷、小吃、酒吧。。。真是体内剁手煞气发作了，一路一边抵制一边又受不了去看了。</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/大理4.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理5.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理6.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理7.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理8.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理9.jpeg" alt="大理"></center>


<p>上午逛完古城，中午吃古城小吃，洱海田螺。。。。<br>下午我们决定去洱海，经过一番问路，我们找到了2路公交车站牌（2路直接到洱海码头），在等车于是魔性得搭讪又来了（<code>幸运点5</code>），这次不是叫我帅哥了，是个大爷看我打扮（带着你这样帽子，不知道才怪）知道我是来旅游得，问我要不要坐船，我听了这不是正事我们想得吗？ 我说是呀，是呀！他说带我去，拿票便宜。我说好啊。（反正都是要去得对吧，而且本地人带我去拿不管是不是便宜了，到时看不就知道了，票上一般写着价钱的）<br>我们坐上了公交车，在车上我旁边的人走了 ，我站在旁边，大爷看了我，我马上说大爷你坐这吧，（大爷估计也有个50多岁了）我又做好事了，这样会让旅途心情愉快。（没准大爷觉得我小伙不错更便宜给我呢 嘿嘿~）<br>当我在脑海YY得时候，我们到了，洱海码头。宽敞得洱海码头，来几张美美得图。</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/大理10.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理11.jpeg" alt="大理"></center>

<p>票价是180，给我们拿得是100，看大爷得神色不像是骗我。我愉快得买了两张票。<br>坐船咯，做船船咯~~<br>海上风和大，站在船头很嗨啊~~~·</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/大理12.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理13.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理14.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理15.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理16.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理17.jpeg" alt="大理"></center>

<p>票是出发去两个岛上看旅游景点，接送直到返回。<br>金锁岛得烤鱼不错哦，（流口水~！还看到了海鸥，红嘴海鸥。</p>
<center><img src="http://www.liangxiansen.cn/images/yunnan/大理18.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理19.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理20.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理21.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理22.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理23.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理24.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理25.jpeg" alt="大理"></center><br><center><img src="http://www.liangxiansen.cn/images/yunnan/大理26.jpeg" alt="大理"></center>

<h2 id="第7天（11-17）"><a href="#第7天（11-17）" class="headerlink" title="第7天（11/17）"></a>第7天（11/17）</h2><p>在不舍中踏上回京行程，这次旅行给我带来了很多快乐，遇到了很多可爱的人，收获了很多<code>幸运点</code>。<br>我得旅行中有你们陪我在和那些可爱得人出现，我很幸运，谢谢你们！<br>我远方得朋友，虽然我们5年没见了，见面也很少，都在为自己生活中事情忙碌，但是经过这次旅行更让我确信你是我生命中很重要得朋友。<br>我想我和我弟都会记住这次快乐得旅行。<br><code>（攻略5：只要你是开心得，好运自然来，整个旅途我都是开心得，特别特别开心，超级开心~！）</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python其他理解与思考]]></title>
      <url>http://www.liangxiansen.cn/2016/08/03/python%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h3 id="Python中作用域"><a href="#Python中作用域" class="headerlink" title="Python中作用域"></a>Python中作用域</h3><ul>
<li>python中无块级作用域,python中以<code>函数为作用域</code></li>
</ul>
<pre><code class="python">if 1 == 1:
    name = &#39;alex&#39;

print(name)
</code></pre>
<p>输出结果：<code>alex</code><br><a id="more"></a></p>
<ul>
<li>python代码还没执行的时候,作用域就已经形成了</li>
</ul>
<pre><code class="python">name = &#39;alex&#39;


def f1():
    print(name)


def f2():
    name = &#39;eric&#39;
    f1()

f2()
</code></pre>
<p>输出结果: <code>alex</code></p>
<blockquote>
<p>请思考:<br>1.为什么if 判断里面定义的不一定为执行的变量会有值,<br>2.为什么执行f2函数输出的是<code>alex</code>而不是<code>eric</code></p>
</blockquote>
<h3 id="烧脑的新浪面试题"><a href="#烧脑的新浪面试题" class="headerlink" title="烧脑的新浪面试题"></a>烧脑的新浪面试题</h3><pre><code class="python"># return x
li = [lambda: x for x in range(10)]
# li列表
# li列表中的元素[函数,函数,函数,函数...]
# 函数在没有执行前,内部代码不执行
# ? li[0] ,函数
# ? 函数()
# 返回值是???
r = li[0]()
print(r)
</code></pre>
<p>输出结果: <code>9</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(玩转ZABBIX)Dell 服务器硬件信息监控，自动生成服务器资产信息]]></title>
      <url>http://www.liangxiansen.cn/2016/08/02/zabbix-mosa/</url>
      <content type="html"><![CDATA[<p>Zabbix 一直想监控服务器硬件信息,而DELL OMSA很好的反馈满足了我想要监控得内容,通过OMSA和脚本的实现,对zabbix得熟练玩法实现了服务器的硬件信息监控和自动生成服务器硬件资产信息.</p>
<p>1、服务器自带的工具，比如HP的hpacucli，DELL的OMSA等<br>2、智能平台管理接口 （IPMI，全称Intelligent Platform Management Interface）<br>基于以上两种，通过nagios、zabbix或自研运维平台等包裹，进行预警操作。<br>由于公司使用的服务器全部为DELL PowerEdge系列的，这里将以如何对DELL PowerEdge系列服务器硬件进行监控这一实际案例为主。</p>
<a id="more"></a>
<h3 id="OMSA-介绍"><a href="#OMSA-介绍" class="headerlink" title="OMSA 介绍"></a>OMSA 介绍</h3><p>DELL OMSA的全称为<code>Dell Openmanage Server Administrator</code>，它是戴尔公司基于自主研发力量开发的IT系统管理解决方案，通过与业内领先的系统管理解决方案供应商密切配合，在深入了解用户对系统管理需求的基础上，OMSA系统管理方案可以全面解决系统管理人员最关心的系统部署、系统监控和系统变更三大系统管理问题。它通过提供以下两种方式来对本地和远程的服务器进行管理和监控。<br>界面：<br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/omsa-login.png" alt="OMSA 登录界面"><br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/omsa-meu.png" alt="OMSA 菜单"></p>
<h3 id="zabbix监控"><a href="#zabbix监控" class="headerlink" title="zabbix监控"></a>zabbix监控</h3><h5 id="zabbix介绍"><a href="#zabbix介绍" class="headerlink" title="zabbix介绍"></a>zabbix介绍</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-logo.jpg" alt="ZABBIX"><br>Zabbix是一款功能很齐全且定制性能强得开源项目，能够很好得解决了企业内服务器系统性能得监控、网络质量得监控、网络设备使用情况得监控、以及各个业务使用情况得监控（自己定义监控项）、还有硬件监控；<br>能够通过使用者自己得想法去满足企业中各种监控需求，使用的人如果思想越活跃（业内称会玩），能够满足很多各式各样得监控，只有你想不到没有做不到。</p>
<blockquote>
<p>举个栗子：我的一个朋友给自己得女朋友监控一个商品页面的价钱，达到自己满意得价钱给她发短信  （哈哈，484很嗨森 (∩_∩)）</p>
</blockquote>
<p>官方网站：<a href="http://www.www.zabbix.com" target="_blank" rel="noopener">点击这里</a></p>
<h4 id="脚本监控-直接获取值的监控项："><a href="#脚本监控-直接获取值的监控项：" class="headerlink" title="脚本监控,直接获取值的监控项："></a>脚本监控,直接获取值的监控项：</h4><p>这里基于zabbix 开源监控平台，自己编写监控脚本，通过自定义key得方式在zabbix中进行数据监控和故障预警。<br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item.png" alt="硬件监控"></p>
<h4 id="LLD-自动发现"><a href="#LLD-自动发现" class="headerlink" title="LLD 自动发现"></a>LLD 自动发现</h4><p>由于有些服务器部件是变动得，所以基于LLD<code>（Low-level discovery）</code>动态得发现设备并基于我指定得监控项模板创建监控项</p>
<h5 id="模板创建监控项："><a href="#模板创建监控项：" class="headerlink" title="模板创建监控项："></a>模板创建监控项：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-temp.png" alt="硬件监控项模板"></p>
<h5 id="RAID状态监控"><a href="#RAID状态监控" class="headerlink" title="RAID状态监控:"></a>RAID状态监控:</h5><p>由于服务器上可能会创建多个raid，并且raid级别各不一样<br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-raid.png" alt="硬件RAID卡监控"></p>
<h5 id="机箱状态监控："><a href="#机箱状态监控：" class="headerlink" title="机箱状态监控："></a>机箱状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-server.png" alt="硬件机箱状态监控"></p>
<h5 id="BBU电池状态监控："><a href="#BBU电池状态监控：" class="headerlink" title="BBU电池状态监控："></a>BBU电池状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-bbu.png" alt="硬件BBU电池监控"></p>
<h5 id="CPU硬件状态监控："><a href="#CPU硬件状态监控：" class="headerlink" title="CPU硬件状态监控："></a>CPU硬件状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-cpu.png" alt="硬件CPU硬件状态监控"></p>
<h5 id="内存硬件状态监控："><a href="#内存硬件状态监控：" class="headerlink" title="内存硬件状态监控："></a>内存硬件状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-mem.png" alt="硬件内存硬件状态监控"></p>
<h5 id="硬件温度监控："><a href="#硬件温度监控：" class="headerlink" title="硬件温度监控："></a>硬件温度监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-tmp.png" alt="硬件温度监控"></p>
<h5 id="硬件电压状态监控："><a href="#硬件电压状态监控：" class="headerlink" title="硬件电压状态监控："></a>硬件电压状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-volt.png" alt="硬件电压状态监控"></p>
<h5 id="硬件电源状态监控："><a href="#硬件电源状态监控：" class="headerlink" title="硬件电源状态监控："></a>硬件电源状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-power.png" alt="硬件电源状态监控"></p>
<h5 id="硬盘硬件状态监控："><a href="#硬盘硬件状态监控：" class="headerlink" title="硬盘硬件状态监控："></a>硬盘硬件状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-disk.png" alt="硬件硬盘状态监控"></p>
<h5 id="网卡硬件状态监控："><a href="#网卡硬件状态监控：" class="headerlink" title="网卡硬件状态监控："></a>网卡硬件状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-intf.png" alt="硬件网卡状态监控"></p>
<h5 id="风扇硬件状态监控："><a href="#风扇硬件状态监控：" class="headerlink" title="风扇硬件状态监控："></a>风扇硬件状态监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-fans.png" alt="硬件风扇状态监控"></p>
<h5 id="硬件资产监控："><a href="#硬件资产监控：" class="headerlink" title="硬件资产监控："></a>硬件资产监控：</h5><p><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-assets.png" alt="硬件资产监控"></p>
<h4 id="自动生成硬件资产信息"><a href="#自动生成硬件资产信息" class="headerlink" title="自动生成硬件资产信息"></a>自动生成硬件资产信息</h4><p>在很多服务器得情况下，一般使用zabbix监控得用户，当某个机器告警了，要连上去看一下得时候，不知道这台机器得IP。一般会到zabbix右上角搜索一台机器，然后点击去找到这个机器得IP或者域名，然后登陆到服务器上查看。（我们告警得时候告警得是机器得alias名称——别名，不会选择报IP，因为别名让收告警得用户更好知道这台是台提供什么得服务器或者作用。）<br>在这个基础上我又在监控得机器上加入了很多信息，并且不是手动去输入得都是自动生成的。服务器情况从此不管是运行状态还是设备信息都能从监控这一个平台全部看到。<br>下面是效果：<br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-assetslist.png" alt="硬件资产信息"><br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-assetslist1.png" alt="硬件资产信息"><br><img src="http://www.liangxiansen.cn/images/zabbix-omsa/zabbix-item-assetslist2.png" alt="硬件资产信息"><br>从刚开始探索硬件监控到写脚本实现，从线下测试到线上全部测试，再到模板得创建，修复大大小小不协调问题，监控项得慢慢完善才有了现在这套监控。脚本总共有415行代码！</p>
<div class="github-widget" data-repo="LiangXianSen/Dell-OMSA-monitor"></div>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 搭建个人博客]]></title>
      <url>http://www.liangxiansen.cn/2016/03/05/hexo/</url>
      <content type="html"><![CDATA[<h2 id="Hexo-搭建个人博客"><a href="#Hexo-搭建个人博客" class="headerlink" title="Hexo 搭建个人博客"></a>Hexo 搭建个人博客</h2><p>你可以选择购买主机搭建动态博客 - <a href="https://wordpress.org/" target="_blank" rel="noopener">WordPress</a>等，也可以使用<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>来搭建一个静态的个人博客。我选择了现在很热门的<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> + <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 的方式来搭建独立的个人博客。</p>
<p>在搭建个人博客的过程中，你可能会使用到下面几个网站。在这几个网站中都有相应的官方文档及教程。如果官方文档不能满足你，那么请<a href="https://www.google.com/" target="_blank" rel="noopener">Google</a>。</p>
<p><a href="https://github.com/" target="_blank" rel="noopener">Github 官网</a><br><a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a><br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo 官网</a><br><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js 官网</a><br><a href="http://www.git-scm.com/" target="_blank" rel="noopener">Git 官网</a></p>
<h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>登入<a href="https://github.com/" target="_blank" rel="noopener">Github 网站</a>，在你的主页点击图标<a href="https://github.com/new" target="_blank" rel="noopener"> New Repository </a>创建一个新的版本库，因为我们是使用Github 仓库的<a href="https://pages.github.com" target="_blank" rel="noopener"> Github Pages </a>去搭建我们的静态博客，所以版本库的名称是你以后博客的地址，博客名 +  <code>.github.io</code>。如：我的用户名是：<code>liangxiansen</code>，那么版本库的名字应该是：<a href="https://github.com/LiangXianSen/liangxiansen.github.io" target="_blank" rel="noopener"> liangxiansen.github.io </a>，这个是一定不能出错的。因为之后你将要访问的你的博客地址就是：<a href="https://liangxiansen.github.io" target="_blank" rel="noopener"> https://liangxiansen.github.io </a>。</p>
<p><img src="http://www.liangxiansen.cn/images/hexo/github.io.png" alt="github.io"></p>
<blockquote>
<p>这个仓库地址 命名格式必须是 +  <code>github.io</code> 的形式</p>
</blockquote>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo的安装在其<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>中有很详细的说明。下面将简单介绍Hexo的安装。</p>
<ul>
<li>安装<a href="https://nodejs.org/" target="_blank" rel="noopener"> Node.js </a>，请进入Node.js 的官网下载安装。</li>
</ul>
<ul>
<li>安装<a href="http://www.git-scm.com/" target="_blank" rel="noopener"> Git </a>，前面已经说明，不再赘述。</li>
</ul>
<p>上面两个工具安装完整之后，只需要使用npm即可完成Hexo的安装。</p>
<pre><code>npm install -g hexo-cli
</code></pre><p>安装Hexo完成之后，执行下面的命令，Hexo将会在你制定的文件夹中新建所需要的文件。</p>
<pre><code>hexo init &lt;folder&gt;
cd &lt;folder&gt;
npm install
</code></pre><p>新建完成后，文件夹下的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><ul>
<li><strong>_config.yml</strong> 文件是网站的配置文件，可以在其中配置网站的大部分参数。</li>
<li><strong>package.json</strong> 文件是应用程序的信息。</li>
<li><strong>source</strong> 是资源文件夹，是用来存放用户资源的地方。</li>
<li><strong>themes</strong> 是<a href="https://hexo.io/themes" target="_blank" rel="noopener">主题</a>文件夹，Hexo会根据主题来生成不同的静态页面。</li>
<li><strong>scaffolds</strong>是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。</li>
</ul>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>先进入你的Hexo文件夹 <code>themes</code> 里面，选择一个<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>下载：</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next.git
</code></pre><p>然后打开Hexo主文件夹下的<strong>_config.yml</strong>，修改其中的<code>theme</code> 属性。<code>theme:</code> 后面要加空格。</p>
<h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><pre><code>hexo generate #生成静态页面，生成的内容在public文件夹下
hexo server #启动本地服务，进行文章预览调试。hexo s --debug 命令可以用来调试
</code></pre><p>在浏览器输入： <a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> 进行查看</p>
<h3 id="发布到Github"><a href="#发布到Github" class="headerlink" title="发布到Github"></a>发布到Github</h3><p>先使用下面的命令对Git进行初始配置。</p>
<pre><code>git config --global user.name &quot;your name&quot;
git config --global user.email &quot;email@email.com&quot;
</code></pre><p>然后打开Hexo主文件夹下的<strong>_config.yml</strong>，设置其中的<code>deploy</code> 参数，详细请查看Hexo官方文档中<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署部分</a>。</p>
<p>我的设置如下所示：</p>
<pre><code>deploy:
  type: git 
  repository: https://github.com/LiangXianSen/liangxiansen.github.io.git
  branch: master
</code></pre><p>在上面的参数设置好了之后，使用下面的命令安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener"> hexo-deployer-git </a>插件，只有安装了插件之后才可以部署到Github Pages。</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>安装完插件之后使用下面的命令进行部署：</p>
<pre><code>hexo generate #生成静态文件
hexo deploy #部署到github
</code></pre><p>还有一个更快捷的命令：</p>
<pre><code>hexo deploy -g #在部署前先生成
</code></pre><blockquote>
<p>在浏览器输入：<a href="https://xxx.github.io" target="_blank" rel="noopener">https://xxx.github.io</a> 即可访问刚刚发布的网站了。</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>hexo</code> 目录下的 <code>db.json</code> 文件不要随便删除，里面记录了好多信息，我删了后发现我的blog的访问量的纪录全没了（手动捂脸～）。</li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
